<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-06-17 Mon 11:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Many-Core Levels</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Many-Core Levels</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb9278f4">1. Introduction</a></li>
<li><a href="#orge42ec70">2. System definition</a></li>
<li><a href="#org881de83">3. The library</a></li>
<li><a href="#orgee10bd5">4. The hardware description language HDL</a></li>
<li><a href="#org5d80b01">5. Many-Core Programming Language</a></li>
<li><a href="#orgb460fb6">6. Passes</a></li>
<li><a href="#orgfdd9db2">7. Micro-passes</a></li>
<li><a href="#org4a9c255">8. Commandline</a></li>
<li><a href="#org454f804">9. The main module</a></li>
<li><a href="#orgf37fe43">10. Copying </a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb9278f4" class="outline-2">
<h2 id="orgb9278f4"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Many-Core Levels is a programming system that supports the methodology
"Stepwise-refinement for performance".  The system allows one to write
computational kernels for different kinds of many-core hardware. It consists of
two languages: a hardware description language HDL and a programming language
MCPL. HDL allows one to define hardware with different levels of detail, which
results in different abstraction levels. MCL defines a hierarchy of hardware
descriptions, starting with hardware description perfect. Each lower-level
hardware description defines many-core hardware in more detail. MCPL allows one
to write computational kernels that are mapped to hardware by specifying which
hardware description is targeted and by using constructs that define a mapping
between algorithm and hardware.  For more details, refer to [1].
</p>

<p>
This document discusses the code that is written in a literate-programming
style with <a href="https://orgmode.org">Org-mode</a> files.  The code exports to this documentation and to the
source code itself.
</p>

<p>
MCL has been released under license GPL version 3.
</p>

<p>
[1] Pieter Hijma, Rob V. van Nieuwpoort, Ceriel J.H. Jacobs, and Henri E. Bal:
Stepwise-refinement for Performance: a methodology for many-core programming
Concurrency and Computation: Practice and Experience, 27: 4515–4554. DOI:
<a href="https://doi.org/10.1002/cpe.3416">10.1002/cpe.3416</a>.
</p>
</div>
</div>

<div id="outline-container-orge42ec70" class="outline-2">
<h2 id="orge42ec70"><span class="section-number-2">2</span> System definition</h2>
<div class="outline-text-2" id="text-2">
<div id="text-table-of-contents">
<ul>
<li><a href="#org88d38f5">2.1. Defining a package for the system definition:</a></li>
<li><a href="#orgc7c7655">2.2. Setting up the environment</a></li>
<li><a href="#org672af33">2.3. Top-level definition</a></li>
<li><a href="#org9115405">2.4. The main files</a></li>
<li><a href="#org6b0e390">2.5. The library</a></li>
<li><a href="#orgf3cd12e">2.6. The micro passes</a></li>
<li><a href="#orgc43901b">2.7. The passes</a></li>
<li><a href="#orgc765ab7">2.8. The commandline</a></li>
<li><a href="#org98d1c98">2.9. The tests</a></li>
<li><a href="#orgf4d7187">2.10. Maxima</a></li>
<li><a href="#org09cd69f">2.11. Quickutil</a></li>
</ul>
</div>

<p>
MCL and its libraries depend on many files.  Below, the system definition is
explained.
</p>
</div>

<div id="outline-container-org88d38f5" class="outline-3">
<h3 id="org88d38f5"><span class="section-number-3">2.1</span> Defining a package for the system definition:</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:mcl-asd</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:asdf</span> <span style="color: #483d8b;">:uiop</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc7c7655" class="outline-3">
<h3 id="orgc7c7655"><span class="section-number-3">2.2</span> Setting up the environment</h3>
<div class="outline-text-3" id="text-2-2">
<p>
MCL depends on many libraries that will be submoduled in the original
repository.  Therefore, we do not rely on the main systems file, but on a
custom one.  We set up the main environment variables (for MCL and quicklisp)
and setup the central repository for systems such that we are looking in or own
submodule directory.  We also have to setup quicklisp again.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:mcl-asd</span>)

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*mcl-root-dir*</span> <span style="color: #8b2252;">"MCL_ROOT_DIR"</span>)
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*quicklisp-dir*</span> <span style="color: #8b2252;">"QUICKLISP_DIR"</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-env-var</span> (var)
  (<span style="color: #a020f0;">if</span> (not (getenvp var))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Environment variable ~a is not set."</span> var)
      (getenv var)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-env-dir</span> (var)
  (format nil <span style="color: #8b2252;">"~a/"</span> (get-env-var var)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-system-dir</span> ()
  (merge-pathnames <span style="color: #8b2252;">"lib/systems/"</span> (get-env-dir *mcl-root-dir*)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-quicklisp-dir</span> ()
  (get-env-dir *quicklisp-dir*))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">(setf *central-registry* (list *default-pathname-defaults* (get-system-dir)))</span>
(pushnew (get-system-dir) *central-registry*)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(let ((quicklisp-init (merge-pathnames "setup.lisp" (get-quicklisp-dir))))</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(when (probe-file quicklisp-init)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(load quicklisp-init)))</span>
</pre>
</div>

<p>
Because ASDF alone is not capable of loading moptilities and cl-graph in a
good way, we use quicklisp to do that using <code>asdf-system-connections</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(ql:quickload <span style="color: #483d8b;">:asdf-system-connections</span>)
(<span style="color: #a020f0;">unless</span> (or (member <span style="color: #483d8b;">:asdf-system-connections</span> *features*)
            (find-system 'asdf-system-connections nil))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"MCL needs asdf-system-connections"</span>))
(<span style="color: #a020f0;">when</span> (and (not (member <span style="color: #483d8b;">:asdf-system-connections</span> *features*))
           (find-system 'asdf-system-connections nil))
  (operate 'load-op 'asdf-system-connections))
(ql:quickload <span style="color: #483d8b;">:cl-graph</span>)
<span style="color: #b22222;">;;</span><span style="color: #b22222;">(ql:quickload :cl-graph-and-moptilities)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org672af33" class="outline-3">
<h3 id="org672af33"><span class="section-number-3">2.3</span> Top-level definition</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(defsystem <span style="color: #483d8b;">:mcl</span>
    <span style="color: #483d8b;">:depends-on</span> (<span style="color: #483d8b;">:cl-ppcre</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:cl-fad</span>
                           <span style="color: #483d8b;">:cl-utilities</span> <span style="color: #483d8b;">:esrap</span> <span style="color: #483d8b;">:parser.common-rules</span>
                           <span style="color: #483d8b;">:parser.common-rules.operators</span>
                           <span style="color: #483d8b;">:string-case</span> <span style="color: #483d8b;">:iterate</span> <span style="color: #483d8b;">:cl-log</span> 
                           <span style="color: #483d8b;">:net.didierverna.clon</span> <span style="color: #483d8b;">:clon-completion</span> <span style="color: #483d8b;">:kebab</span>
                           <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:cl-graph-extension</span>
                           <span style="color: #483d8b;">:code-emitter</span>)
    <span style="color: #483d8b;">:components</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9115405" class="outline-3">
<h3 id="org9115405"><span class="section-number-3">2.4</span> The main files</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">
<pre class="src src-lisp">((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"mcl-quickutil"</span>)
 (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span> <span style="color: #483d8b;">:depends-on</span> (library micro-passes passes))
 (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"main"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6b0e390" class="outline-3">
<h3 id="org6b0e390"><span class="section-number-3">2.5</span> The library</h3>
<div class="outline-text-3" id="text-2-5">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> library
         <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"mcl-quickutil"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:module</span> parsing <span style="color: #483d8b;">:depends-on</span> (ast)
                   <span style="color: #483d8b;">:components</span>
                   ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
                    (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"parsing"</span>
                           <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> ast
          <span style="color: #483d8b;">:components</span>
          ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
           (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"ast-macros"</span>
                  <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
           (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"library"</span>
                  <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span> <span style="color: #8b2252;">"visitor-macros"</span>))
           (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"visitor-macros"</span>
                  <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> ast-mcpl <span style="color: #483d8b;">:depends-on</span> (ast)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"ast"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"printing"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"accessors"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span> <span style="color: #8b2252;">"ast"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> build-ast <span style="color: #483d8b;">:depends-on</span> (ast-mcpl)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"build-ast"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> ast-hdl <span style="color: #483d8b;">:depends-on</span> (ast)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"ast"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"printing"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> pass-library
         <span style="color: #483d8b;">:depends-on</span> (errors check-consistency-ast logging)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"pass-library"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> logging
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"logging"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> controlflow <span style="color: #483d8b;">:depends-on</span> (ast ast-mcpl)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"macros-controlflow"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"controlflow"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span> <span style="color: #8b2252;">"macros-controlflow"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"cfgraph"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"library"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> callgraph
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"callgraph"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> dataflow <span style="color: #483d8b;">:depends-on</span> (ast ast-mcpl controlflow)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"dataflow"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"dataflow-elements"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"library"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> errors
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"errors"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> hardware-descriptions
         <span style="color: #483d8b;">:depends-on</span> (mcl-util)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"macros"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"hardware-descriptions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> check-consistency-ast
         <span style="color: #483d8b;">:depends-on</span> (query-hdl-mcpl)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"check-consistency-ast"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> query-hdl-mcpl
         <span style="color: #483d8b;">:depends-on</span> (ast ast-hdl ast-mcpl hardware-descriptions)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"query-hdl-mcpl"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> mcl-util
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"mcl-util"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf3cd12e" class="outline-3">
<h3 id="orgf3cd12e"><span class="section-number-3">2.6</span> The micro passes</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> micro-passes <span style="color: #483d8b;">:depends-on</span> (library)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:module</span> parse-mcpl 
                   <span style="color: #483d8b;">:components</span>
                   ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
                    (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"parser"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
                    (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"library"</span>
                           <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> parse-hdl
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"parser"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"library"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> set-parents
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"set-parents"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> resolve-vars
         <span style="color: #483d8b;">:depends-on</span> (resolve-exports)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"resolve-vars"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> resolve-exports
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"resolve-exports"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> set-callgraph
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"set-callgraph"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> resolve-calls
         <span style="color: #483d8b;">:depends-on</span> (resolve-exports)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"resolve-calls"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> resolve-types
         <span style="color: #483d8b;">:depends-on</span> (resolve-exports)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"resolve-types"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> set-vars-written <span style="color: #483d8b;">:depends-on</span> (print-pretty aliases)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"set-vars-written"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> print-pretty
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"print-pretty"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> print
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"print"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> print-ast-json
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"print-ast-json"</span> <span style="color: #483d8b;">:depends-on</span>
                 (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> set-cfgraphs
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"set-cfgraphs"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> print-bb
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"print-bb"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> definitions <span style="color: #483d8b;">:depends-on</span> (def-variables)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"definitions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> uses <span style="color: #483d8b;">:depends-on</span> (use-variables)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"uses"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> aliases <span style="color: #483d8b;">:depends-on</span> (check-types print-dataflow)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"aliases"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> reaching-definitions
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"reaching-definitions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> print-dataflow <span style="color: #483d8b;">:depends-on</span> (print-bb)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"print-dataflow"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> use-variables <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"use-variables"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> def-variables <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"def-variables"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> on-device-variables
         <span style="color: #483d8b;">:depends-on</span> (def-variables use-variables)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"on-device-variables"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> dataflow-on-device-variables
         <span style="color: #483d8b;">:depends-on</span> (on-device-variables)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"dataflow-on-device-variables"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> set-entry-exit-on-device-variables
         <span style="color: #483d8b;">:depends-on</span> (dataflow-on-device-variables
                      on-device-variables)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"set-entry-exit-on-device-variables"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> flatten-types <span style="color: #483d8b;">:depends-on</span> (simplify-expressions)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"flatten-type"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> flatten-var <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"flatten-var"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> dependencies <span style="color: #483d8b;">:depends-on</span> (reaching-definitions)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"dependencies"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> on-device-decls <span style="color: #483d8b;">:depends-on</span> (dependencies)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"on-device-decls"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> visualize-graph <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"visualize-graph"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> visualize-cfgraph
         <span style="color: #483d8b;">:depends-on</span> (print-bb visualize-graph)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"visualize-cfgraph"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> visualize-callgraph
         <span style="color: #483d8b;">:depends-on</span> (print-pretty visualize-graph)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"visualize-callgraph"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> visualize-dataflow-graph
         <span style="color: #483d8b;">:depends-on</span> (print-pretty print-bb visualize-graph)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"visualize-dataflow-graph"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> translate <span style="color: #483d8b;">:depends-on</span> (load-hardware-descriptions)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"equivalence"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"translate-memory-spaces"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"translate-foreach"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"translate"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> simplify-expressions <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"simplify-expressions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> replace-id-stats <span style="color: #483d8b;">:depends-on</span> (set-parents)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"replace-id-stats"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> load-hardware-descriptions
         <span style="color: #483d8b;">:depends-on</span> (set-parents replace-id-stats parse-hdl)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"load-hardware-descriptions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> check-package
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"check-package"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> check-memory-spaces
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"check-memory-spaces"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> check-exports
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"check-exports"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> fold-constants
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"fold-constants"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> remove-hardware-vars
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"remove-hardware-vars"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> move-dimension-constants
         <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"move-dimension-constants"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> move-foreach-to-func
         <span style="color: #483d8b;">:depends-on</span> (move-stats-to-func)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"move-foreach-to-func"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> move-foreach-to-func-cashmere
         <span style="color: #483d8b;">:depends-on</span> (move-stats-to-func)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"move-foreach-to-func-cashmere"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> move-stats-to-func
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"move-stats-to-func"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> move-stats-out-func
         <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"move-stats-out-func"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> specialize-funcs-on-ms
         <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"specialize-funcs-on-ms"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> generate-transfers
         <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"macros"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"helper-functions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span> <span style="color: #8b2252;">"macros"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"generate-transfers"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span> <span style="color: #8b2252;">"macros"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> generate-allocations
         <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"generate-allocations"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> remove-unnecessary-transfers
         <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"remove-unnecessary-transfers"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> generate-code
         <span style="color: #483d8b;">:depends-on</span> (check-types)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"gen-generic"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"output-files"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"library"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"gen-cpp-header"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"gen-opencl"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"generators"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"gen-cpp"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"gen-cashmere"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> transform-tile-expressions
         <span style="color: #483d8b;">:depends-on</span> ()
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"transform-tile-expressions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> check-types <span style="color: #483d8b;">:depends-on</span> (flatten-types fold-constants)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"check-types"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"numeric-types"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"assignment-rules"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"type-equivalence"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"compute-types"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"type-errors"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc43901b" class="outline-3">
<h3 id="orgc43901b"><span class="section-number-3">2.7</span> The passes</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> passes <span style="color: #483d8b;">:depends-on</span> (library micro-passes)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"semantic-analysis"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"print-pretty"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"print-ast-json"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"flatten-types"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"translate"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"remove-hardware-vars"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"move-foreach-to-func"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"move-foreach-to-func-cashmere"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"generate-transfers"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"specialize-funcs-on-ms"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"generate-code"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"generate-cashmere-code"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"transform-tile-expressions"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc765ab7" class="outline-3">
<h3 id="orgc765ab7"><span class="section-number-3">2.8</span> The commandline</h3>
<div class="outline-text-3" id="text-2-8">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> commandline
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"commandline"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))))
</pre>
</div>
</div>
</div>



<div id="outline-container-org98d1c98" class="outline-3">
<h3 id="org98d1c98"><span class="section-number-3">2.9</span> The tests</h3>
<div class="outline-text-3" id="text-2-9">
<div class="org-src-container">
<pre class="src src-lisp">(defsystem <span style="color: #483d8b;">:mcl/tests</span>
    <span style="color: #483d8b;">:depends-on</span> (<span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:cl-ppcre</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:anaphora</span>
                           <span style="color: #483d8b;">:cl-utilities</span> <span style="color: #483d8b;">:esrap</span> <span style="color: #483d8b;">:parser.common-rules</span>
                           <span style="color: #483d8b;">:parser.common-rules.operators</span>
                           <span style="color: #483d8b;">:string-case</span> <span style="color: #483d8b;">:iterate</span> <span style="color: #483d8b;">:cl-log</span> 
                           <span style="color: #483d8b;">:code-emitter</span> <span style="color: #483d8b;">:mcl</span>)
    <span style="color: #483d8b;">:components</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">((<span style="color: #483d8b;">:module</span> tests
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-mcl"</span> <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:module</span> test-parse-mcpl <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
                   <span style="color: #483d8b;">:components</span>
                   ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
                    (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-parser"</span>
                           <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-parse-hdl  <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-parser"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-print-pretty <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-print-pretty"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-resolve-calls <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-resolve-calls"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-dataflow-library <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"library"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-reaching-definitions <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:depends-on</span> (test-dataflow-library)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-reaching-definitions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-dependencies <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:depends-on</span> (test-dataflow-library)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-defs-with-uses"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-dependencies"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-on-device-variables <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:depends-on</span> (test-dataflow-library)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-on-device-variables"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-aliases <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:depends-on</span> (test-dataflow-library)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-aliases"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>



<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-set-vars-written <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-set-vars-written"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-set-cfgraphs <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-set-cfgraphs"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-flatten-types <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-flatten-type"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-flatten-var <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-flatten-var"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-translate <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-translate"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-simplify-expressions <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-simplify-expressions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-replace-id-stats <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-replace-id-stats"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-ast-mcpl <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-ast-mcpl"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-check-memory-spaces <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-check-memory-spaces"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-specialize-funcs-on-ms <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-specialize-funcs-on-ms"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-generate-transfers <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-generate-transfers"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-generate-allocations <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-generate-allocations"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-definitions <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-definitions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-transform-tile-expressions <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-transform-tile-expressions"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #483d8b;">:module</span> test-check-types <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>)
         <span style="color: #483d8b;">:components</span>
         ((<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"packages"</span>)
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"macros"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span>))
          (<span style="color: #483d8b;">:file</span> <span style="color: #8b2252;">"test-check-types"</span>
                 <span style="color: #483d8b;">:depends-on</span> (<span style="color: #8b2252;">"packages"</span> <span style="color: #8b2252;">"macros"</span>))))))))
</pre>
</div>
</div>
</div>




<div id="outline-container-orgf4d7187" class="outline-3">
<h3 id="orgf4d7187"><span class="section-number-3">2.10</span> Maxima</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Maxima does have a <code>.asd</code> file, but SBCL fails to load it properly as it seems
to convert a warning into an error.  We use Maxima's native build system to
compile and load it.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-maxima-dir</span> ()
  (<span style="color: #a020f0;">let</span> ((dir (getenv <span style="color: #8b2252;">"MCL_ROOT_DIR"</span>)))
    (<span style="color: #a020f0;">unless</span> dir
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Environment variable MCL_ROOT_DIR has not been set"</span>))
    (merge-pathnames <span style="color: #8b2252;">"lib/maxima-5.41.0/"</span> (uiop/pathname:parse-unix-namestring dir <span style="color: #483d8b;">:ensure-directory</span> t))))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*maxima-dir*</span> (get-maxima-dir))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">load-file</span> (pathname)
  (format t <span style="color: #8b2252;">"~a/~a"</span> *maxima-dir* pathname)
  (load (format nil <span style="color: #8b2252;">"~a/~a"</span> *maxima-dir* pathname)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">load-maxima</span> ()
  (with-current-directory ((merge-pathnames <span style="color: #8b2252;">"src/"</span> *maxima-dir*))
    (load-file <span style="color: #8b2252;">"src/maxima-build.lisp"</span>)
    (mcl-asd::maxima-load)))

(<span style="color: #a020f0;">unless</span> (find-package <span style="color: #483d8b;">:maxima</span>)
  (load-maxima))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-dir-string</span> (file-spec)
  (format nil <span style="color: #8b2252;">"~a~a"</span> (unix-namestring *maxima-dir*) file-spec))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-maxima-file-list</span> (<span style="color: #228b22;">&amp;rest</span> file-specs)
  (cons '(cl-user::mlist cl-user::simp) (mapcar #'make-dir-string file-specs)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-maxima-vars</span> ()
  (setf maxima::$file_search_maxima (make-maxima-file-list
                                     <span style="color: #8b2252;">"share/$$$.{mac,mc}"</span>
                                     <span style="color: #8b2252;">"share/stringproc/$$$.{mac,mc}"</span>)
        maxima::$file_search_lisp (make-maxima-file-list
                                   <span style="color: #8b2252;">"share/$$$.{fasl,lisp,lsp}"</span>
                                   <span style="color: #8b2252;">"share/stringproc/$$$.{fasl,lisp,lsp}"</span>
                                   <span style="color: #8b2252;">"src/$$$.{fasl,lisp,lsp}"</span>)))

(set-maxima-vars)
(maxima::$load <span style="color: #8b2252;">"stringproc"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org09cd69f" class="outline-3">
<h3 id="org09cd69f"><span class="section-number-3">2.11</span> Quickutil</h3>
<div class="outline-text-3" id="text-2-11">
<p>
Loading things from Quickutil does not seem to work properly.  Therefore, we
create our custom file that we load with the system.  We can create the utility
file with the following command:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(qtlc:save-utils-as <span style="color: #8b2252;">"system/mcl-quickutil.lisp"</span>
                    <span style="color: #483d8b;">:utilities</span> '(<span style="color: #483d8b;">:map-tree</span> <span style="color: #483d8b;">:iota</span> <span style="color: #483d8b;">:transpose</span>) <span style="color: #483d8b;">:package</span> <span style="color: #483d8b;">:mcl-quickutil</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org881de83" class="outline-2">
<h2 id="org881de83"><span class="section-number-2">3</span> The library</h2>
<div class="outline-text-2" id="text-3">
<p>
This section shows the libraries that are used within MCL.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#orgfda7bcf">3.1. Parsing</a>
<ul>
<li><a href="#org6eb7d98">3.1.1. The package</a></li>
<li><a href="#orga9b64e5">3.1.2. The common parsing functions</a></li>
</ul>
</li>
<li><a href="#orge8929a9">3.2. AST</a>
<ul>
<li><a href="#org5df88c9">3.2.1. The package</a></li>
<li><a href="#org1e033cc">3.2.2. Defining an AST</a></li>
<li><a href="#org0d23ecc">3.2.3. Helper functions</a>
<ul>
<li><a href="#org858760b">3.2.3.1. The root of the AST</a></li>
<li><a href="#org49fcc20">3.2.3.2. Equality of ASTs</a></li>
<li><a href="#org33eb54b">3.2.3.3. Parents of ASTs</a></li>
<li><a href="#org92bcac4">3.2.3.4. Children of ASTs</a></li>
<li><a href="#org40742ad">3.2.3.5. Siblings of ASTs</a></li>
<li><a href="#org33f9eee">3.2.3.6. Visitors</a></li>
<li><a href="#orgae10929">3.2.3.7. Visitor macros</a></li>
<li><a href="#orgd93c46b">3.2.3.8. Deep copies</a></li>
<li><a href="#orga8ef0c0">3.2.3.9. Replacing AST nodes</a></li>
<li><a href="#orge050aae">3.2.3.10. Removing AST nodes</a></li>
<li><a href="#org4a4d1dc">3.2.3.11. Inserting AST nodes</a></li>
<li><a href="#org83cf355">3.2.3.12. Declaration for the children method.</a></li>
<li><a href="#org67c0091">3.2.3.13. Printing the AST</a></li>
<li><a href="#org2402c7b">3.2.3.14. Querying the AST</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgae4949e">3.3. Building AST forms</a>
<ul>
<li><a href="#org3cdc62f">3.3.1. The package</a></li>
<li><a href="#orgd7ff6b0">3.3.2. Building AST-forms</a>
<ul>
<li><a href="#org4e4f775">3.3.2.1. Declarations</a></li>
<li><a href="#org6af5917">3.3.2.2. Types</a></li>
<li><a href="#orge68c4c5">3.3.2.3. Statements</a></li>
<li><a href="#org61af2c8">3.3.2.4. Variables</a></li>
<li><a href="#org11061c6">3.3.2.5. Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org59be09c">3.4. Errors</a>
<ul>
<li><a href="#orga743db4">3.4.1. The package</a></li>
<li><a href="#orgd8b0ecf">3.4.2. The errors</a>
<ul>
<li><a href="#org70d7ba5">3.4.2.1. Macros for generating an error function</a></li>
<li><a href="#org5a92d56">3.4.2.2. Common errors</a></li>
<li><a href="#org96fb8e8">3.4.2.3. Pass errors</a></li>
<li><a href="#org6efb181">3.4.2.4. Parse errors</a></li>
<li><a href="#org14712e7">3.4.2.5. Define/resolve errors</a></li>
<li><a href="#org4b8ec33">3.4.2.6. Constant/written variables</a></li>
<li><a href="#org8a6e4e7">3.4.2.7. Type errors</a></li>
<li><a href="#org950c774">3.4.2.8. Memory-space errors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0f9b3ad">3.5. Callgraph</a>
<ul>
<li><a href="#orgfca803b">3.5.1. The package</a></li>
<li><a href="#orgaa95100">3.5.2. The functionality</a></li>
</ul>
</li>
<li><a href="#org717a170">3.6. Control-flow graph</a>
<ul>
<li><a href="#orgc1f1a84">3.6.1. The package</a></li>
<li><a href="#org12956e5">3.6.2. The graph</a></li>
<li><a href="#org6bf3219">3.6.3. The main interface</a></li>
<li><a href="#org666692d">3.6.4. Macros</a></li>
<li><a href="#org0fa6f16">3.6.5. Library functions for controlflow</a></li>
</ul>
</li>
<li><a href="#org4c4b600">3.7. Dataflow</a>
<ul>
<li><a href="#orgb51ee2c">3.7.1. Defining the package</a></li>
<li><a href="#org578c9b2">3.7.2. The basic dataflow framework</a></li>
<li><a href="#org3ff04f7">3.7.3. Generic functions</a></li>
<li><a href="#orgba58f48">3.7.4. Basic dataflow-elements</a></li>
<li><a href="#org884c660">3.7.5. Some utility functions</a></li>
<li><a href="#org70d577e">3.7.6. Debugging functions</a></li>
<li><a href="#org7a0248d">3.7.7. A library to help testing dataflow</a>
<ul>
<li><a href="#org2fbe8bf">3.7.7.1. The package</a></li>
<li><a href="#org9be05c5">3.7.7.2. The functionality</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org342e5ca">3.8. Hardware descriptions</a>
<ul>
<li><a href="#org7761a38">3.8.1. The package</a></li>
<li><a href="#org988cce1">3.8.2. Retrieving the hardware descriptions</a></li>
<li><a href="#orge0a0757">3.8.3. Macros</a></li>
<li><a href="#orgd00afdb">3.8.4. The device hierarchy</a></li>
<li><a href="#org3cc675d">3.8.5. Resolving names in hardware descriptions</a></li>
<li><a href="#org52d505f">3.8.6. Predicate functions for collect and retrieve</a></li>
<li><a href="#org670f0c9">3.8.7. Generic query functions for hardware descriptions</a></li>
</ul>
</li>
<li><a href="#org477d0b7">3.9. Querying HDL and MCPL</a>
<ul>
<li><a href="#orgae41d5d">3.9.1. The package</a></li>
<li><a href="#org4d14a02">3.9.2. The functionality</a></li>
</ul>
</li>
<li><a href="#orga6638df">3.10. The pass library</a>
<ul>
<li><a href="#org6e55cbb">3.10.1. The package</a></li>
<li><a href="#org7943c38">3.10.2. The functionality</a></li>
</ul>
</li>
<li><a href="#org11721d6">3.11. Check consistency AST</a>
<ul>
<li><a href="#org60a8cd2">3.11.1. The package</a></li>
<li><a href="#org1af4e2f">3.11.2. The functionality</a>
<ul>
<li><a href="#org96ad623">3.11.2.1. Checking parents/child relationship</a></li>
<li><a href="#org104afa8">3.11.2.2. Checking decls/vars relationship</a></li>
<li><a href="#org19821db">3.11.2.3. Checking the function/call relationship</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdfd5884">3.12. Logging</a>
<ul>
<li><a href="#org9dfe608">3.12.1. The package</a></li>
<li><a href="#org2419a8f">3.12.2. The functionality</a>
<ul>
<li><a href="#orgd264098">3.12.2.1. External functions</a></li>
<li><a href="#orgcea4330">3.12.2.2. The internals</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc9fea6e">3.13. Utilities</a>
<ul>
<li><a href="#orgb2a88e0">3.13.1. The package</a></li>
<li><a href="#orga402e09">3.13.2. The utility functions</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgfda7bcf" class="outline-3">
<h3 id="orgfda7bcf"><span class="section-number-3">3.1</span> Parsing</h3>
<div class="outline-text-3" id="text-3-1">
<p>
There are some functions and terminals and non-terminals that are common among
the two parsers.  
</p>
</div>

<div id="outline-container-org6eb7d98" class="outline-4">
<h4 id="org6eb7d98"><span class="section-number-4">3.1.1</span> The package</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:parsing</span>
     (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:esrap</span> <span style="color: #483d8b;">:parser.common-rules</span> <span style="color: #483d8b;">:ast</span>)
     (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:*filename*</span>
              <span style="color: #483d8b;">:skippable</span>
              <span style="color: #483d8b;">:skippable?</span>
              <span style="color: #483d8b;">:defkw</span>
              <span style="color: #483d8b;">:identifier</span>
              <span style="color: #483d8b;">:make-loc</span>
              <span style="color: #483d8b;">:do-left-assoc</span>
              <span style="color: #483d8b;">:do-right-assoc</span>
              <span style="color: #483d8b;">:do-non-assoc</span>
              <span style="color: #483d8b;">:semi-colon/?s</span>
              <span style="color: #483d8b;">:block-open/?s</span>
              <span style="color: #483d8b;">:block-close/?s</span>
              <span style="color: #483d8b;">:equals/?s</span>
              <span style="color: #483d8b;">:parenthesis-open/?s</span>
              <span style="color: #483d8b;">:parenthesis-close/?s</span>
              <span style="color: #483d8b;">:bracket-open/?s</span>
              <span style="color: #483d8b;">:bracket-close/?s</span>
              <span style="color: #483d8b;">:dot</span>
              <span style="color: #483d8b;">:dot/?s</span>
              <span style="color: #483d8b;">:comma/?s</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga9b64e5" class="outline-4">
<h4 id="orga9b64e5"><span class="section-number-4">3.1.2</span> The common parsing functions</h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*filename*</span> nil)

(defrule skippable (+  (or whitespace
                           c-style-comment/rest-of-line
                           c-style-comment/delimited)))

(defrule skippable? (* (or whitespace
                           c-style-comment/rest-of-line
                           c-style-comment/delimited)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defkw</span> (kw-string <span style="color: #228b22;">&amp;optional</span> <span style="color: #228b22;">&amp;body</span> body)
  (<span style="color: #a020f0;">let</span> ((rule-sym (intern (format nil <span style="color: #8b2252;">"~a-KW"</span> (string-upcase kw-string))))) <span style="color: #b22222;">;</span>
    (<span style="color: #a020f0;">if</span> body
        `(defrule/s ,rule-sym (and ,kw-string (! (character-ranges (#\a #\z)))) ,@body)
        `(defrule/s ,rule-sym (and ,kw-string (! (character-ranges (#\a #\z))))))))

(defrule/s identifier (and (character-ranges (#\a #\z))
                   (* (or (character-ranges (#\a #\z) (#\A #\Z) (#\0 #\9))
                        #\_)))
  (<span style="color: #483d8b;">:text</span> t))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-loc</span> (start end)
  (list (cons start end) *filename*))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-left-assoc</span> (l tail)
  (<span style="color: #a020f0;">if</span> tail 
    (<span style="color: #a020f0;">let*</span> ((op-exp (car tail))
           (f (first op-exp))
           (r (second op-exp)))
       (do-left-assoc (funcall f l r (location l)) (cdr tail)))
    l))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-right-assoc</span> (l tail)
  (<span style="color: #a020f0;">if</span> tail 
    (<span style="color: #a020f0;">let*</span> ((op-exp (car tail))
           (f (first op-exp))
           (r (second op-exp)))
      (funcall f l (do-right-assoc r (cdr tail)) (location l)))
    l))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-non-assoc</span> (l lst)
  (<span style="color: #a020f0;">if</span> lst 
    (<span style="color: #a020f0;">let*</span> ((f (first lst))
           (r (second lst)))
      (funcall f l r (location l)))
    l))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(defrule/s semi-colon #\;)

(defrule/s block-open #\{)
(defrule/s block-close #\})

(defrule/s equals #\=)

(defrule/s parenthesis-open #\()

(defrule/s parenthesis-close #\))

(defrule/s bracket-open #\[)

(defrule/s bracket-close #\])

(defrule/s dot #\.)

(defrule/s comma #\,)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orge8929a9" class="outline-3">
<h3 id="orge8929a9"><span class="section-number-3">3.2</span> AST</h3>
<div class="outline-text-3" id="text-3-2">
<p>
This library allows one to define ASTs.
</p>
</div>

<div id="outline-container-org5df88c9" class="outline-4">
<h4 id="org5df88c9"><span class="section-number-4">3.2.1</span> The package</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:ast</span>
     (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span>)
     (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:flatten</span>)
     (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
     (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:splice-if</span>)
     (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:defast</span>
              <span style="color: #483d8b;">:ast</span>
              <span style="color: #483d8b;">:ast=</span>
              <span style="color: #483d8b;">:ast&lt;</span>
              <span style="color: #483d8b;">:location&lt;</span>
              <span style="color: #483d8b;">:location</span>
              <span style="color: #483d8b;">:parent</span>
              <span style="color: #483d8b;">:children</span>
              <span style="color: #483d8b;">:slot-names-children</span>
              <span style="color: #483d8b;">:parent-in-asts-p</span>
              <span style="color: #483d8b;">:get-parents</span>
              <span style="color: #483d8b;">:has-as-child-p</span>
              <span style="color: #483d8b;">:get-child-elements</span>
              <span style="color: #483d8b;">:siblings-before</span>
              <span style="color: #483d8b;">:visit</span>
              <span style="color: #483d8b;">:mirrored-visit</span>
              <span style="color: #483d8b;">:visit-breadth-first</span>
              <span style="color: #483d8b;">:defvisitor</span>
              <span style="color: #483d8b;">:retrieve</span>
              <span style="color: #483d8b;">:retrieve-all</span>
              <span style="color: #483d8b;">:collect</span>
              <span style="color: #483d8b;">:collect-all</span>
              <span style="color: #483d8b;">:collect-all-parent</span>
              <span style="color: #483d8b;">:copy-ast</span>
              <span style="color: #483d8b;">:replace-in-ast</span>
              <span style="color: #483d8b;">:remove-from-ast</span>
              <span style="color: #483d8b;">:insert-before-ast</span>
              <span style="color: #483d8b;">:insert-after-ast</span>
              <span style="color: #483d8b;">:create-print-functions</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1e033cc" class="outline-4">
<h4 id="org1e033cc"><span class="section-number-4">3.2.2</span> Defining an AST</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
The following code shows an example of how the <code>defast</code> macro is used.  This
macro allows us to define kind of an algebraic datatype on which pattern
matching can be applied using generic methods.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defast module
        ((module (id imports code) (module-callgraph))) 
        ())
</pre>
</div>

<p>
This form defines an AST node called module.  It has only one constructor that
has the same name as the AST node.  It has the three fields <code>id</code>, <code>imports</code>,
and <code>code</code>.  It has one auxilary field <code>module-callgraph</code> that is not
necessarily part of the tree but can also refer back to other nodes.
</p>

<p>
Another example is listed below:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defast decl 
        ((normal-decl (modifiers basic-decls) ())
         (assign-decl (modifiers basic-decl expr) ())) 
        (as-basic-decls written))
</pre>
</div>

<p>
This defines an AST node <code>decl</code> which can be a <code>normal-decl</code> with <code>modifiers</code>
and <code>basic-decls</code>, and an <code>assign-decl</code> with an additional field <code>expr</code>.  The
auxiliary fields of a <code>decl</code> keep track of the "as-basic-decls" and whether this
declaration is written anywhere.
</p>

<p>
The <code>defast</code> macro has to first check whether the two constructors are the same
as in the first example.  Based on that it determines the type and creates a
superclass or not.  Finally, it creates constructors, visit methods, and a
method to retrieve the children:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defast</span> (type constructors auxiliary-fields)
  (<span style="color: #a020f0;">let*</span> ((first-constructor (caar constructors))
         (constructors-equal (cl:eq type first-constructor))
         (type (<span style="color: #a020f0;">if</span> constructors-equal 'ast type))
         (superclass (<span style="color: #a020f0;">if</span> constructors-equal
                         nil
                         (create-superclass type auxiliary-fields))))
    `(<span style="color: #a020f0;">progn</span>
       ,superclass
       ,(<span style="color: #a020f0;">when</span> (not constructors-equal)
          (create-empty-visit-method type)
          (create-empty-mirrored-visit-method type))
       ,@(<span style="color: #a020f0;">let</span> ((res nil))
           (<span style="color: #a020f0;">dolist</span> (c constructors)
             (push (create-constructor c type) res)
             (push (create-visit-methods c) res)
             (push (create-children-method c) res)
             (push (create-slot-names-children-method c) res))
           (nreverse res)))))
</pre>
</div>

<p>
The following function creates superclass code and code that exports several
symbols:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-superclass</span> (type auxiliary-fields)
  `(<span style="color: #a020f0;">progn</span>
     (<span style="color: #a020f0;">defclass</span> ,type (ast) 
       ,(<span style="color: #a020f0;">let</span> ((res nil))
             (<span style="color: #a020f0;">dolist</span> (f auxiliary-fields)
               (push `(,f <span style="color: #483d8b;">:initform</span> nil <span style="color: #483d8b;">:accessor</span> ,f) res))
             (nreverse res)))
     ,@(create-export-list auxiliary-fields)
     (export ',type)))
</pre>
</div>

<p>
The following code creates empty visit methods:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-empty-visit-method</span> (c)
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">visit</span> ((ast ,c) forward backward)
       (funcall forward ast)
       (funcall backward ast)
       nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-empty-mirrored-visit-method</span> (c)
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mirrored-visit</span> ((read-only-ast ,c) (mod-ast ,c)
                              forward backward)
       (funcall forward read-only-ast mod-ast)
       (funcall backward read-only-ast mod-ast)
       nil))
</pre>
</div>

<p>
The following function creates a constructor:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-constructor</span> (c type)
  (<span style="color: #a020f0;">let*</span> ((c-name (first c))
         (fields (second c))
         (aux-fields (third c))
         (make-sym (intern (format nil <span style="color: #8b2252;">"MAKE-~a"</span> c-name))))
    `(<span style="color: #a020f0;">progn</span> 
       ,(create-class c-name type fields aux-fields)
       (export ',c-name)
       ,@(create-export-list fields)
       ,@(create-export-list aux-fields)
       ,(create-make-function make-sym c-name fields)
       ,(create-copy-method make-sym c-name fields)
       ,(create-replace-child-method c-name fields)
       ,(create-remove-child-method c-name fields)
       ,(create-insert-before/after-child-method c-name fields 'before)
       ,(create-insert-before/after-child-method c-name fields 'after)
       ,(create-child-ast&lt;-method c-name fields)
       (export ',make-sym))))
</pre>
</div>

<p>
Creating a class:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-class</span> (c-name type fields aux-fields)
  `(<span style="color: #a020f0;">defclass</span> ,c-name (,type)
     ,(<span style="color: #a020f0;">let</span> ((res nil))
        (<span style="color: #a020f0;">dolist</span> (f fields)
          (<span style="color: #a020f0;">let*</span> ((fname (symbol-name f))
                 (kw (intern fname <span style="color: #8b2252;">"KEYWORD"</span>)))
            (push `(,f <span style="color: #483d8b;">:initarg</span> ,kw
                       <span style="color: #483d8b;">:initform</span> 
                       (<span style="color: #ff0000; font-weight: bold;">error</span> ,(format nil <span style="color: #8b2252;">"Must supply value to ~a"</span>
                                       fname)) <span style="color: #483d8b;">:accessor</span> ,f)
                  res)))
        (<span style="color: #a020f0;">dolist</span> (f aux-fields)
          (push `(,f <span style="color: #483d8b;">:initform</span> nil <span style="color: #483d8b;">:accessor</span> ,f) res))
        (nreverse res))))
</pre>
</div>

<p>
Creating a convenience function to make the class:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-make-function</span> (make-sym c-name fields)
  `(<span style="color: #a020f0;">defun</span> ,make-sym (,@fields <span style="color: #228b22;">&amp;optional</span> location)
     (make-instance ',c-name
                    ,@(<span style="color: #a020f0;">let</span> ((res nil))
                           (<span style="color: #a020f0;">dolist</span> (f fields)
                             (<span style="color: #a020f0;">let*</span> ((fname (symbol-name f))
                                    (kw (intern fname <span style="color: #8b2252;">"KEYWORD"</span>)))
                               (push kw res)
                               (push f res)))
                           (nreverse res))
              <span style="color: #483d8b;">:location</span> location)))
</pre>
</div>

<p>
The following function creates a copy function that creates a deep copy of an
AST.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-copy-method</span> (make-symbol c-name fields)
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ast</span> ((ast ,c-name))
     (,make-symbol ,@(<span style="color: #a020f0;">let</span> (res)
                          (<span style="color: #a020f0;">dolist</span> (f fields)
                            (push `(copy-ast (,f ast)) res))
                          (nreverse res))
                   (location ast))))
</pre>
</div>

<p>
The following two functions create methods that replace a child in and remove a
child from the AST respecively.  For every field, we check whether it is the
same as child and if true we replace it or set it to <code>nil</code>.  A field can be a
list and in that case we have to replace or remove it in the list.  However, if
a field has no value, the value is going to be <code>nil</code> which is also a list.
Therefore, we also check whether the list is non <code>nil</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-replace-child-method</span> (c-name fields)
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">replace-child</span> ((ast ,c-name) child <span style="color: #228b22;">&amp;key</span> with)
     ,@(<span style="color: #a020f0;">if</span> fields
           `((<span style="color: #a020f0;">with-slots</span> ,fields ast
                (<span style="color: #a020f0;">cond</span> ,@(<span style="color: #a020f0;">loop</span> for f in fields
                           collect `((eq child ,f)
                                     (setf ,f with))))
                (<span style="color: #a020f0;">cond</span> ,@ (<span style="color: #a020f0;">loop</span> for f in fields
                              collect `((and (listp ,f) ,f)
                                        (setf ,f (splice-if with #'(<span style="color: #a020f0;">lambda</span> (x) (eql x child)) ,f)))))
                (setf (parent child) ast)))
          `((<span style="color: #a020f0;">declare</span> (ignore with))
            (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a has no child."</span> ast)))))
</pre>
</div>


<p>
The following function creates a function that removes a child from the AST.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-remove-child-method</span> (c-name fields)
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">remove-child</span> ((ast ,c-name) child)
     ,@(<span style="color: #a020f0;">if</span> fields
           `((<span style="color: #a020f0;">with-slots</span> ,fields ast
                (<span style="color: #a020f0;">cond</span> ,@(<span style="color: #a020f0;">loop</span> for f in fields
                           collect `((eq child ,f)
                                     (setf ,f nil))))
                (<span style="color: #a020f0;">cond</span> ,@ (<span style="color: #a020f0;">loop</span> for f in fields
                            collect `((and (listp ,f) (member child ,f))
                                     (setf ,f (remove child ,f)))))))
           `((<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a has no child"</span> ast)))))
</pre>
</div>

<p>
The following function creates an insert-before-child method:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-insert-before/after-child-method</span> (c-name fields before/after)
  (<span style="color: #a020f0;">let</span> ((insert-b/a-child
         (intern (format nil <span style="color: #8b2252;">"INSERT-~A-CHILD"</span> before/after) <span style="color: #483d8b;">:ast</span>))
        (insert-b/a (intern (format nil <span style="color: #8b2252;">"INSERT-~A"</span> before/after) <span style="color: #483d8b;">:utility-directory</span>)))
    `(<span style="color: #a020f0;">defmethod</span> ,insert-b/a-child ((ast ,c-name) child to-insert)
       ,@(<span style="color: #a020f0;">if</span> fields
             `((<span style="color: #a020f0;">with-slots</span> ,fields ast
                 (<span style="color: #a020f0;">cond</span> ,@(<span style="color: #a020f0;">loop</span> for f in fields
                            collect `((and (listp ,f) (member child ,f))
                                      (setf ,f (,insert-b/a child ,f to-insert))
                                      (setf (parent to-insert) ast)))
                       (t
                        (,insert-b/a-child (parent ast) ast to-insert)))))
             `((<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a has no child."</span> ast))))))
</pre>
</div>


<p>
The following function creates method that checks whether a child of a parent
AST is less than another child of the parent AST.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-child-ast&lt;-method</span> (c-name fields)
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">child-ast&lt;</span> ((ast ,c-name) child1 child2)
     ,(<span style="color: #a020f0;">if</span> fields
          `(<span style="color: #a020f0;">if</span> (eq child1 child2)
               nil
               (<span style="color: #a020f0;">with-slots</span> ,fields ast
                 (<span style="color: #a020f0;">let</span> ((position-child1 ,(create-conditions 'child1 fields))
                       (position-child2 ,(create-conditions 'child2 fields)))
                   (<span style="color: #a020f0;">if</span> (eql (car position-child1) (car position-child2))
                       (<span style="color: #a020f0;">let</span> ((list (cdr position-child1)))
                         (&lt; (position child1 list) (position child2 list)))
                       (&lt; (car position-child1) (car position-child2))))))
           `(<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a has no child."</span> ast))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-conditions</span> (child-symbol fields)
  `(<span style="color: #a020f0;">cond</span> ,@(<span style="color: #a020f0;">loop</span> for f in fields
              for pos from 0
              collect `((or (eq ,child-symbol ,f)
                            (and (listp ,f) (member ,child-symbol ,f)))
                        (cons ,pos ,f)))
         (t
          (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"child1 not a child"</span>))))
</pre>
</div>


<p>
The following function creates visit methods, that visit all fields:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-visit-methods</span> (c )
  (<span style="color: #a020f0;">let</span> ((c-name (first c))
        (fields (second c)))
    `(<span style="color: #a020f0;">progn</span>
       (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">visit</span> ((ast ,c-name) forward backward)
         (<span style="color: #a020f0;">when</span> (funcall forward ast)
           ,@(<span style="color: #a020f0;">let</span> ((res nil))
                  (<span style="color: #a020f0;">dolist</span> (f fields)
                    (push `(visit (,f ast) forward backward) res))
                  (nreverse res)))
         (funcall backward ast))
       (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mirrored-visit</span> ((read-only-ast ,c-name) (mod-ast ,c-name)
                                  forward backward)
         (<span style="color: #a020f0;">when</span> (funcall forward read-only-ast mod-ast)
           ,@(<span style="color: #a020f0;">let</span> ((res nil))
                  (<span style="color: #a020f0;">dolist</span> (f fields)
                    (push `(mirrored-visit (,f read-only-ast) (,f mod-ast)
                                           forward backward) <span style="color: #ff0000; font-weight: bold;">res))</span>
                  (nreverse res)))
         (funcall backward read-only-ast mod-ast)))))
</pre>
</div>

<p>
The following function retrieves all children from an AST node:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-children-method</span> (c)
  (<span style="color: #a020f0;">let</span> ((c-name (first c))
        (fields (second c)))
    `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">children</span> ((ast ,c-name))
       (list ,@(<span style="color: #a020f0;">let</span> ((res nil))
                    (<span style="color: #a020f0;">dolist</span> (f fields)
                      (push `(,f ast) res))
                    (nreverse res))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-slot-names-children-method</span> (c)
  (<span style="color: #a020f0;">let</span> ((c-name (first c))
        (fields (second c)))
    `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">slot-names-children</span> ((ast ,c-name))
       ',fields)))
</pre>
</div>

<p>
The following function is a helper function that generates exports for each
element in the list.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-export-list</span> (l)
  (<span style="color: #a020f0;">let</span> (res)
    (<span style="color: #a020f0;">dolist</span> (e l)
      (push `(export ',e) res))
    (nreverse res)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org0d23ecc" class="outline-4">
<h4 id="org0d23ecc"><span class="section-number-4">3.2.3</span> Helper functions</h4>
<div class="outline-text-4" id="text-3-2-3">
</div>

<div id="outline-container-org858760b" class="outline-5">
<h5 id="org858760b"><span class="section-number-5">3.2.3.1</span> The root of the AST</h5>
<div class="outline-text-5" id="text-3-2-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">ast</span> ()
  ((parent <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:parent</span>
           <span style="color: #483d8b;">:initform</span> nil 
           <span style="color: #483d8b;">:accessor</span> parent)
   (location <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:location</span>
             <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply value to :location"</span>) 
             <span style="color: #483d8b;">:accessor</span> location)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org49fcc20" class="outline-5">
<h5 id="org49fcc20"><span class="section-number-5">3.2.3.2</span> Equality of ASTs</h5>
<div class="outline-text-5" id="text-3-2-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">ast=</span> (ast1 ast2)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether ast1 is equal to ast2."</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">ast&lt;</span> (ast1 ast2)
  (<span style="color: #a020f0;">let</span> ((common-parents (find-common-parents ast1 ast2)))
    (ast&lt;2 (move-to-child-of-parents common-parents ast1)
            (move-to-child-of-parents common-parents ast2))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-to-child-of-parents</span> (parents ast)
  <span style="color: #8b2252;">"Move ast such that it becomes a child of one of the parents in parents."</span>
  (<span style="color: #a020f0;">when</span> (null ast)
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Reached the end of the chain of parents"</span>))
  (<span style="color: #a020f0;">if</span> (member (parent ast) parents)
      ast
      (move-to-child-of-parents parents (parent ast))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-common-parents</span> (ast1 ast2)
  (intersection (get-parents ast1) (get-parents ast2)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">ast&lt;2</span> (ast1 ast2)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (eq (parent ast1) (parent ast2)))
  (child-ast&lt; (parent ast1) ast1 ast2))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">child-ast&lt;</span> (ast child1 child2)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether child1 is less than child2 in the parent ast."</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">location&lt;</span> (location1 location2)
  (<span style="color: #a020f0;">if</span> (or (null location1) (null location2))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"one of locations is nil: ~a, ~a"</span> location1 location2)
      (<span style="color: #a020f0;">if</span> (eql (car location1) (car location2))
          (&lt; (cdr location1) (cdr location2))
          (&lt; (car location1) (car location2)))))
</pre>
</div>

<p>
TODO: I don't understand why this one is necessary.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast=</span> ((s1 t) s2)
  (equals s1 s2))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast=</span> ((s1 number) s2)
  (equals s1 s2))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast=</span> ((s1 string) s2)
  (equal s1 s2))
</pre>
</div>

<p>
TODO: I don't understand why this one would work.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast=</span> ((l1 list) l2)
  (and (equal (type-of l1) (type-of l2))
       (or (and (null l1) (null l2))
           (and (ast= (car l1) (car l2)) 
                (ast= (cdr l1) (cdr l2))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast=</span> ((ast1 ast) ast2)
  (and (equal (type-of ast1) (type-of ast2))
       (ast= (children ast1) (children ast2))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equals</span> (a b)
  (and (equal (type-of a) (type-of b))
       (equal a b)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org33eb54b" class="outline-5">
<h5 id="org33eb54b"><span class="section-number-5">3.2.3.3</span> Parents of ASTs</h5>
<div class="outline-text-5" id="text-3-2-3-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parent-in-asts-p</span> (ast asts)
  <span style="color: #8b2252;">"Whether ast has a parent that is in asts"</span>
  (intersection (get-parents ast) asts))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-parents</span> (ast)
  <span style="color: #8b2252;">"Get all the parents of ast"</span>
  (<span style="color: #a020f0;">let</span> ((parent (parent ast)))
    (<span style="color: #a020f0;">if</span> (null parent)
        nil
        (cons parent (get-parents parent)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org92bcac4" class="outline-5">
<h5 id="org92bcac4"><span class="section-number-5">3.2.3.4</span> Children of ASTs</h5>
<div class="outline-text-5" id="text-3-2-3-4">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">has-as-child-p</span> (parent child)
  <span style="color: #8b2252;">"Whether parent has child as child"</span>
  (member child (get-child-elements parent)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-child-elements</span> (ast)
  <span style="color: #8b2252;">"Retrieve the child elements from an AST.  </span>

<span style="color: #8b2252;">If one of the children is a list, return the elements in the list instead of </span>
<span style="color: #8b2252;">the list."</span>
  (flatten (children ast)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org40742ad" class="outline-5">
<h5 id="org40742ad"><span class="section-number-5">3.2.3.5</span> Siblings of ASTs</h5>
<div class="outline-text-5" id="text-3-2-3-5">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">siblings-before</span> (ast)
  (<span style="color: #a020f0;">let</span> ((siblings (get-child-elements (parent ast))))
    (subseq siblings 0 (position ast siblings))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org33f9eee" class="outline-5">
<h5 id="org33f9eee"><span class="section-number-5">3.2.3.6</span> Visitors</h5>
<div class="outline-text-5" id="text-3-2-3-6">
<p>
The visit is a depth-first visit.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">visit</span> (ast forward backward)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Visit the ast with functions forward and backward."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">visit</span> ((ast ast) forward backward)
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"unimplemented ~a"</span> (class-of ast)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">visit</span> ((s string) forward backward)
  (funcall forward s)
  (funcall backward s))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">visit</span> ((l list) forward backward)
  (funcall forward l)
  (<span style="color: #a020f0;">dolist</span> (e l)
        (visit e forward backward))
  (funcall backward l))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">visit</span> ((l number) forward backward)
  (funcall forward l)
  (funcall backward l))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">visit</span> ((s symbol) forward backward)
  (funcall forward s)
  (funcall backward s))
</pre>
</div>

<p>
The mirrored-visit is similar:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">mirrored-visit</span> (read-only-ast mod-ast forward backward)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Visit both read-only- and mod- ast with functions forward </span>
<span style="color: #8b2252;">and backward."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mirrored-visit</span> ((ro-ast ast) (mod-ast ast) forward backward)
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"unimplemented ~a"</span> (class-of ro-ast)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mirrored-visit</span> ((ro-s string) (mod-s string) forward backward)
  (funcall forward ro-s mod-s)
  (funcall backward ro-s mod-s))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mirrored-visit</span> ((ro-l list) (mod-l list) forward backward)
  (funcall forward ro-l mod-l)
  (<span style="color: #a020f0;">loop</span> for i from 0 below (length ro-l)
     do (mirrored-visit (nth i ro-l) (nth i mod-l) forward backward))
  (funcall backward ro-l mod-l))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mirrored-visit</span> ((ro-n number) (mod-n number) forward backward)
  (funcall forward ro-n mod-n)
  (funcall backward ro-n mod-n))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mirrored-visit</span> ((ro-s symbol) (mod-s symbol) forward backward)
  (funcall forward ro-s mod-s)
  (funcall backward ro-s mod-s))
</pre>
</div>


<p>
The following visit is a breadth-first visit.  The input of
<code>visit-breadth-first-2</code> should be a list of ast forms.  It keeps track of two
queues, one for the atoms and one for the children.  First we push the items on
the queues.  The children of the ast forms (which can be lists themselves, in
which' case we push the items of the lists on the queue) are put on the queue
of children.  We then call the forward function on the queue of atoms,
recursively call the function on the queue of children and then call the
backward function for queue of atoms.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:ast</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visit-breadth-first</span> (ast forward backward)
     (visit-breadth-first-2 (list ast) forward backward))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visit-breadth-first-2</span> (asts forward backward)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (listp asts))
  (<span style="color: #a020f0;">when</span> asts
    (<span style="color: #a020f0;">let</span> (q-of-atoms q-of-children)
      (<span style="color: #a020f0;">labels</span> ((push-ast-on-queue (ast)
                 (<span style="color: #ff0000; font-weight: bold;">assert</span> (atom ast))
                 (push ast q-of-atoms)
                 (<span style="color: #a020f0;">when</span> (typep ast 'ast)
                   (mapcar #'(<span style="color: #a020f0;">lambda</span> (x)
                               (<span style="color: #a020f0;">if</span> (listp x)
                                   (mapcar #'(<span style="color: #a020f0;">lambda</span> (y)
                                               (push y q-of-children))
                                           x)
                                   (push x q-of-children)))
                           (children ast)))))
        (mapcar #'push-ast-on-queue asts)
        (mapcar forward (reverse q-of-atoms))
        (visit-breadth-first-2 (nreverse q-of-children) forward backward)
        (mapcar backward (reverse q-of-atoms))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae10929" class="outline-5">
<h5 id="orgae10929"><span class="section-number-5">3.2.3.7</span> Visitor macros</h5>
<div class="outline-text-5" id="text-3-2-3-7">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defvisitor</span> (visitor-name param-name types <span style="color: #228b22;">&amp;body</span> body)
  `(<span style="color: #a020f0;">progn</span>
     ,@(<span style="color: #a020f0;">let</span> ((res nil))
        (<span style="color: #a020f0;">dolist</span> (type types)
          (push `(<span style="color: #a020f0;">defmethod</span> ,visitor-name ((,param-name ,type))
                   ,@body) <span style="color: #ff0000; font-weight: bold;">res))</span>
        (nreverse res))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd93c46b" class="outline-5">
<h5 id="orgd93c46b"><span class="section-number-5">3.2.3.8</span> Deep copies</h5>
<div class="outline-text-5" id="text-3-2-3-8">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:ast</span>)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">copy-ast</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Make a deep copy of the AST.</span>

<span style="color: #8b2252;">The parent should be set again, and the auxiliary fields are not copied."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ast</span> ((s string)) s)
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ast</span> ((l list)) (mapcar #'copy-ast l))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ast</span> ((s symbol)) s)
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ast</span> ((n number)) n)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8ef0c0" class="outline-5">
<h5 id="orga8ef0c0"><span class="section-number-5">3.2.3.9</span> Replacing AST nodes</h5>
<div class="outline-text-5" id="text-3-2-3-9">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-in-ast</span> (to-be-replaced <span style="color: #228b22;">&amp;key</span> with)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Replace AST node to-be-replaced with with."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">replace-in-ast</span> ((to-be-replaced ast) <span style="color: #228b22;">&amp;key</span> with)
  (aif (parent to-be-replaced)
       (replace-child it to-be-replaced <span style="color: #483d8b;">:with</span> with)
       (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a has no parent"</span> to-be-replaced)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-child</span> (ast child-to-replace <span style="color: #228b22;">&amp;key</span> with)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Replace the child child-to-replace with with in ast."</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge050aae" class="outline-5">
<h5 id="orge050aae"><span class="section-number-5">3.2.3.10</span> Removing AST nodes</h5>
<div class="outline-text-5" id="text-3-2-3-10">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">remove-from-ast</span> (to-be-removed)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Remove AST node from the AST."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">remove-from-ast</span> ((to-be-removed ast))
  (aif (parent to-be-removed)
       (remove-child it to-be-removed)
       (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a has no parent"</span> to-be-removed)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">remove-child</span> (ast child-to-removed)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Remove the child child-to-removed in ast."</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a4d1dc" class="outline-5">
<h5 id="org4a4d1dc"><span class="section-number-5">3.2.3.11</span> Inserting AST nodes</h5>
<div class="outline-text-5" id="text-3-2-3-11">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">insert-before-child</span> (parent child to-insert ))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">insert-after-child</span> (parent child to-insert ))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-before-ast</span> (point-in-ast ast-to-insert)
  (insert-before-child (parent point-in-ast) point-in-ast ast-to-insert))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-after-ast</span> (point-in-ast ast-to-insert)
  (insert-after-child (parent point-in-ast) point-in-ast ast-to-insert))
</pre>
</div>
</div>
</div>

<div id="outline-container-org83cf355" class="outline-5">
<h5 id="org83cf355"><span class="section-number-5">3.2.3.12</span> Declaration for the children method.</h5>
<div class="outline-text-5" id="text-3-2-3-12">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">children</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Retrieve the children of the ast."</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org67c0091" class="outline-5">
<h5 id="org67c0091"><span class="section-number-5">3.2.3.13</span> Printing the AST</h5>
<div class="outline-text-5" id="text-3-2-3-13">
<p>
The following macro creates print functions for the AST-forms:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">create-print-functions</span> (types)
  <span style="color: #8b2252;">"Creates print-object functions for AST forms. </span>

<span style="color: #8b2252;">The types should be a list of pairs.  The first in the pair is the AST-form for</span>
<span style="color: #8b2252;">which a print-object function is generated.  The second in the pair is the form</span>
<span style="color: #8b2252;">that should be printed with the AST-form.</span>

<span style="color: #8b2252;">Example: (create-print-functions ((module id) (lib-import id)))"</span>
  `(<span style="color: #a020f0;">progn</span>
     ,@(<span style="color: #a020f0;">loop</span> for spec in types
          collect
            `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((ast ,(first spec)) stream)
              (print-unreadable-object (ast stream <span style="color: #483d8b;">:type</span> t)
                (format stream <span style="color: #8b2252;">"~a"</span> (,(second spec) ast)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2402c7b" class="outline-5">
<h5 id="org2402c7b"><span class="section-number-5">3.2.3.14</span> Querying the AST</h5>
<div class="outline-text-5" id="text-3-2-3-14">
<p>
The following four functions help to query ASTs.  The exported functions are
<code>collect</code>, <code>retrieve</code>, <code>collect-all</code>, and <code>retrieve-all</code>.  They all take as
input an AST and a predicate.  If the predicate is true, the resulting AST form
is collected.  The function <code>retrieve</code> expects to match on only one AST form
and will not return a list, but the element.  The <code>all</code> variants do a deep
search whereas the non-<code>all</code> variant only visits each child of the AST.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:ast</span>)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">collect-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">collect-bw</span> (ast))

(<span style="color: #a020f0;">let</span> ((result nil)
      (function (constantly nil)))

  (defvisitor collect-fw ast (ast string list number symbol)
    (<span style="color: #a020f0;">when</span> (funcall function ast)
      (push ast result))
    t)

  (defvisitor collect-bw ast (ast string list number symbol)
    nil)

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">retrieve-all</span> (ast predicate)
    <span style="color: #8b2252;">"Retrieves the ast that satisfies predicate.  </span>
<span style="color: #8b2252;">This function searches through each child.</span>
<span style="color: #8b2252;">An error is returned if it finds none or multiple results."</span>
    (setf result nil)
    (setf function predicate)
    (visit ast #'collect-fw #'collect-bw)
    (<span style="color: #a020f0;">if</span> (&gt; (length result) 1)
        (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"more than one result"</span>)
        (first result)))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">collect-all</span> (ast predicate)
    <span style="color: #8b2252;">"Collects the asts that satisfy predicate while searching the complete</span>
<span style="color: #8b2252;">tree."</span> 
    (setf result nil)
    (setf function predicate)
    (visit ast #'collect-fw #'collect-bw)
    (nreverse result)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">collect</span> (ast predicate)
  <span style="color: #8b2252;">"Collects the ASTs that satisfy predicate.  It only iterates over the </span>
<span style="color: #8b2252;">children of the ast."</span>
  (remove-if (complement predicate) (flatten (children ast))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">retrieve</span> (ast predicate)
  <span style="color: #8b2252;">"Retrieves the AST that satisfies predicate.  It only iterates over the </span>
<span style="color: #8b2252;">children of the ast and it expects to return only one result."</span>
  (<span style="color: #a020f0;">let</span> ((result (collect ast predicate)))
    (<span style="color: #a020f0;">if</span> (&gt; (length result) 1)
        (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"more than one result"</span>)
        (first result))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">collect-all-parent</span> (ast predicate)
  <span style="color: #8b2252;">"Collect from the parents of ast the ast-forms that satisfy predicate."</span>
  (<span style="color: #a020f0;">let</span> ((result nil))
    (<span style="color: #a020f0;">do</span> ((parent (parent ast) (parent parent)))
        ((null parent) (nreverse result))
      (<span style="color: #a020f0;">when</span> (funcall predicate parent)
        (push parent result)))))
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orgae4949e" class="outline-3">
<h3 id="orgae4949e"><span class="section-number-3">3.3</span> Building AST forms</h3>
<div class="outline-text-3" id="text-3-3">
<p>
This library contains convenience functions to create simple AST forms, for
example to build an AST form for testing purposes.  There are several
assumptions:
</p>

<ul class="org-ul">
<li>there will be no modifiers in the declarations other than <code>const</code>,</li>
<li>non-array type variables will be of type <code>int</code>, and</li>
<li>array type variables will be of type <code>float</code>.</li>
</ul>
</div>

<div id="outline-container-org3cdc62f" class="outline-4">
<h4 id="org3cdc62f"><span class="section-number-4">3.3.1</span> The package</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:build-ast</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:mcl-quickutil</span> <span style="color: #483d8b;">:map-tree</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:build-decl</span>
           <span style="color: #483d8b;">:build-type</span>

           <span style="color: #483d8b;">:build-foreach</span>
           <span style="color: #483d8b;">:build-call</span>
           <span style="color: #483d8b;">:build-call-stat</span>
           <span style="color: #483d8b;">:build-decl-stat</span>
           <span style="color: #483d8b;">:build-assign-stat</span>

           <span style="color: #483d8b;">:build-var</span>

           <span style="color: #483d8b;">:build-expr</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7ff6b0" class="outline-4">
<h4 id="orgd7ff6b0"><span class="section-number-4">3.3.2</span> Building AST-forms</h4>
<div class="outline-text-4" id="text-3-3-2">
</div>

<div id="outline-container-org4e4f775" class="outline-5">
<h5 id="org4e4f775"><span class="section-number-5">3.3.2.1</span> Declarations</h5>
<div class="outline-text-5" id="text-3-3-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-decl</span> (name <span style="color: #228b22;">&amp;optional</span> array-sizes const expr)
  (<span style="color: #a020f0;">if</span> expr
      (build-assign-decl name array-sizes expr const)
      (build-normal-decl name array-sizes const)))



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-assign-decl</span> (name  array-sizes expr <span style="color: #228b22;">&amp;optional</span> const)
  (make-assign-decl
   (<span style="color: #a020f0;">if</span> const (list (make-const)) nil)
   (build-basic-decl name array-sizes)
   (build-expr expr)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-normal-decl</span> (name array-sizes <span style="color: #228b22;">&amp;optional</span> const)
  (make-normal-decl
   (<span style="color: #a020f0;">if</span> const (list (make-const)) nil)
   (list (build-basic-decl name array-sizes))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-basic-decl</span> (name array-sizes))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-basic-decl</span> ((name string) array-sizes)
  (make-basic-decl (build-type array-sizes)
                   (make-id name)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6af5917" class="outline-5">
<h5 id="org6af5917"><span class="section-number-5">3.3.2.2</span> Types</h5>
<div class="outline-text-5" id="text-3-3-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-type</span> (array-sizes))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-type</span> ((array-sizes (eql nil)))
  (make-int))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-type</span> ((array-sizes list))
  (build-array-type array-sizes))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-array-type</span> (array-sizes))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-array-type</span> ((array-sizes (eql nil)))
  (make-flt))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-array-type</span> ((array-sizes list))
  (<span style="color: #a020f0;">destructuring-bind</span> (first <span style="color: #228b22;">&amp;rest</span> rest) array-sizes
    (make-array-type (build-array-type rest)
                     (mapcar #'build-array-size first))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-array-size</span> (size)
  (make-decl-array-size (build-expr size) nil))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge68c4c5" class="outline-5">
<h5 id="orge68c4c5"><span class="section-number-5">3.3.2.3</span> Statements</h5>
<div class="outline-text-5" id="text-3-3-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-foreach</span> (decl nr-iters stats))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-foreach</span> ((decl string) (nr-iters string) stats)
  (make-foreach-stat (build-decl decl) (build-expr nr-iters) (make-id <span style="color: #8b2252;">"threads"</span>)
                     (make-block-stat (make-code-block stats))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-call</span> (name <span style="color: #228b22;">&amp;rest</span> parameters)
  (make-call (make-id name) (mapcar #'build-expr parameters)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-call-stat</span> (name <span style="color: #228b22;">&amp;rest</span> parameters)
  (make-call-stat (apply #'build-call name parameters)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-decl-stat</span> (name <span style="color: #228b22;">&amp;optional</span> array-sizes const expr)
  (make-decl-stat (build-decl name array-sizes const expr)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-assign-stat</span> (var expr)
  (make-assign-stat (build-var var) (build-expr expr)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org61af2c8" class="outline-5">
<h5 id="org61af2c8"><span class="section-number-5">3.3.2.4</span> Variables</h5>
<div class="outline-text-5" id="text-3-3-2-4">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-var</span> (name <span style="color: #228b22;">&amp;optional</span> array-exprs))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-var</span> ((name string) <span style="color: #228b22;">&amp;optional</span> array-exprs)
  (make-normal-var
   (make-basic-var (make-id name)
                   (<span style="color: #a020f0;">if</span> array-exprs
                       (map-tree #'build-expr array-exprs)
                       nil))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-var</span> ((var var) <span style="color: #228b22;">&amp;optional</span> array-exprs)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (null array-exprs))
  var)
</pre>
</div>
</div>
</div>

<div id="outline-container-org11061c6" class="outline-5">
<h5 id="org11061c6"><span class="section-number-5">3.3.2.5</span> Expressions</h5>
<div class="outline-text-5" id="text-3-3-2-5">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-expr</span> (name <span style="color: #228b22;">&amp;optional</span> array-exprs))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-expr</span> ((name string) <span style="color: #228b22;">&amp;optional</span> array-exprs)
  (make-var-expr
   (build-var name array-exprs)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-expr</span> ((expr expr) <span style="color: #228b22;">&amp;optional</span> array-exprs)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (null array-exprs))
  expr)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-expr</span> ((expr number) <span style="color: #228b22;">&amp;optional</span> array-exprs)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (null array-exprs))
  (make-int-constant expr))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org59be09c" class="outline-3">
<h3 id="org59be09c"><span class="section-number-3">3.4</span> Errors</h3>
<div class="outline-text-3" id="text-3-4">
</div>
<div id="outline-container-orga743db4" class="outline-4">
<h4 id="orga743db4"><span class="section-number-4">3.4.1</span> The package</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
This package defines functionality for errors in MCL.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:errors</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:mcl-error</span> <span style="color: #483d8b;">:mcpl-error</span>

           <span style="color: #483d8b;">:text</span>
           <span style="color: #483d8b;">:loc</span>

           <span style="color: #483d8b;">:pass-error</span>

           <span style="color: #483d8b;">:parse-mcpl-error</span>
           <span style="color: #483d8b;">:parse-hdl-error</span>

           <span style="color: #483d8b;">:export-error</span> <span style="color: #483d8b;">:pkg-error</span>
           <span style="color: #483d8b;">:define-resolve-error</span> <span style="color: #483d8b;">:undefined-func-error</span> <span style="color: #483d8b;">:unequal-nr-params-error</span>
           <span style="color: #483d8b;">:undefined-type-error</span> <span style="color: #483d8b;">:undeclared-var-error</span> <span style="color: #483d8b;">:already-declared-error</span>
           <span style="color: #483d8b;">:non-primitive-type-error</span> <span style="color: #483d8b;">:undefined-hardware-description-var-error</span>

           <span style="color: #483d8b;">:non-var-written-error</span>
           <span style="color: #483d8b;">:constant-var-written-error</span>

           <span style="color: #483d8b;">:mcpl-type-error</span> <span style="color: #483d8b;">:numeric-type-error</span> <span style="color: #483d8b;">:incompatible-type-error</span>
           <span style="color: #483d8b;">:inequivalent-type-error</span> <span style="color: #483d8b;">:too-many-array-exprs-error</span>
           <span style="color: #483d8b;">:unequal-nr-array-exprs-error</span>

           <span style="color: #483d8b;">:mcpl-memory-space-error</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8b0ecf" class="outline-4">
<h4 id="orgd8b0ecf"><span class="section-number-4">3.4.2</span> The errors</h4>
<div class="outline-text-4" id="text-3-4-2">
</div>

<div id="outline-container-org70d7ba5" class="outline-5">
<h5 id="org70d7ba5"><span class="section-number-5">3.4.2.1</span> Macros for generating an error function</h5>
<div class="outline-text-5" id="text-3-4-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">create-error-function</span> (symbol)
  `(<span style="color: #a020f0;">defun</span> ,symbol (location message <span style="color: #228b22;">&amp;rest</span> arguments)
     (<span style="color: #ff0000; font-weight: bold;">error</span> ',symbol
            <span style="color: #483d8b;">:text</span> (apply #'format (append (list  nil message) arguments))
            <span style="color: #483d8b;">:loc</span> location)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">def-mcl-error</span> (name parent)
  `(<span style="color: #a020f0;">progn</span>
     (<span style="color: #a020f0;">define-condition</span> ,name (,parent) ())
     (create-error-function ,name)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a92d56" class="outline-5">
<h5 id="org5a92d56"><span class="section-number-5">3.4.2.2</span> Common errors</h5>
<div class="outline-text-5" id="text-3-4-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">define-condition</span> <span style="color: #0000ff;">mcl-error</span> (<span style="color: #ff0000; font-weight: bold;">error</span>)
  ((text <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:text</span> <span style="color: #483d8b;">:reader</span> text)
   (loc <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:loc</span> <span style="color: #483d8b;">:reader</span> loc)))
(create-error-function mcl-error)

(def-mcl-error mcpl-error mcl-error)
</pre>
</div>
</div>
</div>


<div id="outline-container-org96fb8e8" class="outline-5">
<h5 id="org96fb8e8"><span class="section-number-5">3.4.2.3</span> Pass errors</h5>
<div class="outline-text-5" id="text-3-4-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(def-mcl-error pass-error mcl-error)
</pre>
</div>
</div>
</div>

<div id="outline-container-org6efb181" class="outline-5">
<h5 id="org6efb181"><span class="section-number-5">3.4.2.4</span> Parse errors</h5>
<div class="outline-text-5" id="text-3-4-2-4">
<div class="org-src-container">
<pre class="src src-lisp">(def-mcl-error parse-mcpl-error mcpl-error)
(def-mcl-error parse-hdl-error mcl-error)
</pre>
</div>
</div>
</div>

<div id="outline-container-org14712e7" class="outline-5">
<h5 id="org14712e7"><span class="section-number-5">3.4.2.5</span> Define/resolve errors</h5>
<div class="outline-text-5" id="text-3-4-2-5">
<div class="org-src-container">
<pre class="src src-lisp">(def-mcl-error export-error mcpl-error)
(def-mcl-error pkg-error mcpl-error)

(def-mcl-error define-resolve-error mcpl-error)

(def-mcl-error undefined-func-error define-resolve-error)
(def-mcl-error unequal-nr-params-error define-resolve-error)
(def-mcl-error undefined-type-error define-resolve-error)

(def-mcl-error undeclared-var-error define-resolve-error)
(def-mcl-error already-declared-error  define-resolve-error)

(def-mcl-error non-primitive-type-error define-resolve-error)
(def-mcl-error undefined-hardware-description-var-error define-resolve-error)
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b8ec33" class="outline-5">
<h5 id="org4b8ec33"><span class="section-number-5">3.4.2.6</span> Constant/written variables</h5>
<div class="outline-text-5" id="text-3-4-2-6">
<div class="org-src-container">
<pre class="src src-lisp">(def-mcl-error non-var-written-error mcpl-error)
(def-mcl-error constant-var-written-error mcpl-error)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a6e4e7" class="outline-5">
<h5 id="org8a6e4e7"><span class="section-number-5">3.4.2.7</span> Type errors</h5>
<div class="outline-text-5" id="text-3-4-2-7">
<p>
An MCPL type error is a form of an MCPL error:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-mcl-error mcpl-type-error mcpl-error)
</pre>
</div>

<p>
There is also a special numeric type error.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-mcl-error numeric-type-error mcpl-type-error)

(def-mcl-error incompatible-type-error mcpl-type-error)

(def-mcl-error inequivalent-type-error mcpl-type-error)

(def-mcl-error too-many-array-exprs-error mcpl-type-error)

(def-mcl-error unequal-nr-array-exprs-error mcpl-type-error)
</pre>
</div>
</div>
</div>

<div id="outline-container-org950c774" class="outline-5">
<h5 id="org950c774"><span class="section-number-5">3.4.2.8</span> Memory-space errors</h5>
<div class="outline-text-5" id="text-3-4-2-8">
<div class="org-src-container">
<pre class="src src-lisp">(def-mcl-error mcpl-memory-space-error mcpl-error)
</pre>
</div>
</div>
</div>
</div>
</div>





<div id="outline-container-org0f9b3ad" class="outline-3">
<h3 id="org0f9b3ad"><span class="section-number-3">3.5</span> Callgraph</h3>
<div class="outline-text-3" id="text-3-5">
</div>
<div id="outline-container-orgfca803b" class="outline-4">
<h4 id="orgfca803b"><span class="section-number-4">3.5.1</span> The package</h4>
<div class="outline-text-4" id="text-3-5-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:callgraph</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:cl-graph-extension</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:make-callgraph</span> <span style="color: #483d8b;">:funcs-ordered</span> <span style="color: #483d8b;">:tops-callgraph</span>
           <span style="color: #483d8b;">:get-funcs-subgraph-ordered</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaa95100" class="outline-4">
<h4 id="orgaa95100"><span class="section-number-4">3.5.2</span> The functionality</h4>
<div class="outline-text-4" id="text-3-5-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">callgraph</span> (graph-container) ())

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-callgraph</span> ()
  (make-instance 'callgraph <span style="color: #483d8b;">:default-edge-type</span> <span style="color: #483d8b;">:directed</span>))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">funcs-ordered</span> (callgraph)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Returns the functions of the callgraph sorted in topogical order."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">funcs-ordered</span> ((callgraph callgraph))
  (mapcar #'element (topological-sort callgraph)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-funcs-subgraph-ordered</span> (callgraph funcs)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Returns a list of functions that form the subgraph of </span>
<span style="color: #8b2252;">functions funcs"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-funcs-subgraph-ordered</span> ((callgraph callgraph) (funcs list))
  (funcs-ordered (get-subgraph callgraph funcs)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-funcs-subgraph-ordered</span> ((callgraph callgraph) (func func))
  (funcs-ordered (get-subgraph callgraph func)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-subgraph</span> (callgraph funcs)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the subgraph of the callgraph give several funcs"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-subgraph</span> ((callgraph callgraph) (func func))
  (closure callgraph (list func)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-subgraph</span> ((callgraph callgraph) (funcs list))
  (closure callgraph funcs))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tops-callgraph</span> (callgraph)
  (mapcar #'element (graph-roots callgraph)))

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org717a170" class="outline-3">
<h3 id="org717a170"><span class="section-number-3">3.6</span> Control-flow graph</h3>
<div class="outline-text-3" id="text-3-6">
<p>
It is possible to create two versions of the control-flow graph.  One version
considers foreach statements as loops, while the other version considers the
foreach statement as one statement or one node in the graph.
</p>
</div>

<div id="outline-container-orgc1f1a84" class="outline-4">
<h4 id="orgc1f1a84"><span class="section-number-4">3.6.1</span> The package</h4>
<div class="outline-text-4" id="text-3-6-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:controlflow</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #b22222;">;;</span><span style="color: #b22222;">:alexandria :anaphora</span>
        <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:cl-graph-extension</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:awhen</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:def-methods</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:make-cfgraph</span>
           <span style="color: #483d8b;">:cfgraph=</span>
           <span style="color: #483d8b;">:basic-blocks</span>
           <span style="color: #483d8b;">:bb</span>
           <span style="color: #483d8b;">:bb-entry</span>
           <span style="color: #483d8b;">:bb-exit</span>
           <span style="color: #483d8b;">:make-bb-entry</span>
           <span style="color: #483d8b;">:make-bb-exit</span>
           <span style="color: #483d8b;">:entry</span>
           <span style="color: #483d8b;">:exit</span>
           <span style="color: #483d8b;">:bb=</span>
           <span style="color: #483d8b;">:ast-&gt;basic-blocks</span>
           <span style="color: #483d8b;">:get-ast-basic-block</span>
           <span style="color: #483d8b;">:get-basic-block-ast</span>
           <span style="color: #483d8b;">:predecessors</span>
           <span style="color: #483d8b;">:successors</span>
           <span style="color: #483d8b;">:predecessor-p</span>
           <span style="color: #483d8b;">:successor-p</span>
           <span style="color: #483d8b;">:remove-unconnected-blocks</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org12956e5" class="outline-4">
<h4 id="org12956e5"><span class="section-number-4">3.6.2</span> The graph</h4>
<div class="outline-text-4" id="text-3-6-2">
<p>
A <code>cfgraph</code> keeps track of the entry and exit nodes.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">cfgraph</span> (graph-container)
  ((entry <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:entry</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"must supply entry"</span>) <span style="color: #483d8b;">:reader</span> entry)
   (exit <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:exit</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"must supply exit"</span>) <span style="color: #483d8b;">:reader</span> exit)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-cfgraph</span> ()
  (<span style="color: #a020f0;">let</span> ((graph (make-directed-graph)))
    (change-class graph 'cfgraph <span style="color: #483d8b;">:entry</span> (make-bb-entry) <span style="color: #483d8b;">:exit</span> (make-bb-exit))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">cfgraph=</span> (cfgraph1 cfgraph2))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">cfgraph=</span> ((g1 cfgraph) (g2 cfgraph))
  (graph= g1 g2 <span style="color: #483d8b;">:test</span> #'bb=))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">basic-blocks</span> (cfgraph))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">basic-blocks</span> ((cfgraph cfgraph))
  (mapcar #'element (vertexes cfgraph)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6bf3219" class="outline-4">
<h4 id="org6bf3219"><span class="section-number-4">3.6.3</span> The main interface</h4>
<div class="outline-text-4" id="text-3-6-3">
<p>
The following code defines several basic-blocks classes:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">bb=</span> (bb1 bb2))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">bb</span> () ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">bb-entry</span> (bb) ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">bb-exit</span> (bb) ())

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-ast-basic-block</span> (basic-block)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the AST from a basic-block."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-ast-basic-block</span> (bb-entry)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-ast-basic-block</span> (bb-exit)
  nil)

(defbb-generic decl)
(defbb-generic stat)
(defbb-generic expr)
(defbb-generic inc)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-bb-entry</span> ()
  (make-instance 'bb-entry))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-bb-exit</span> ()
  (make-instance 'bb-exit))
</pre>
</div>

<p>
The following code defines specific basic block types.  
</p>


<div class="org-src-container">
<pre class="src src-lisp">(defbb bb-decl decl)
(defbb bb-stat stat)
(defbb bb-for-decl decl)
(defbb bb-for-cond expr)
(defbb bb-for-inc inc)
(defbb bb-if-cond expr)
</pre>
</div>

<p>
There are two types for <code>foreach</code> statements.  The first type uses three
different basic blocks to represent the foreach statement as a loop.  The
latter type represents it just as a foreach statement.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defbb bb-foreach-size expr)
(defbb bb-foreach-decl decl)
(defbb bb-foreach-exit decl)

(defbb bb-foreach stat)
</pre>
</div>
</div>
</div>


<div id="outline-container-org666692d" class="outline-4">
<h4 id="org666692d"><span class="section-number-4">3.6.4</span> Macros</h4>
<div class="outline-text-4" id="text-3-6-4">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defbb</span> (name param)
  (<span style="color: #a020f0;">let</span> ((make-name (intern (format nil <span style="color: #8b2252;">"MAKE-~a"</span> name)))
        (keyword (intern (symbol-name param) <span style="color: #8b2252;">"KEYWORD"</span>))
        (superclass-name (intern (format nil <span style="color: #8b2252;">"BB-~a-GENERIC"</span> param))))
    `(<span style="color: #a020f0;">progn</span>
       (<span style="color: #a020f0;">defclass</span> ,name (,superclass-name) ())
       (<span style="color: #a020f0;">defun</span> ,make-name (,param)
         (make-instance ',name ,keyword ,param))
       (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">bb=</span> ((bb1 ,name) (bb2 ,name))
         (ast= (,param bb1) (,param bb2)))
       (export ',make-name)
       (export ',name))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defbb-generic</span> (name)
  (<span style="color: #a020f0;">let</span> ((class-name (intern (format nil <span style="color: #8b2252;">"BB-~a-GENERIC"</span> name)))
        (keyword-name (intern (symbol-name name) <span style="color: #8b2252;">"KEYWORD"</span>)))
    `(<span style="color: #a020f0;">progn</span>
       (<span style="color: #a020f0;">defclass</span> ,class-name (bb)
         ((,name <span style="color: #483d8b;">:initarg</span> ,keyword-name
                 <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> ,(format nil <span style="color: #8b2252;">"must supply ~a"</span> name))
                 <span style="color: #483d8b;">:reader</span> ,name)))
       (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-ast-basic-block</span> ((bb ,class-name))
         (,name bb))
       (export ',class-name))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0fa6f16" class="outline-4">
<h4 id="org0fa6f16"><span class="section-number-4">3.6.5</span> Library functions for controlflow</h4>
<div class="outline-text-4" id="text-3-6-5">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">bb=</span> ((bb1 bb) (bb2 bb)) nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">bb=</span> ((bb1 bb-entry) (bb2 bb-entry)) t)
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">bb=</span> ((bb1 bb-exit) (bb2 bb-exit)) t)


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">predecessors</span> (bb cfgraph)
  (pred/successors bb cfgraph #'parent-vertexes))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">successors</span> (bb cfgraph)
  (pred/successors bb cfgraph #'child-vertexes))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">pred/successors</span> (bb cfgraph func))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pred/successors</span> ((bb cl-graph:graph-container-vertex) cfgraph func)
  (<span style="color: #a020f0;">declare</span> (ignore cfgraph))
  (mapcar #'element (funcall func bb)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pred/successors</span> (bb cfgraph func)
  (mapcar #'element (funcall func (find-vertex cfgraph bb))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">predecessor-p</span> (pred-bb succ-bb cfgraph)
  <span style="color: #8b2252;">"Whether pred-bb is a predecessor of succ-bb in controlflow graph cfgraph"</span>
  (member pred-bb (predecessors succ-bb cfgraph)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">successor-p</span> (succ-bb pred-bb cfgraph)
  <span style="color: #8b2252;">"Whether succ-bb is a successor of pred-bb in controlflow graph cfgraph"</span>
  (member succ-bb (successors pred-bb cfgraph)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-basic-block-ast</span> (ast cfgraph)
  (<span style="color: #a020f0;">let</span> ((bbs (basic-blocks cfgraph)))
    (<span style="color: #a020f0;">loop</span> for bb in bbs
       do (awhen (get-ast-basic-block bb)
            (<span style="color: #a020f0;">when</span> (retrieve-all it #'(<span style="color: #a020f0;">lambda</span> (ast-form) (eq ast-form ast)))
              (<span style="color: #a020f0;">return</span> bb))))))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defgeneric ast-in-bb-p (ast bb))</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defmethod ast-in-bb-p ((ast bb))</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">nil)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defmethod ast-in-bb-p (ast ))</span>

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-unconnected-blocks</span> (cfgraph)
  (subgraph-containing cfgraph (find-vertex cfgraph (entry cfgraph))))
</pre>
</div>


<p>
Printing functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((bb bb-decl-generic) stream)
  (print-unreadable-object (bb stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a"</span> (decl bb))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((bb bb-stat-generic) stream)
  (print-unreadable-object (bb stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a"</span> (stat bb))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((bb bb-expr-generic) stream)
  (print-unreadable-object (bb stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a"</span> (expr bb))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((bb bb-inc-generic) stream)
  (print-unreadable-object (bb stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a"</span> (inc bb))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((bb bb-foreach) stream)
  (print-unreadable-object (bb stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"foreach ~a"</span> (decl (stat bb)))))
</pre>
</div>

<p>
Other library functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">ast-&gt;basic-blocks</span> (ast)
  (<span style="color: #a020f0;">let</span> ((cfgraph (cfgraph (get-func ast))))
    (ast-&gt;basic-blocks2 ast (basic-blocks cfgraph))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">ast-&gt;basic-blocks2</span> (ast basic-blocks))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast-&gt;basic-blocks2</span> ((fes foreach-stat) basic-blocks)
  (<span style="color: #a020f0;">with-slots</span> (decl nr-iters stat) fes
    (concatenate
     'list
     (list (find-basic-block-with-type 'bb-foreach-decl
                                       (equals-bb-decl decl) basic-blocks)
           (find-basic-block-with-type 'bb-foreach-size
                                       (equals-bb-expr nr-iters) basic-blocks))
     (ast-&gt;basic-blocks2 stat basic-blocks))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast-&gt;basic-blocks2</span> ((fs for-stat) basic-blocks)
  (<span style="color: #a020f0;">with-slots</span> (decl cond-expr inc stat) fs
    (concatenate
     'list
     (list (find-basic-block-with-type 'bb-for-decl
                                       (equals-bb-decl decl) basic-blocks)
           (find-basic-block-with-type 'bb-for-cond
                                       (equals-bb-expr cond-expr)
                                       basic-blocks)
           (find-basic-block-with-type 'bb-for-inc
                                       (equals-bb-inc inc) basic-blocks))
     (ast-&gt;basic-blocks2 stat basic-blocks))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast-&gt;basic-blocks2</span> ((bs block-stat) basic-blocks)
  (<span style="color: #a020f0;">with-slots</span> (code-block) bs
    (ast-&gt;basic-blocks2 code-block basic-blocks)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast-&gt;basic-blocks2</span> ((cb code-block) basic-blocks)
  (mapcan #'(<span style="color: #a020f0;">lambda</span> (stat) (ast-&gt;basic-blocks2 stat basic-blocks)) (stats cb)))

(def-methods ast-&gt;basic-blocks2
    ((stat (decl-stat assign-stat inc-stat call-stat swap-stat barrier-stat
                      as-stat))
     basic-blocks)
  (list (find-basic-block-stat stat basic-blocks)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast-&gt;basic-blocks2</span> ((decl decl) basic-blocks)
  (list (find-basic-block (has-one-of-types '(bb-stat bb-decl))
                          #'(<span style="color: #a020f0;">lambda</span> (bb)
                              (<span style="color: #a020f0;">typecase</span> bb
                                (bb-stat (<span style="color: #a020f0;">let</span> ((s (stat bb)))
                                    (and (typep s 'decl-stat)
                                         (eq decl (decl s)))))
                                (bb-decl (eq decl (decl bb)))
                                (otherwise nil)))
                          basic-blocks)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-basic-block-stat</span> (stat basic-blocks)
  (find-basic-block-with-type 'bb-stat (equals-bb-stat stat) basic-blocks))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">ast-&gt;basic-blocks2</span> ((is if-stat) basic-blocks)
  (<span style="color: #a020f0;">with-slots</span> (cond-expr stat elsestat) is
    (cons (find-basic-block-with-type 'bb-if-cond
                                      (equals-bb-expr cond-expr) basic-blocks)
          (concatenate
           'list
           (ast-&gt;basic-blocks2 stat basic-blocks)
           (<span style="color: #a020f0;">if</span> elsestat (ast-&gt;basic-blocks2 elsestat basic-blocks) nil)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-basic-block-with-type</span> (type equal-test basic-blocks)
  (find-basic-block (has-one-of-types (list type)) equal-test basic-blocks))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-basic-block</span> (type-test equal-test basic-blocks)
  (<span style="color: #a020f0;">loop</span> for bb in basic-blocks
     do (<span style="color: #a020f0;">if</span> (and (funcall type-test bb) (funcall equal-test bb))
            (<span style="color: #a020f0;">return-from</span> find-basic-block bb)))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Did not find basic-block"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">has-one-of-types</span> (types)
  #'(<span style="color: #a020f0;">lambda</span> (bb)
      (<span style="color: #a020f0;">loop</span> for type in types thereis (typep bb type))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equals-bb-decl</span> (decl)
  #'(<span style="color: #a020f0;">lambda</span> (bb) (eq decl (decl bb))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equals-bb-expr</span> (expr)
  #'(<span style="color: #a020f0;">lambda</span> (bb) (eq expr (expr bb))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equals-bb-stat</span> (stat)
  #'(<span style="color: #a020f0;">lambda</span> (bb) (eq stat (stat bb))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equals-bb-inc</span> (inc)
  #'(<span style="color: #a020f0;">lambda</span> (bb) (eq inc (inc bb))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4c4b600" class="outline-3">
<h3 id="org4c4b600"><span class="section-number-3">3.7</span> Dataflow</h3>
<div class="outline-text-3" id="text-3-7">
</div>
<div id="outline-container-orgb51ee2c" class="outline-4">
<h4 id="orgb51ee2c"><span class="section-number-4">3.7.1</span> Defining the package</h4>
<div class="outline-text-4" id="text-3-7-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:dataflow</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span>
        <span style="color: #b22222;">;;</span><span style="color: #b22222;">:alexandria</span>
        <span style="color: #483d8b;">:cl-graph</span>
        <span style="color: #483d8b;">:simple-sets</span>
        <span style="color: #b22222;">;;</span><span style="color: #b22222;">:anaphora :ast</span>
        <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:copy-hash-table</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:hash-table=</span> <span style="color: #483d8b;">:fixed-point</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:dataflow-forward</span> <span style="color: #483d8b;">:dataflow-backward</span>
           <span style="color: #483d8b;">:must-forward</span> <span style="color: #483d8b;">:must-backward</span>
           <span style="color: #483d8b;">:may-forward</span> <span style="color: #483d8b;">:may-backward</span>

           <span style="color: #483d8b;">:add-forward-dataflow-analysis</span>
           <span style="color: #483d8b;">:add-backward-dataflow-analysis</span>
           <span style="color: #483d8b;">:out-set</span>
           <span style="color: #483d8b;">:in-set</span>

           <span style="color: #483d8b;">:dataflow-element</span>
           <span style="color: #483d8b;">:dataflow-variable-with-bb</span>
           <span style="color: #483d8b;">:dataflow-variable</span>
           <span style="color: #483d8b;">:bb-dataflow-element</span>
           <span style="color: #483d8b;">:definition</span>
           <span style="color: #483d8b;">:use</span>

           <span style="color: #483d8b;">:make-dataflow-variable</span>

           <span style="color: #483d8b;">:dataflow-element=</span>

           <span style="color: #483d8b;">:make-dataflow-set</span>
           <span style="color: #483d8b;">:universal-set</span>
           <span style="color: #483d8b;">:empty-dataflow-map</span>
           <span style="color: #483d8b;">:empty-dataflow-map-p</span>

           <span style="color: #483d8b;">:dataflow-union</span>
           <span style="color: #483d8b;">:dataflow-intersection</span>
           <span style="color: #483d8b;">:dataflow-difference</span>

           <span style="color: #483d8b;">:get-predecessor-values</span>
           <span style="color: #483d8b;">:get-successor-values</span>
           <span style="color: #483d8b;">:filter-dataflow-map</span>
           <span style="color: #483d8b;">:combine</span>
           <span style="color: #483d8b;">:get-ast-dataflow-element</span>

           <span style="color: #483d8b;">:dataflow-variables-called-func-&gt;calling-func</span>
           <span style="color: #483d8b;">:dataflow-variable-called-func-&gt;calling-func</span>
           <span style="color: #483d8b;">:dataflow-variables-calling-func-&gt;called-func</span>
           <span style="color: #483d8b;">:dataflow-variable-calling-func-&gt;called-func</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org578c9b2" class="outline-4">
<h4 id="org578c9b2"><span class="section-number-4">3.7.2</span> The basic dataflow framework</h4>
<div class="outline-text-4" id="text-3-7-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-forward</span> (cfgraph v-entry top transfer-function meet)
  <span style="color: #8b2252;">"Execute a forward dataflow instance with controlflow graph cfgraph, the</span>
<span style="color: #8b2252;">dataflow value v-entry for the entry node in the controlflow graph, a function</span>
<span style="color: #8b2252;">top that gives each block an initial top dataflow value, a transfer function</span>
<span style="color: #8b2252;">that returns a dataflow value based on a basic block and a dataflow-value in</span>
<span style="color: #8b2252;">the controlflow graph and a meet function that combines dataflow values from IN</span>
<span style="color: #8b2252;">and OUT.</span>

<span style="color: #8b2252;">cfgraph should be of type cfgraph</span>
<span style="color: #8b2252;">v-entry should be of type dataflow-value</span>
<span style="color: #8b2252;">top should be a function that returns a dataflow-value given no arguments.</span>
<span style="color: #8b2252;">   It is necessary that \"x meet top = x\" and \"top meet x = x\"</span>
<span style="color: #8b2252;">transfer-function should be a function with a basic-block and dataflow-value as</span>
<span style="color: #8b2252;">   input and returns a dataflow-value</span>
<span style="color: #8b2252;">meet is a function that takes two dataflow values and returns a dataflow-value</span>

<span style="color: #8b2252;">The function returns a pair of dataflow maps with OUT as the first value and IN</span>
<span style="color: #8b2252;">as the second value."</span>
  (dataflow cfgraph v-entry top transfer-function meet #'entry #'predecessors))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-backward</span> (cfgraph v-exit top transfer-function meet)
  <span style="color: #8b2252;">"Execute a backward dataflow instance with controlflow graph cfgraph, the</span>
<span style="color: #8b2252;">dataflow value v-exit for the exit node in the controlflow graph, a function</span>
<span style="color: #8b2252;">top that gives each block an initial top dataflow value, a transfer function</span>
<span style="color: #8b2252;">that returns a dataflow value based on a basic block and a dataflow-value in</span>
<span style="color: #8b2252;">the controlflow graph and a meet function that combines dataflow values from OUT</span>
<span style="color: #8b2252;">and IN.</span>

<span style="color: #8b2252;">cfgraph should be of type cfgraph</span>
<span style="color: #8b2252;">v-exit should be of type dataflow-value</span>
<span style="color: #8b2252;">top should be a function that returns a dataflow-value given no arguments.</span>
<span style="color: #8b2252;">   It is necessary that \"x meet top = x\" and \"top meet x = x\"</span>
<span style="color: #8b2252;">transfer-function should be a function with a basic-block and dataflow-value as</span>
<span style="color: #8b2252;">   input and returns a dataflow-value</span>
<span style="color: #8b2252;">meet is a function that takes two dataflow values and returns a dataflow-value</span>

<span style="color: #8b2252;">The function returns a pair of dataflow maps with IN as the first value and OUT</span>
<span style="color: #8b2252;">as the second value."</span>
  (dataflow cfgraph v-exit top transfer-function meet #'exit #'successors))
</pre>
</div>

<p>
The following function is the actual dataflow function and is written in a
forward manner:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow</span> (cfgraph v-entry top transfer-function meet entry predecessors)
  (<span style="color: #a020f0;">let*</span> ((bb-vertexes (vertexes cfgraph))
         (entry (funcall entry cfgraph))
         (bb-vertexes-wo-entry (remove-if #'(<span style="color: #a020f0;">lambda</span> (x)
                                              (eq (element x) entry))
                                          bb-vertexes))
         (out (make-hash-table))
         (in (make-hash-table)))
    (<span style="color: #a020f0;">dolist</span> (bb-vertex bb-vertexes)
      (<span style="color: #a020f0;">let</span> ((bb (element bb-vertex)))
        (setf (gethash bb in) (make-dataflow-set))
        (setf (gethash bb out) (make-dataflow-set))))
    (setf (gethash entry out) v-entry)
    (<span style="color: #a020f0;">dolist</span> (bb-vertex bb-vertexes-wo-entry)
      (<span style="color: #a020f0;">let</span> ((bb (element bb-vertex)))
        (setf (gethash bb out) (copy-set top))))
    (fixed-point out #'copy #'compare
      (debug-df2 <span style="color: #8b2252;">"new iteration"</span> <span style="color: #8b2252;">""</span> <span style="color: #8b2252;">""</span> predecessors cfgraph out in)
      (<span style="color: #a020f0;">dolist</span> (bb-vertex bb-vertexes-wo-entry)
        (<span style="color: #a020f0;">let</span> ((b (element bb-vertex)))
          (setf (gethash b in) (make-dataflow-set))
          (debug-df (format nil <span style="color: #8b2252;">"doing block ~a"</span> b))
          (setf (gethash b in)
                (compute-meet
                 out meet
                 (funcall predecessors bb-vertex cfgraph)))
          (debug-df2 <span style="color: #8b2252;">"after the meets of each "</span> <span style="color: #8b2252;">"predecessor"</span> <span style="color: #8b2252;">"successor"</span>
                     predecessors cfgraph out in)
          (setf (gethash b out) (funcall transfer-function b (gethash b in)))
          (debug-df2 <span style="color: #8b2252;">"after the transfer function"</span> <span style="color: #8b2252;">""</span> <span style="color: #8b2252;">""</span> predecessors
                     cfgraph out in))))
    (visualize-df entry cfgraph out in)
    (values out in)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-meet</span> (out meet predecessors)
  (<span style="color: #a020f0;">destructuring-bind</span> (first <span style="color: #228b22;">&amp;rest</span> rest) predecessors
    (<span style="color: #a020f0;">let</span> ((result (copy-set (gethash first out))))
      (<span style="color: #a020f0;">dolist</span> (p rest)
        (setf result (funcall meet result (gethash p out))))
      result)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org3ff04f7" class="outline-4">
<h4 id="org3ff04f7"><span class="section-number-4">3.7.3</span> Generic functions</h4>
<div class="outline-text-4" id="text-3-7-3">
<p>
The following functions are useful generic must/may forward/backward functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">must-forward</span> (cfgraph gen kill)
  (must-forward/backward cfgraph gen kill #'dataflow-forward))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">must-backward</span> (cfgraph gen kill)
  (must-forward/backward cfgraph gen kill #'dataflow-backward))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">may-backward</span> (cfgraph gen kill)
  (may-forward/backward cfgraph gen kill #'dataflow-backward))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">may-forward</span> (cfgraph gen kill)
  (may-forward/backward cfgraph gen kill #'dataflow-forward))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">must-forward/backward</span> (cfgraph gen kill dataflow-func)
  (must/may-forward/backward cfgraph gen kill dataflow-func (universal-set gen)
                             #'intersection))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">may-forward/backward</span> (cfgraph gen kill dataflow-func)
  (must/may-forward/backward cfgraph gen kill dataflow-func (make-dataflow-set)
                             #'union))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">must/may-forward/backward</span> (cfgraph gen kill dataflow-func top meet)
  (funcall dataflow-func
     cfgraph
     (make-dataflow-set)
     top
     #'(<span style="color: #a020f0;">lambda</span> (bb v)
         (union (gethash bb gen) (set-difference v (gethash bb kill))))
     meet))
</pre>
</div>
</div>
</div>



<div id="outline-container-orgba58f48" class="outline-4">
<h4 id="orgba58f48"><span class="section-number-4">3.7.4</span> Basic dataflow-elements</h4>
<div class="outline-text-4" id="text-3-7-4">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">dataflow-element</span> () ())

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">dataflow-variable</span> (dataflow-element)
  ((decl <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:decl</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"must supply a decl"</span>) <span style="color: #483d8b;">:reader</span> decl)))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">bb-dataflow-element</span> (dataflow-element) 
  ((bb <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:bb</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"must supply basic-block"</span>) <span style="color: #483d8b;">:reader</span> bb)))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">dataflow-variable-with-bb</span> (dataflow-variable bb-dataflow-element) ())

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">definition</span> (dataflow-variable-with-bb) ())

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">use</span> (dataflow-variable-with-bb) ())

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">dataflow-element=</span> (e1 e2)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"whether two dataflow elements are the same"</span>)
  (<span style="color: #483d8b;">:method-combination</span> and))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">dataflow-element=</span> and ((de1 bb-dataflow-element) (de2 bb-dataflow-element))
  (eq (bb de1) (bb de2)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">dataflow-element=</span> and ((dv1 dataflow-variable) (dv2 dataflow-variable))
  (eq (decl dv1) (decl dv2)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-dataflow-set</span> (<span style="color: #228b22;">&amp;optional</span> elements)
  (make-set <span style="color: #483d8b;">:test</span> #'dataflow-element= <span style="color: #483d8b;">:elements</span> elements))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-dataflow-variable</span> (decl)
  (make-instance 'dataflow-variable <span style="color: #483d8b;">:decl</span> decl))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((d dataflow-variable-with-bb) stream)
  (print-unreadable-object (d stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a: ~a"</span> (bb d) (decl d))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((d dataflow-variable) stream)
  (print-unreadable-object (d stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a"</span> (decl d))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org884c660" class="outline-4">
<h4 id="org884c660"><span class="section-number-4">3.7.5</span> Some utility functions</h4>
<div class="outline-text-4" id="text-3-7-5">
<p>
The following macro helps to retrieve the IN or OUT set of a dataflow map.  It
makes use of two global variables that maintain whether an analysis is forward
of backward.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*forward-dataflow-analyses*</span> (list 'dataflow-forward))
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*backward-dataflow-analyses*</span> (list 'dataflow-backward))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-forward-dataflow-analysis</span> (symbol)
  (push symbol *forward-dataflow-analyses*))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-backward-dataflow-analysis</span> (symbol)
  (push symbol *backward-dataflow-analyses*))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">out-set</span> (analysis)
  (in/out-set analysis 0 1))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">in-set</span> (analysis)
  (in/out-set analysis 1 0))

(<span style="color: #a020f0;">eval-when</span> (<span style="color: #483d8b;">:compile-toplevel</span> <span style="color: #483d8b;">:load-toplevel</span>)
  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">in/out-set</span> (analysis value-forward value-backward)
    (<span style="color: #a020f0;">if</span> (listp analysis)
        (<span style="color: #a020f0;">let</span> ((name-analysis (first analysis)))
          (<span style="color: #a020f0;">cond</span> ((member name-analysis *forward-dataflow-analyses*)
                 `(nth-value ,value-forward ,analysis))
                ((member name-analysis *backward-dataflow-analyses*)
                 `(nth-value ,value-backward ,analysis))
                (t (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Analysis ~a is not known to be forward or backward</span>
<span style="color: #8b2252;">Use add-forward-dataflow-analysis or add-backward-dataflow-analysis to register</span>
<span style="color: #8b2252;">the analyses."</span> name-analysis))))
        (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"in/out-set only works on function calls"</span>))))
</pre>
</div>



<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-ast-dataflow-element</span> (dataflow-element))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-ast-dataflow-element</span> ((de bb-dataflow-element))
  (get-ast-basic-block (bb de)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-union</span> (map1 map2)
  (dataflow-set-operation map1 map2 #'union))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-difference</span> (map1 map2)
  (dataflow-set-operation map1 map2 #'set-difference))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-intersection</span> (map1 map2)
  (dataflow-set-operation map1 map2 #'intersection))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-set-operation</span> (map1 map2 operation)
  (<span style="color: #a020f0;">let</span> ((result-map (make-hash-table)))
    (<span style="color: #a020f0;">loop</span> for bb being the hash-keys in map1
       do (do-set-operation bb result-map map1 map2 operation))
    result-map))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-set-operation</span> (bb result-map map1 map2 operation)
  (setf (gethash bb result-map)
        (funcall operation (gethash bb map1) (gethash bb map2))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">universal-set</span> (map)
  (<span style="color: #a020f0;">let</span> ((set (make-set <span style="color: #483d8b;">:test</span> #'dataflow-element=)))
    (<span style="color: #a020f0;">loop</span> for bb being the hash-key in map
       do (add-all-to-set (elements (gethash bb map)) set))
    set))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">empty-dataflow-map</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((map (make-hash-table)))
    (<span style="color: #a020f0;">loop</span> for bb in (basic-blocks cfgraph)
       do (setf (gethash bb map) (make-dataflow-set)))
    map))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">empty-dataflow-map-p</span> (dataflow-map)
  (<span style="color: #a020f0;">loop</span> for v being the hash-values in dataflow-map
       always (empty-set-p v)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-predecessor-values</span> (map cfgraph)
  (get-pred/succ-values map cfgraph #'predecessor-p))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-successor-values</span> (map cfgraph)
  (get-pred/succ-values map cfgraph #'successor-p))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-pred/succ-values</span> (map cfgraph pred/succ-func)
  (combine map map
           #'(<span style="color: #a020f0;">lambda</span> (b1 b2) (funcall pred/succ-func b2 b1 cfgraph))
           (constantly t)
           #'(<span style="color: #a020f0;">lambda</span> (e1 e2) (<span style="color: #a020f0;">declare</span> (ignore e1)) e2)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">filter-dataflow-map</span> (pred map)
  (combine map map #'eq
           #'(<span style="color: #a020f0;">lambda</span> (e1 e2) (<span style="color: #a020f0;">declare</span> (ignore e2)) (funcall pred e1))
           #'(<span style="color: #a020f0;">lambda</span> (e1 e2) (<span style="color: #a020f0;">declare</span> (ignore e2)) e1)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">combine</span> (map1 map2 bb-predicate dataflow-predicate create-element-func)
  <span style="color: #8b2252;">"Combine two dataflow solutions.</span>

<span style="color: #8b2252;">bb-predicate should be a predicate on two basic blocks, </span>
<span style="color: #8b2252;">  for example whether they are equal or not.</span>
<span style="color: #8b2252;">dataflow-predicate should be a predicate on two dataflow-elements,</span>
<span style="color: #8b2252;">  for example whether two declarations are the same.</span>
<span style="color: #8b2252;">create-element-func should be a function that takes two dataflow elements</span>
<span style="color: #8b2252;">  and returns a new one."</span>
  (<span style="color: #a020f0;">let</span> ((map (make-hash-table)))
    (<span style="color: #a020f0;">loop</span> for bb1 being the hash-keys in map1
       do (<span style="color: #a020f0;">let</span> ((set (make-dataflow-set)))
            (<span style="color: #a020f0;">loop</span> for bb2 being the hash-keys in map2
               when (funcall bb-predicate bb1 bb2)
               do (fill-set (gethash bb1 map1) (gethash bb2 map2)
                            dataflow-predicate create-element-func set))
            (setf (gethash bb1 map) set)))
    map))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">fill-set</span> (set1 set2 dataflow-predicate create-element-func result-set)
  (<span style="color: #a020f0;">let</span> ((elements1 (elements set1))
        (elements2 (elements set2)))
    (<span style="color: #a020f0;">loop</span> for e1 in elements1
       do (<span style="color: #a020f0;">loop</span> for e2 in elements2
             when (funcall dataflow-predicate e1 e2)
             do (add-to-set (funcall create-element-func e1 e2) result-set)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">copy</span> (hash-table)
  (copy-hash-table hash-table <span style="color: #483d8b;">:key</span> #'copy-set))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compare</span> (hash-table-1 hash-table-2)
  (hash-table= hash-table-1 hash-table-2 <span style="color: #483d8b;">:test-for-value</span> #'set=))
</pre>
</div>


<p>
Converting dataflow variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-variables-called-func-&gt;calling-func</span>
    (dataflow-variables-list call)
  <span style="color: #8b2252;">"Takes a list of dataflow variables and a call and transforms the declarations</span>
<span style="color: #8b2252;">to those of the calling function.  It returns a list."</span>
  (<span style="color: #a020f0;">loop</span> for dv in dataflow-variables-list collect
       (dataflow-variable-called-func-&gt;calling-func dv call)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-variable-called-func-&gt;calling-func</span>
    (dataflow-variable-called-func call)
  <span style="color: #8b2252;">"Makes a dataflow-variable from the called function to one that belongs to the</span>
<span style="color: #8b2252;">calling function."</span>
  (make-instance
   (class-of dataflow-variable-called-func)
   <span style="color: #483d8b;">:decl</span> (decl-called-func-&gt;calling-func
          (decl dataflow-variable-called-func) call)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-variables-calling-func-&gt;called-func</span>
    (dataflow-variables-list call)
  <span style="color: #8b2252;">"Takes a list of dataflow variables and a call and transforms the declarations</span>
<span style="color: #8b2252;">to those of the calling function.  It returns a list."</span>
  (<span style="color: #a020f0;">loop</span> for dv in dataflow-variables-list collect 
       (dataflow-variable-calling-func-&gt;called-func dv call)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-variable-calling-func-&gt;called-func</span>
    (dataflow-variable-calling-func call)
  <span style="color: #8b2252;">"Makes a dataflow-variable from the calling function to one that belongs to </span>
<span style="color: #8b2252;">the called function."</span>
  (make-instance
   (class-of dataflow-variable-calling-func)
   <span style="color: #483d8b;">:decl</span>
   (decl-calling-func-&gt;called-func (decl dataflow-variable-calling-func) call)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org70d577e" class="outline-4">
<h4 id="org70d577e"><span class="section-number-4">3.7.6</span> Debugging functions</h4>
<div class="outline-text-4" id="text-3-7-6">
<p>
The following functions are empty debugging functions.  By redefining these
functions, one can debug and visualize the dataflow process.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">debug-df2</span> (message arg-forward arg-backward predecessor-function
                  cfgraph out in)
  (<span style="color: #a020f0;">declare</span> (ignore message arg-forward arg-backward predecessor-function
                   cfgraph out in)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">debug-df</span> (message <span style="color: #228b22;">&amp;optional</span> cfgraph out in)
  (<span style="color: #a020f0;">declare</span> (ignore message cfgraph out in)))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visualize-df</span> (entry cfgraph out in)
  (<span style="color: #a020f0;">declare</span> (ignore entry cfgraph out in)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*turn-debug-on*</span> nil)
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*turn-visualize-on*</span> nil)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">turn-on-debug</span> () (setf *turn-debug-on* t))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">turn-off-debug</span> () (setf *turn-debug-on* nil))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">turn-on-visualize</span> () (setf *turn-visualize-on* t))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">turn-off-visualize</span> ()  (setf *turn-visualize-on* nil))
 
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">debug-df</span> (message <span style="color: #228b22;">&amp;optional</span> cfgraph out in)
  (<span style="color: #a020f0;">when</span> *turn-debug-on*
    (format t <span style="color: #8b2252;">"~a~%"</span> message)
    (<span style="color: #a020f0;">when</span> (and cfgraph out in)
      (show cfgraph in out t))))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">(uiop:run-program '("dot" "-Tpng" "/home/pieter/dataflow.dot") :output "/home/pieter/dataflow.png")</span>
<span style="color: #b22222;">;;</span><span style="color: #b22222;">(uiop:run-program '("qiv" "-t" "/home/pieter/dataflow.png"))</span>

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">debug-df2</span> (message arg-forward arg-backward predecessor-function
                  cfgraph out in)
  
  (<span style="color: #a020f0;">when</span> *turn-debug-on*
    (<span style="color: #a020f0;">if</span> (eq predecessor-function #'predecessors)
        (<span style="color: #a020f0;">progn</span> (format t <span style="color: #8b2252;">"~a~a~%"</span> message arg-forward)
               (<span style="color: #a020f0;">when</span> (and cfgraph out in)
                 (show cfgraph in out t)))
        (<span style="color: #a020f0;">progn</span> (format t <span style="color: #8b2252;">"~a~a~%"</span> message arg-backward)
               (<span style="color: #a020f0;">when</span> (and cfgraph out in)
                 (show cfgraph out in t))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">show</span> (cfgraph in out generate-png)
  (visualize-dataflow-graph:visualize-dataflow-graph
   cfgraph in out <span style="color: #8b2252;">"/home/pieter/dataflow.dot"</span>)
  (<span style="color: #a020f0;">when</span> generate-png
    (uiop:run-program
     '(<span style="color: #8b2252;">"dot"</span> <span style="color: #8b2252;">"-Tpng"</span> <span style="color: #8b2252;">"/home/pieter/dataflow.dot"</span>)
     <span style="color: #483d8b;">:output</span> <span style="color: #8b2252;">"/home/pieter/dataflow.png"</span>)
    (uiop:run-program '(<span style="color: #8b2252;">"qiv"</span> <span style="color: #8b2252;">"-t"</span> <span style="color: #8b2252;">"/home/pieter/dataflow.png"</span>))))
  
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visualize-df</span> (entry cfgraph out in)
  (<span style="color: #a020f0;">when</span> *turn-visualize-on*
    (<span style="color: #a020f0;">if</span> (typep entry 'bb-entry)
        (show cfgraph in out t)
        (show cfgraph out in t))))
</pre>
</div>
</div>
</div>




<div id="outline-container-org7a0248d" class="outline-4">
<h4 id="org7a0248d"><span class="section-number-4">3.7.7</span> A library to help testing dataflow</h4>
<div class="outline-text-4" id="text-3-7-7">
</div>
<div id="outline-container-org2fbe8bf" class="outline-5">
<h5 id="org2fbe8bf"><span class="section-number-5">3.7.7.1</span> The package</h5>
<div class="outline-text-5" id="text-3-7-7-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-dataflow-library</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:simple-sets</span>
        <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span>
        <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:resolve-vars</span> <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:parse-mcpl</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:build-definition</span>
           <span style="color: #483d8b;">:build-use</span>

           <span style="color: #483d8b;">:build-dataflow-set</span>

           <span style="color: #483d8b;">:build-compare-set</span> <span style="color: #483d8b;">:build-element</span> <span style="color: #483d8b;">:build-use-var</span>
           <span style="color: #483d8b;">:map-&gt;compare-set</span>
           <span style="color: #483d8b;">:get-cfgraph</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9be05c5" class="outline-5">
<h5 id="org9be05c5"><span class="section-number-5">3.7.7.2</span> The functionality</h5>
<div class="outline-text-5" id="text-3-7-7-2">
<p>
Firstly, we need compare functions to verify the results:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">eq-bb</span> (bb1 bb2))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-bb</span> ((bb1 bb) (bb2 bb))
  (<span style="color: #a020f0;">if</span> (eq (type-of bb1) (type-of bb2))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not implemented for ~a"</span> bb1)
      nil))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-bb</span> ((bb1 bb-exit) (bb2 bb-exit))
  t)
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-bb</span> ((bb1 bb-entry) (bb2 bb-entry))
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-bb</span> ((bb1 bb-decl-generic) (bb2 bb-decl-generic))
  (ast= (decl bb1) (decl bb2)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-bb</span> ((bb1 bb-stat-generic) (bb2 bb-stat-generic))
  (ast= (stat bb1) (stat bb2)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-bb</span> ((bb1 bb-expr-generic) (bb2 bb-expr-generic))
  (ast= (expr bb1) (expr bb2)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-bb</span> ((bb1 bb-inc-generic) (bb2 bb-inc-generic))
  (ast= (inc bb1) (inc bb2)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">eq-dataflow-element</span> (e1 e2)
  (<span style="color: #483d8b;">:method-combination</span> and))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-dataflow-element</span> and ((de1 bb-dataflow-element) (de2 bb-dataflow-element))
  (eq-bb (bb de1) (bb de2)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-dataflow-element</span> and ((de1 dataflow-variable) (de2 dataflow-variable))
  (ast= (decl de1) (decl de2)))
</pre>
</div>

<p>
We also need datastructures to compare dataflow-results.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">element</span> ()
  ((bb <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:bb</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"need bb"</span>) <span style="color: #483d8b;">:reader</span> bb)
   (dataflow-set <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:dataflow-set</span>
                 <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"need dataflow-set"</span>) <span style="color: #483d8b;">:reader</span> dataflow-set)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-element</span> (bb dataflow-set)
  (make-instance 'element <span style="color: #483d8b;">:bb</span> bb <span style="color: #483d8b;">:dataflow-set</span> dataflow-set))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">element=</span> (e1 e2)
  (and
   (eq-bb (bb e1) (bb e2))
   (set= (dataflow-set e1) (dataflow-set e2))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-compare-set</span> (<span style="color: #228b22;">&amp;key</span> (elements nil))
  (make-set <span style="color: #483d8b;">:test</span> #'element= <span style="color: #483d8b;">:elements</span> elements))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-dataflow-test-set</span> (<span style="color: #228b22;">&amp;key</span> elements)
  (make-set <span style="color: #483d8b;">:test</span> #'eq-dataflow-element <span style="color: #483d8b;">:elements</span> elements))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((e element) stream)
  (print-unreadable-object (e stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a: ~a"</span> (bb e) (dataflow-set e))))
</pre>
</div>

<p>
We need functions to build the compare set from scratch.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-empty-bb</span> (bb set)
  (<span style="color: #a020f0;">unless</span> (find bb (elements set) <span style="color: #483d8b;">:test</span> #'eq-bb <span style="color: #483d8b;">:key</span> #'bb)
    (add-to-compare-set (make-element bb (make-dataflow-test-set <span style="color: #483d8b;">:elements</span> nil))
                        set)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-compare-set</span> (<span style="color: #228b22;">&amp;rest</span> elements)
  (<span style="color: #a020f0;">let</span> ((set (make-compare-set <span style="color: #483d8b;">:elements</span> nil)))
    (<span style="color: #a020f0;">loop</span> for element in elements do (add-to-compare-set element set))
    (add-empty-bb (make-bb-entry) set)
    (add-empty-bb (make-bb-exit) set)
    set))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">add-to-compare-set</span> (element set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-to-compare-set</span> ((d definition) set)
  (add-to-compare-set (make-element
                       (bb d)
                       (make-dataflow-test-set <span style="color: #483d8b;">:elements</span> (list d))) <span style="color: #ff0000; font-weight: bold;">set))</span>

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-to-compare-set</span> ((e element) set)
  (add-to-set e set))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-element</span> (decl-or-stat dataflow-set))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-element</span> ((d decl) dataflow-set)
  (make-element (make-bb-decl d) dataflow-set))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-element</span> ((s stat) dataflow-set)
  (make-element (make-bb-stat s) dataflow-set))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-element</span> ((bb bb) dataflow-set)
  (make-element bb dataflow-set))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-dataflow-set</span> (<span style="color: #228b22;">&amp;rest</span> elements)
  (make-dataflow-test-set <span style="color: #483d8b;">:elements</span> elements))


(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-definition</span> (decl decl-or-stat))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-definition</span> (d (d2 decl))
  (make-instance 'definition <span style="color: #483d8b;">:decl</span> d <span style="color: #483d8b;">:bb</span> (make-bb-decl d2)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-definition</span> (d (s stat))
  (make-instance 'definition <span style="color: #483d8b;">:decl</span> d <span style="color: #483d8b;">:bb</span> (make-bb-stat s)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">build-use</span> (decl decl-or-stat))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-use</span> (d (d2 decl))
  (make-instance 'use <span style="color: #483d8b;">:decl</span> d <span style="color: #483d8b;">:bb</span> (make-bb-decl d2)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">build-use</span> (d (s stat))
  (make-instance 'use <span style="color: #483d8b;">:decl</span> d <span style="color: #483d8b;">:bb</span> (make-bb-stat s)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">map-&gt;compare-set</span> (hash-table cfgraph)
  (<span style="color: #a020f0;">let</span> ((result (make-compare-set)))
    (<span style="color: #a020f0;">dolist</span> (bb (mapcar #'element (vertexes cfgraph)))
      (<span style="color: #a020f0;">let</span> ((dataflow-set (elements (gethash bb hash-table))))
        (add-to-set (build-element
                     bb
                     (make-dataflow-test-set <span style="color: #483d8b;">:elements</span> dataflow-set))
                    result)))
    result))
</pre>
</div>


<p>
Finally, we need some functionality for getting the results:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-cfgraph</span> (input)
  (<span style="color: #a020f0;">let</span> ((ast (set-cfgraphs
              (resolve-vars
               (set-parents (parse-mcpl input)) nil))))
    (values (cfgraph (first (funcs (code ast)))) ast)))
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org342e5ca" class="outline-3">
<h3 id="org342e5ca"><span class="section-number-3">3.8</span> Hardware descriptions</h3>
<div class="outline-text-3" id="text-3-8">
</div>
<div id="outline-container-org7761a38" class="outline-4">
<h4 id="org7761a38"><span class="section-number-4">3.8.1</span> The package</h4>
<div class="outline-text-4" id="text-3-8-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:hardware-descriptions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span>
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">:lol :util</span>
        <span style="color: #b22222;">;;</span><span style="color: #b22222;">:pathname </span>
        <span style="color: #483d8b;">:mcl-util</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-hdl</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:flatten</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:walk-tree</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:cl-fad</span> <span style="color: #483d8b;">:file-exists-p</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:save-hardware-description</span> <span style="color: #483d8b;">:get-hardware-description-by-name</span>
           <span style="color: #483d8b;">:get-parent-hardware-description</span>
           <span style="color: #483d8b;">:hardware-description-p</span>
           <span style="color: #483d8b;">:get-hardware-description-dir</span>
           <span style="color: #483d8b;">:get-executing-par-unit</span>
           <span style="color: #483d8b;">:block-with-types</span>
           <span style="color: #483d8b;">:block-with-type</span>
           <span style="color: #483d8b;">:block-with-name</span>
           <span style="color: #483d8b;">:property-with-name</span>
           <span style="color: #483d8b;">:get-nr-units</span>
           <span style="color: #483d8b;">:get-property-from-block</span>
           <span style="color: #483d8b;">:resolve</span>
           <span style="color: #483d8b;">:inherited-id</span>
           <span style="color: #483d8b;">:get-par-unit</span>
           <span style="color: #483d8b;">:get-default-memory-space</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org988cce1" class="outline-4">
<h4 id="org988cce1"><span class="section-number-4">3.8.2</span> Retrieving the hardware descriptions</h4>
<div class="outline-text-4" id="text-3-8-2">
<p>
The hardware descriptions are stored in a hash-table.  Since this is a library,
loading the hardware-descriptions is not possible.  Therefore, there is a
<code>save-hardware-description</code> that stores the hardware descriptions in the
hash-table. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*hardware-descriptions*</span> (make-hash-table <span style="color: #483d8b;">:test</span> 'equal))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">save-hardware-description</span> (name hwd)
  (setf (gethash name *hardware-descriptions*) hwd))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-hardware-description-by-name</span> (name)
  (gethash name *hardware-descriptions*))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">hardware-description-p</span> (id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">hardware-description-p</span> ((import ast-mcpl:lib-import))
  (hardware-description-p (ast-mcpl:id import)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">hardware-description-p</span> ((id ast-mcpl:id))
  (hardware-description-p (ast-mcpl:name id)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">hardware-description-p</span> ((ci ast-mcpl:compound-id))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">hardware-description-p</span> ((name-hwd string))
  (<span style="color: #a020f0;">let</span> ((hwd-dir (get-hardware-description-dir)))
    (file-exists-p (format nil <span style="color: #8b2252;">"~a/~a.hdl"</span> hwd-dir name-hwd))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-hardware-description-dir</span> ()
  (getenv <span style="color: #8b2252;">"HDL_DIR"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge0a0757" class="outline-4">
<h4 id="orge0a0757"><span class="section-number-4">3.8.3</span> Macros</h4>
<div class="outline-text-4" id="text-3-8-3">
<p>
The macro <code>with-hardware-description</code> is a convenience macro that ensures that
functions can be called with the hardware description itself, or a string with
the name of the hardware description that will automatically get the hardware
description.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-hardware-description</span> (hwd <span style="color: #228b22;">&amp;body</span> body)
  `(<span style="color: #a020f0;">let</span> ((,hwd (<span style="color: #a020f0;">cond</span> ((stringp ,hwd)
                    (aif (gethash ,hwd *hardware-descriptions*) 
                         it
                         (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a not loaded."</span> ,hwd)))
                   ((typep ,hwd 'hardware-description)
                    ,hwd)
                   (t
                    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a not a hardware description"</span> ,hwd)))))
    ,@body))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd00afdb" class="outline-4">
<h4 id="orgd00afdb"><span class="section-number-4">3.8.4</span> The device hierarchy</h4>
<div class="outline-text-4" id="text-3-8-4">
<p>
The types of devices defined in a hardware description are organized in a
hierarchy that is defined below.  We have added a function that retrieves the
all subtypes given a type.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*device-hierarchy*</span>
  '(<span style="color: #8b2252;">"device"</span>
    (<span style="color: #8b2252;">"device_group"</span> 
     <span style="color: #8b2252;">"device_unit"</span>
     (<span style="color: #8b2252;">"memory"</span> (<span style="color: #8b2252;">"cache"</span>))
     (<span style="color: #8b2252;">"execution_group"</span> (<span style="color: #8b2252;">"simd_group"</span> (<span style="color: #8b2252;">"load_store_group"</span>)))
     (<span style="color: #8b2252;">"execution_unit"</span> (<span style="color: #8b2252;">"simd_unit"</span>) (<span style="color: #8b2252;">"load_store_unit"</span>))
     <span style="color: #8b2252;">"interconnect"</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-device-types</span> (type)
  (<span style="color: #a020f0;">let</span> (result)
    (walk-tree *device-hierarchy* #'(<span style="color: #a020f0;">lambda</span> (x)
                                      (<span style="color: #a020f0;">when</span> (and (listp x)
                                                 (stringp (first x))
                                                 (string= (first x) type))
                                        (push x result))))
    (flatten result)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3cc675d" class="outline-4">
<h4 id="org3cc675d"><span class="section-number-4">3.8.5</span> Resolving names in hardware descriptions</h4>
<div class="outline-text-4" id="text-3-8-5">
<p>
The following function resolve expressions or statements in hardware
descriptions.
</p>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve</span> (expression-or-id-stat ast-hwd)
  (<span style="color: #483d8b;">:documentation</span>
   <span style="color: #8b2252;">"Resolve an identifier expression or statement in the AST of</span>
<span style="color: #8b2252;">hardware descriptions."</span>))
</pre>
</div>

<p>
The following methods just peel off until identifiers.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((expr unit-expr) ast-hwd)
  (resolve (expr expr) ast-hwd))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((id-expr id-expr) ast-hwd)
  (resolve (qual-id id-expr) ast-hwd))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((is id-stat) ast-hwd)
  (resolve (id is) ast-hwd))
</pre>
</div>

<p>
A compound statement is slightly more complicated as a compound id can refer to
an external (higher up in the hierarchy of hardware descriptions) hdl block.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((ci compound-id) ast-hwd)
  (<span style="color: #a020f0;">with-slots</span> (name compound) ci
    (aif (get-hardware-description-by-name (name name))
         (resolve compound it)
         (resolve compound (resolve name ast-hwd)))))
</pre>
</div>

<p>
Resolving an identifier in a hardware description is somewhat more involved
as one can refer to blocks directly (for example "cores.core") or using the
name of the hardware description (which is required to be a block in the
hardware description as well), for example "perfect.cores.core").  We solve
this by just trying both cases.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((id id) (hwd hardware-description))
  (or (resolve-with-function id hwd #'hdl-blocks)
      (resolve id (resolve (id hwd) hwd))))
</pre>
</div>

<p>
Resolving identifiers in a block searches for blocks in stats.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((id id) (b hdl-block))
  (resolve-with-function id b #'hdl-stats))
</pre>
</div>

<p>
The <code>resolve-with-function</code> searches for the specified block and verifies
whether there is only one of them.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:hardware-descriptions</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-with-function</span> (id ast-hwd function)
  (<span style="color: #a020f0;">let</span> ((result (<span style="color: #a020f0;">loop</span> for b in (funcall function ast-hwd)
                   when (or (and (typep b 'hdl-block)
                                 (ast= id (id b)))
                            (and (typep b 'property)
                                 (string= (name id) (property-type b))))
                   collect b)))
    (<span style="color: #a020f0;">if</span> (&gt; (length result) 1)
        (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"More than one result."</span>)
        (first result))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org52d505f" class="outline-4">
<h4 id="org52d505f"><span class="section-number-4">3.8.6</span> Predicate functions for collect and retrieve</h4>
<div class="outline-text-4" id="text-3-8-6">
<p>
The following functions return closures that can be used as input to the
functions <code>collect</code> and <code>retrieve</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">block-with-types</span> (types)
  #'(<span style="color: #a020f0;">lambda</span> (ast-hwd)
      (and (typep ast-hwd 'hdl-block)
           (member (hdl-block-type ast-hwd) types <span style="color: #483d8b;">:test</span> #'string=))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">block-with-type</span> (type)
  #'(<span style="color: #a020f0;">lambda</span> (ast-hwd)
      (and (typep ast-hwd 'hdl-block)
           (string= (hdl-block-type ast-hwd) type))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">property-with-name</span> (name)
  #'(<span style="color: #a020f0;">lambda</span> (ast-hwd)
      (and (typep ast-hwd 'property)
           (string= name (property-type ast-hwd)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">block-with-name</span> (name)
  #'(<span style="color: #a020f0;">lambda</span> (ast-hwd)
      (and (typep ast-hwd 'hdl-block)
           (string= name (name (id ast-hwd))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org670f0c9" class="outline-4">
<h4 id="org670f0c9"><span class="section-number-4">3.8.7</span> Generic query functions for hardware descriptions</h4>
<div class="outline-text-4" id="text-3-8-7">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-parent-hardware-description</span> (hwd)
  <span style="color: #8b2252;">"Returns the name of the parent hardware description."</span>
  (with-hardware-description hwd
    (<span style="color: #a020f0;">let</span> ((identifier (specializes hwd)))
      (<span style="color: #a020f0;">if</span> (null identifier) nil (name identifier)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-blocks-of-type</span> (ast-hwd type)
  <span style="color: #8b2252;">"Retrieve all blocks from an AST form ast-hwd of type type."</span>
  (<span style="color: #a020f0;">let</span> ((types (get-device-types type)))
    (pushnew type types <span style="color: #483d8b;">:test</span> #'string=)
    (collect-all ast-hwd (block-with-types types))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:hardware-descriptions</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-executing-par-unit</span> (hwd)
  <span style="color: #8b2252;">"Get the name of the executing unit of parallelism from hardware description</span>
<span style="color: #8b2252;">hwd."</span>
  (with-hardware-description hwd
    (<span style="color: #a020f0;">let*</span> ((executing_unit
            (parent (first (get-blocks-of-type hwd <span style="color: #8b2252;">"instructions"</span>))))
           (slot-property
            (first (collect-all executing_unit (property-with-name <span style="color: #8b2252;">"slots"</span>)))))
      (name (qual-id (expr (first (exprs slot-property))))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-nr-units</span> (a-block <span style="color: #228b22;">&amp;optional</span> prefix)
  <span style="color: #8b2252;">"Get the number of units from block a-block."</span>
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (or (null prefix) (string= prefix <span style="color: #8b2252;">"max"</span>)))
  (<span style="color: #a020f0;">let</span> ((property-name (<span style="color: #a020f0;">if</span> prefix
                           (format nil <span style="color: #8b2252;">"~a_nr_units"</span> prefix)
                           <span style="color: #8b2252;">"nr_units"</span>)))
    (aif (get-property-from-block a-block property-name)
         it
         (<span style="color: #a020f0;">if</span> (not prefix)
             (get-nr-units a-block <span style="color: #8b2252;">"max"</span>)
             nil))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:hardware-descriptions</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-property-from-block</span> (a-block property-name)
     <span style="color: #8b2252;">"Get the value of a property with name property-name from block a-block."</span>
     (<span style="color: #a020f0;">let</span> ((property (retrieve a-block (property-with-name property-name))))
       (<span style="color: #a020f0;">if</span> property
           (<span style="color: #a020f0;">let</span> ((exprs (exprs property)))
             (<span style="color: #a020f0;">if</span> (&gt; (length exprs) 1) exprs (first exprs)))
           nil)))
</pre>
</div>

<p>
The following function checks whether an identifier is an inherited identifier,
which means that it originates from another hardware description.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">inherited-id</span> (id)
  (<span style="color: #483d8b;">:documentation</span>
   <span style="color: #8b2252;">"Whether the id is an inherited id (from another hardware description)."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">inherited-id</span> ((id-stat id-stat))
  (inherited-id (id id-stat)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">inherited-id</span> ((id id))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">inherited-id</span> ((ci compound-id))
  (get-hardware-description-by-name (name (name ci))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-par-unit</span> (par-group hardware-description)
  <span style="color: #8b2252;">"Get the parallelism unit from a par-group given a hardware-description."</span>
  (with-hardware-description hardware-description
    (retrieve
     (retrieve-all hardware-description (block-with-name par-group))
     (block-with-type <span style="color: #8b2252;">"par_unit"</span>))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-default-memory-space</span> (hardware-description parallelism-level)
  <span style="color: #8b2252;">"Return the default memory space of parallelism-level."</span>
  (with-hardware-description hardware-description
    (<span style="color: #a020f0;">let*</span> ((hdl-block (retrieve-all hardware-description
                                (<span style="color: #a020f0;">if</span> (string= parallelism-level <span style="color: #8b2252;">"parallelism"</span>)
                                    (block-with-type <span style="color: #8b2252;">"parallelism"</span>)
                                    (block-with-name parallelism-level))))
           (memory-spaces (collect hdl-block (block-with-type <span style="color: #8b2252;">"memory_space"</span>)))
           (result (remove-if (complement #'(<span style="color: #a020f0;">lambda</span> (x)
                                              (retrieve x (property-with-name <span style="color: #8b2252;">"default"</span>))))
                              memory-spaces)))
      (<span style="color: #a020f0;">cond</span> ((eql (length result) 1)
             (first result))
            ((null result)
             nil)
            (t
             (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"More than one default memory spaces."</span>))))))




</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org477d0b7" class="outline-3">
<h3 id="org477d0b7"><span class="section-number-3">3.9</span> Querying HDL and MCPL</h3>
<div class="outline-text-3" id="text-3-9">
</div>
<div id="outline-container-orgae41d5d" class="outline-4">
<h4 id="orgae41d5d"><span class="section-number-4">3.9.1</span> The package</h4>
<div class="outline-text-4" id="text-3-9-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:query-hdl-mcpl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #b22222;">;;</span><span style="color: #b22222;">:alexandria :lol :util</span>
        <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:ast-hdl</span>
        <span style="color: #483d8b;">:hardware-descriptions</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:compose</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:get-parallelism-level</span> 
           <span style="color: #483d8b;">:get-hardware-description</span>
           <span style="color: #483d8b;">:get-memory-spaces</span>
           <span style="color: #483d8b;">:resolve-hardware-description-var</span>
           <span style="color: #483d8b;">:hardware-description-var-p</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:id</span> <span style="color: #483d8b;">:compound-id</span> <span style="color: #483d8b;">:left</span> <span style="color: #483d8b;">:make-mul</span> <span style="color: #483d8b;">:make-add</span>
                          <span style="color: #483d8b;">:expr</span> <span style="color: #483d8b;">:make-div</span> <span style="color: #483d8b;">:right</span> <span style="color: #483d8b;">:sub</span> <span style="color: #483d8b;">:add</span> <span style="color: #483d8b;">:div</span> <span style="color: #483d8b;">:make-sub</span>
                          <span style="color: #483d8b;">:make-id</span> <span style="color: #483d8b;">:make-compound-id</span> <span style="color: #483d8b;">:mul</span> <span style="color: #483d8b;">:name</span> <span style="color: #483d8b;">:compound</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:flatten</span>))


</pre>
</div>
</div>
</div>


<div id="outline-container-org4d14a02" class="outline-4">
<h4 id="org4d14a02"><span class="section-number-4">3.9.2</span> The functionality</h4>
<div class="outline-text-4" id="text-3-9-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-parallelism-level</span> (ast)
  <span style="color: #8b2252;">"Get the parallelism level of an AST form."</span>
  (get-parallelism-level2 (parent ast)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-parallelism-level2</span> (ast)
  (<span style="color: #a020f0;">cond</span> ((null ast) <span style="color: #8b2252;">"parallelism"</span>)
        ((typep ast 'foreach-stat)
         (ast-hdl:name (ast-hdl:id
                        (get-par-unit (name (par-group ast))
                                      (get-hardware-description ast)))))
        ((typep ast 'func)
         (get-parallelism-level-func ast))
        (t (get-parallelism-level2 (parent ast)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-parallelism-level-func</span> (func)
  (aif (called-by func)
       (get-lowest-parallelism-level it)
       (get-parallelism-level2 (parent func))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-lowest-parallelism-level</span> (calls)
  (get-parallelism-level
   (reduce #'(<span style="color: #a020f0;">lambda</span> (r c) (<span style="color: #a020f0;">if</span> (parallelism-level&lt; r c) r c)) calls)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parallelism-level&lt;</span> (ast1 ast2)
  (<span style="color: #a020f0;">let*</span> ((hwd1 (get-hardware-description ast1))
         (hwd2 (get-hardware-description ast2))
         (par-units
          (cons <span style="color: #8b2252;">"parallelism"</span>
                (mapcar (compose #'ast-hdl:name #'ast-hdl:id)
                        (sort (collect-all hwd1 (block-with-type <span style="color: #8b2252;">"par_unit"</span>))
                              #'ast&lt;)))))
    (<span style="color: #ff0000; font-weight: bold;">assert</span> (eq hwd1 hwd2))
    (&lt; (get-position ast1 par-units) (get-position ast2 par-units))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-position</span> (ast par-units)
  (position (get-parallelism-level ast) par-units <span style="color: #483d8b;">:test</span> #'string=))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-hardware-description</span> (form)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the hardware description of form form."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-hardware-description</span> ((s string))
  (get-hardware-description-by-name s))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-hardware-description</span> ((ast ast))
  (get-hardware-description (get-func ast)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-hardware-description</span> ((func func))
  (get-hardware-description (hw-desc func)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-hardware-description</span> ((id id))
  (get-hardware-description (name id)))
</pre>
</div>

<p>
The following method returns a string as it will not be clear if an
<code>ast-mcpl:id</code> or <code>ast-hdl:id</code> will be returned.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-memory-spaces</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the memory space of an AST-form"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-memory-spaces</span> ((decl decl))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (not (memory-space-disallowed decl)))
  (aif (get-memory-spaces-modifier decl)
       (mapcar #'name it)
       (list (ast-hdl:name
              (ast-hdl:id
               (get-default-memory-space (get-hardware-description decl)
                                         (get-parallelism-level decl)))))))


</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">hardware-description-var-p</span> (var)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether var is a hardware description variable."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">hardware-description-var-p</span> ((var dot-var))
  (get-hardware-description (id (basic-var var))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve-hardware-description-var</span> (var)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Resolve a hardware description variable."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve-hardware-description-var</span> ((var dot-var))
  (<span style="color: #a020f0;">let</span> ((hwd (get-hardware-description (id (basic-var var)))))
    (hdl-expr-&gt;mcpl-expr (first (exprs (resolve (mcpl-var-&gt;hdl-var var) hwd))))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">mcpl-var-&gt;hdl-var</span> (var)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Convert an MCPL variable to an HDL variable."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mcpl-var-&gt;hdl-var</span> ((dv dot-var))
  (ast-hdl:make-compound-id (ast-hdl:make-id (name (id (basic-var dv))))
                            (mcpl-var-&gt;hdl-var (var dv))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mcpl-var-&gt;hdl-var</span> ((nv normal-var))
  (mcpl-var-&gt;hdl-var (basic-var nv)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">mcpl-var-&gt;hdl-var</span> ((bv basic-var))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (null (array-exprs bv)))
  (ast-hdl:make-id (name (id bv))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">hdl-expr-&gt;mcpl-expr</span> (hdl-expr)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Convert an HDL expression to an MCPL expression."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">hdl-expr-&gt;mcpl-expr</span> ((unit-expr unit-expr))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (null (unit unit-expr)))
  (hdl-expr-&gt;mcpl-expr (ast-hdl:expr unit-expr)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">hdl-expr-&gt;mcpl-expr</span> ((int-literal int-literal))
  (<span style="color: #a020f0;">with-slots</span> (value location) int-literal
    (make-int-constant value location)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga6638df" class="outline-3">
<h3 id="orga6638df"><span class="section-number-3">3.10</span> The pass library</h3>
<div class="outline-text-3" id="text-3-10">
<p>
This library contains all the functionality to define passes.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org6e55cbb">3.10.1. The package</a></li>
<li><a href="#org7943c38">3.10.2. The functionality</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6e55cbb" class="outline-4">
<h4 id="org6e55cbb"><span class="section-number-4">3.10.1</span> The package</h4>
<div class="outline-text-4" id="text-3-10-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:pass-library</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-log</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:cl-graph-extension</span> <span style="color: #483d8b;">:simple-sets</span>
        <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>
        <span style="color: #483d8b;">:check-consistency-ast</span> <span style="color: #483d8b;">:logging</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:cl-strings</span> <span style="color: #483d8b;">:replace-all</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:pass-data</span> <span style="color: #483d8b;">:modules</span> <span style="color: #483d8b;">:exports</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:root-directory</span>
           <span style="color: #483d8b;">:defpass</span> <span style="color: #483d8b;">:run-pass</span> <span style="color: #483d8b;">:enable-pass</span>
           <span style="color: #483d8b;">:get-key</span> <span style="color: #483d8b;">:get-key-from-filename</span>
           <span style="color: #483d8b;">:resolve-exports</span>
           <span style="color: #483d8b;">:domodules</span>)
  (<span style="color: #483d8b;">:shadow</span> <span style="color: #483d8b;">:exports</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7943c38" class="outline-4">
<h4 id="org7943c38"><span class="section-number-4">3.10.2</span> The functionality</h4>
<div class="outline-text-4" id="text-3-10-2">
<p>
First, the pass library defines a datastructure <code>pass-data</code> that holds all
kinds of data to perform all passes.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">pass-data</span> ()
  ((modules <span style="color: #483d8b;">:initform</span> (make-hash-table <span style="color: #483d8b;">:test</span> 'equal) <span style="color: #483d8b;">:accessor</span> modules)
   (callgraph <span style="color: #483d8b;">:initform</span> nil <span style="color: #483d8b;">:accessor</span> callgraph)
   (exports <span style="color: #483d8b;">:initform</span> (make-hash-table <span style="color: #483d8b;">:test</span> 'equal) <span style="color: #483d8b;">:accessor</span> exports)
   (root-directory <span style="color: #483d8b;">:initform</span> nil <span style="color: #483d8b;">:accessor</span> root-directory)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-pass-data</span> ()
  (make-instance 'pass-data))
</pre>
</div>

<p>
This package allows one to define a pass with the following macro:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defpass</span> (name <span style="color: #228b22;">&amp;body</span> properties)
  (check-properties properties)
  (<span style="color: #a020f0;">let</span> ((instructions 
         (<span style="color: #a020f0;">loop</span> for (type . args) in properties
            append (<span style="color: #a020f0;">case</span> type
                     (<span style="color: #483d8b;">:dependencies</span>
                      (add-dependencies '*pass-graph* name args))
                     (<span style="color: #483d8b;">:options</span>
                      (add-dependencies '*options-graph* name args))
                     (<span style="color: #483d8b;">:at-most-one</span>
                      (add-dependencies '*at-most-one-graph* name args))))))
    (push `(export ',name) instructions)
    (push `(add-vertex *pass-graph* ',name) instructions)
    `(<span style="color: #a020f0;">progn</span> ,@instructions)))
</pre>
</div>

<p>
It has three types of properties: <code>:dependencies</code>, passes on which it depends;
<code>:options</code>, optional passes that can be run together with this pass; and
<code>:at-most-one</code>, which contains lists of passes of which only one should be
chosen.  The function <code>check-properties</code> verifies whether everything is in
order.
</p>

<p>
An example use of the <code>defpass</code> macro is:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defpass generate-code
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis)
  (<span style="color: #483d8b;">:at-most-one</span> (choose-first-option choose-all-options))
  (<span style="color: #483d8b;">:options</span> with-measurement))


</pre>
</div>

<p>
The <code>generate-code</code> pass depends on <code>semantic-analysis</code>, must use at most one
out of <code>choose-first-option</code> or <code>choose-all-options</code> and it is possible to turn
the optional pass <code>with-measurement</code> on.
</p>


<p>
The following is a convenience macro:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">domodules</span> ((var modules) <span style="color: #228b22;">&amp;body</span> body)
  `(<span style="color: #a020f0;">loop</span> for ,var being the hash-values in ,modules
      do ,@body))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-properties</span> (properties)
  (<span style="color: #a020f0;">let</span> ((allowed-properties '(<span style="color: #483d8b;">:dependencies</span> <span style="color: #483d8b;">:options</span> <span style="color: #483d8b;">:at-most-one</span>)))
    (<span style="color: #a020f0;">loop</span> for p in properties
       do (<span style="color: #a020f0;">when</span> (not
                 (and (typep p 'list)
                      (member (car p) allowed-properties)))
            (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Expecting one of ~a"</span> allowed-properties)))))
</pre>
</div>

<p>
The function <code>add-dependencies</code> adds all passes to several graphs:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*pass-graph*</span> (make-directed-graph))
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*options-graph*</span> (make-directed-graph))
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*at-most-one-graph*</span> (make-directed-graph))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-dependencies</span> (graph vertex-from vertices-to)
  (<span style="color: #a020f0;">loop</span> for v-to in vertices-to
     collect `(add-edge-between-vertexes ,graph ',vertex-from ',v-to)))
</pre>
</div>

<p>
The function <code>run-pass</code> runs a pass with several options.  It is defined in a
closure to allow the function <code>enable-pass</code> to set optional passes for the pass
to run.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-graph-initialized</span> (graph <span style="color: #228b22;">&amp;body</span> body)
  `(<span style="color: #a020f0;">progn</span>
     (<span style="color: #a020f0;">when</span> (null ,graph)
       (setf ,graph (make-directed-graph)))
     ,@body))

(<span style="color: #a020f0;">let</span> ((graph nil))
  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reset</span> ()
    (setf graph nil))
  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">run-pass</span> (pass options)
    (initialize-logging)
    (with-graph-initialized graph
      <span style="color: #b22222;">;;</span><span style="color: #b22222;">(handler-case)</span>
      (<span style="color: #a020f0;">progn</span>
        (add-graph graph *pass-graph*)
        (<span style="color: #a020f0;">let</span> ((closure (closure graph (list pass))))
          (check-at-most-one closure)
          (<span style="color: #a020f0;">let</span> ((result (run-passes
                         (mapcar #'element
                                 (reverse
                                  (topological-sort closure)))
                         options)))
            (setf graph nil)
            result)))
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">(pass-error (e) (progn</span>
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">              (setf graph nil)</span>
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">              (error "~a" (text e))))</span>
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">(mcl-error (e) (progn</span>
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">              (report-mcpl-error e)</span>
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">              (error  "~a" (text e))))</span>

      ))


  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">enable-pass</span> (pass pass-to-be-enabled)
    (with-graph-initialized graph
      (<span style="color: #a020f0;">let</span> ((possible-passes (append (get-children *options-graph* pass)
                                      (get-at-most-one-options pass))))
        (<span style="color: #a020f0;">if</span> (member pass-to-be-enabled possible-passes)
            (add-edge-between-vertexes graph pass pass-to-be-enabled)
            (<span style="color: #ff0000; font-weight: bold;">error</span> 'pass-error <span style="color: #8b2252;">"pass ~a cannot be enabled for pass ~a"</span>
                   pass-to-be-enabled pass))
        nil))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visualize-dependency-graph</span> (graph)
  (graph-&gt;dot graph <span style="color: #8b2252;">"passes.dot"</span> <span style="color: #483d8b;">:edge-labeler</span> nil
              <span style="color: #483d8b;">:vertex-formatter</span> #'format-vertex
              <span style="color: #483d8b;">:vertex-labeler</span> #'format-vertex-label))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">format-vertex</span> (vertex stream)
  (<span style="color: #a020f0;">declare</span> (ignore vertex))
  (format stream <span style="color: #8b2252;">""</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">format-vertex-label</span> (vertex stream)
  (format stream <span style="color: #8b2252;">"~a"</span> vertex))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">report-mcpl-error</span> (e)
  (<span style="color: #a020f0;">with-slots</span> (text loc) e
    (<span style="color: #a020f0;">destructuring-bind</span> ((line . column) file) loc
      #+swank
      (swank:eval-in-emacs
       `(<span style="color: #a020f0;">progn</span>
          (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-position</span> (line column)
            (save-excursion
              (goto-line line)
              (move-to-column column)
              (point)))
          (find-file ,file)
          (<span style="color: #a020f0;">let*</span> ((position (find-position ,line ,column))
                 (overlay (make-overlay position (+ position 5))))
            (overlay-put overlay 'face '(<span style="color: #483d8b;">:underline</span> t))
            (overlay-put overlay 'help-echo ,text))
          (goto-line ,line)
          (move-to-column ,column)))
      #-swank
      (<span style="color: #a020f0;">progn</span>
        (format t <span style="color: #8b2252;">"~a~%"</span> e)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-children</span> (graph vertex)
  (<span style="color: #a020f0;">let</span> ((vertex (find-vertex graph vertex nil)))
    (<span style="color: #a020f0;">if</span> vertex
        (mapcar #'element (child-vertexes vertex))
        nil)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-graph</span> (result-graph graph)
  (<span style="color: #a020f0;">dolist</span> (v (vertexes graph))
    (add-vertex result-graph (element v)))
  (<span style="color: #a020f0;">dolist</span> (e (edges graph))
    (add-edge-between-vertexes result-graph
                               (element (vertex-1 e))
                               (element (vertex-2 e)))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-at-most-one-options</span> (pass)
  (<span style="color: #a020f0;">loop</span> for c in (get-children *at-most-one-graph* pass)
     appending c))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">run-passes</span> (passes options)
  (<span style="color: #a020f0;">let</span> ((pass-data (make-pass-data)))
    (<span style="color: #a020f0;">loop</span> for p in passes
       for r = (<span style="color: #a020f0;">progn</span>
                 (log-message <span style="color: #483d8b;">:pass</span> <span style="color: #8b2252;">"Running pass ~a~%"</span> p)
                 (funcall (intern (format nil <span style="color: #8b2252;">"DO-~a"</span> p) <span style="color: #483d8b;">:passes</span>)
                          pass-data
                          (cdr (assoc p options))))
       do (check-consistency pass-data)
         <span style="color: #b22222;">;; </span><span style="color: #b22222;">(loop for m being the hash-values in (modules pass-data)</span>
         <span style="color: #b22222;">;;      </span><span style="color: #b22222;">do (format t (print-pretty:pp m)))</span>
       finally (<span style="color: #a020f0;">return</span> r))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-consistency</span> (pass-data)
  (<span style="color: #a020f0;">loop</span> for m being the hash-values in (modules pass-data)
       do (check-consistency-ast m)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-at-most-one</span> (graph)
  (<span style="color: #a020f0;">let</span> ((passes (mapcar #'element (vertexes graph))))
    (<span style="color: #a020f0;">loop</span> for p in passes do (check-at-most-one-pass p passes))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-at-most-one-pass</span> (pass all-passes)
  (<span style="color: #a020f0;">let</span> ((at-most-specs (get-children *at-most-one-graph* pass)))
    (<span style="color: #a020f0;">loop</span> for spec in at-most-specs
       do
         (<span style="color: #a020f0;">let</span> ((enabled-passes (cl:intersection spec all-passes)))
           (<span style="color: #a020f0;">when</span> (not (eql (length enabled-passes) 1))
             (pass-error nil <span style="color: #8b2252;">"Need one of ~a for ~a, enabled now: ~a"</span>
                         spec pass enabled-passes))))))
</pre>
</div>


<p>
The following functions resolve identifiers in exports:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve-exports</span> (imports-module id exports)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Given the imports from a module, resolve identifier in the</span>
<span style="color: #8b2252;"> exports data structure"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve-exports</span> (imports-module (id id) exports)
  (<span style="color: #a020f0;">let</span> ((result (make-set <span style="color: #483d8b;">:test</span> #'ast=)))
    (<span style="color: #a020f0;">dolist</span> (i imports-module)
      (<span style="color: #a020f0;">let</span> ((exported-ids (gethash (get-key i) exports)))
        (<span style="color: #a020f0;">when</span> exported-ids
          (setf result (union result (subscribe-rel id exported-ids))))))
    (<span style="color: #a020f0;">cond</span> ((empty-set-p result)
           nil)
          ((eql (size-set result) 1)
           (get-element-set result))
          (t       
           (export-error (location id) <span style="color: #8b2252;">"~a not uniquely exported"</span> (name id))))))
</pre>
</div>


<p>
The function <code>get-key</code> computes a unique identifier of module based on the
package and the module-name:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-key</span> (ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-key</span> ((module module))
  (<span style="color: #a020f0;">with-slots</span> (id pkg) module
    (format nil <span style="color: #8b2252;">"~a/~a"</span> (get-key pkg) (get-key id))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-key</span> ((id id))
  (format nil <span style="color: #8b2252;">"~a"</span> (name id)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-key</span> ((ci compound-id))
  (<span style="color: #a020f0;">with-slots</span> (name compound) ci
    (format nil <span style="color: #8b2252;">"~a/~a"</span> name (get-key compound))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-key</span> ((i lib-import))
  (get-key (id i)))
</pre>
</div>

<p>
Likewise, it is possible to retrieve the key from a filename, given pass-data:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-key-from-filename</span> (filename pass-data)
  (<span style="color: #a020f0;">let</span> ((root-name (namestring (root-directory pass-data))))
    (<span style="color: #a020f0;">if</span> (string= root-name <span style="color: #8b2252;">""</span>)
        (remove-extension filename)
        (remove-extension (replace-all filename root-name <span style="color: #8b2252;">""</span>)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-extension</span> (filename)
  (subseq filename 0 (- (length filename) 4)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org11721d6" class="outline-3">
<h3 id="org11721d6"><span class="section-number-3">3.11</span> Check consistency AST</h3>
<div class="outline-text-3" id="text-3-11">
</div>
<div id="outline-container-org60a8cd2" class="outline-4">
<h4 id="org60a8cd2"><span class="section-number-4">3.11.1</span> The package</h4>
<div class="outline-text-4" id="text-3-11-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:check-consistency-ast</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-log</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:query-hdl-mcpl</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:def-methods</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:check-consistency-ast</span>
           <span style="color: #483d8b;">:check-parents-child-consistency</span>
           <span style="color: #483d8b;">:check-decls-vars-consistency</span>
           <span style="color: #483d8b;">:check-funcs-calls-consistency</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1af4e2f" class="outline-4">
<h4 id="org1af4e2f"><span class="section-number-4">3.11.2</span> The functionality</h4>
<div class="outline-text-4" id="text-3-11-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-consistency-ast</span> (module)
  (log-message <span style="color: #483d8b;">:check-consistency</span> <span style="color: #8b2252;">"Checking consistency"</span>)
  (check-parents-child-consistency module)
  (check-decls-vars-consistency module)
  (check-funcs-calls-consistency module)
  module)
</pre>
</div>
</div>

<div id="outline-container-org96ad623" class="outline-5">
<h5 id="org96ad623"><span class="section-number-5">3.11.2.1</span> Checking parents/child relationship</h5>
<div class="outline-text-5" id="text-3-11-2-1">
<p>
The following functions check the parent/child relationship.  Modules are
supposed to not have a parent.  Each other AST-form should have a parent that
points to child.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-parents-child-consistency</span> (ast)
  (log-message <span style="color: #483d8b;">:check-consistency-part</span> <span style="color: #8b2252;">"Checking parents-child-relationship"</span>)
  (visit ast #'check-parents-child-fw #'check-parents-child-bw))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-parents-child-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-parents-child-bw</span> (ast))

(defvisitor check-parents-child-fw ast (list string symbol number)
  t)
(defvisitor check-parents-child-bw ast (ast list string symbol number)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-parents-child-fw</span> ((module module))
  (<span style="color: #a020f0;">when</span> (not (null (parent module)))
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"The parent of module ~a is not nil."</span> module))
  (check-children module)
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-parents-child-fw</span> ((ast ast))
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(when (and (typep ast 'call)</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">        (string= (name (id ast)) "mcl_builtin_transfer_from_device"))</span>
  <span style="color: #b22222;">;;   </span><span style="color: #b22222;">(format t "yep~%"))</span>
  (check-parent ast)
  (check-children ast)
  t)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-parent</span> (ast)
  (<span style="color: #a020f0;">with-slots</span> (parent) ast
    (<span style="color: #a020f0;">if</span> (null parent)
        (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"AST ~a does not have a parent."</span> ast)
        (<span style="color: #a020f0;">when</span> (not (has-as-child-p parent ast))
          (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"AST ~a has ~a as parent, but the parent does not have it </span>
<span style="color: #8b2252;">as child"</span> ast parent)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-children</span> (ast)
  (<span style="color: #a020f0;">dolist</span> (child (children ast))
    (check-child child ast)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-child</span> (child parent))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-child</span> ((child ast) parent)
  (<span style="color: #a020f0;">when</span> (not (eq (parent child) parent))
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"AST ~a has ~a as child, but the child does not have it as parent"</span>
           parent child)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-child</span> ((l list) parent)
  (<span style="color: #a020f0;">dolist</span> (e l)
    (check-child e parent)))

(def-methods check-child ((ast (string symbol number)) parent)
  t)

</pre>
</div>
</div>
</div>

<div id="outline-container-org104afa8" class="outline-5">
<h5 id="org104afa8"><span class="section-number-5">3.11.2.2</span> Checking decls/vars relationship</h5>
<div class="outline-text-5" id="text-3-11-2-2">
<p>
The following pass visits the AST and reacts to basic declarations, normal
variables and dot-variables.  In the latter case, the visit does not continue
if it is a hardware variable.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-decls-vars-consistency</span> (ast)
  (log-message <span style="color: #483d8b;">:check-consistency-part</span> <span style="color: #8b2252;">"Checking decls-vars-relationship"</span>)
  (visit ast #'check-decls-vars-fw #'check-decls-vars-bw)
  ast)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-decls-vars-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-decls-vars-bw</span> (ast))

(defvisitor check-decls-vars-fw ast (ast list string symbol number)
  t)

(defvisitor check-decls-vars-bw ast (ast list string symbol number)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-decls-vars-fw</span> ((bd basic-decl))
  (check-decl-basic-decl bd)
  (check-vars-basic-decl bd))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-decls-vars-fw</span> ((v normal-var))
  (check-basic-var (basic-var v)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-decls-vars-fw</span> ((dv dot-var))
  (<span style="color: #a020f0;">if</span> (not (hardware-description-var-p dv))
      (<span style="color: #a020f0;">progn</span>
        (check-basic-var (basic-var dv))
        t)
      nil))
</pre>
</div>

<p>
For basic declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-decl-basic-decl</span> (bd)
  (<span style="color: #a020f0;">with-slots</span> (id decl) bd
    (<span style="color: #a020f0;">if</span> decl
        (check-decl-has-bd decl bd)
        (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"basic-decl ~a has no decl"</span> (name id)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-decl-has-bd</span> (decl bd)
  (<span style="color: #a020f0;">with-slots</span> (id location) bd
    (<span style="color: #a020f0;">unless</span> (<span style="color: #a020f0;">loop</span> for bd2 in (get-basic-decls decl)
               thereis (eq bd bd2))
      (error-message <span style="color: #8b2252;">"basic-decl"</span> (name id) <span style="color: #8b2252;">"decl"</span> (name (get-id decl))
                     location))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-vars-basic-decl</span> (bd)
  (<span style="color: #a020f0;">with-slots</span> ((id-bd id) id vars location) bd
    (<span style="color: #a020f0;">dolist</span> (v vars)
      (<span style="color: #a020f0;">with-slots</span> ((id-v id) basic-decl) (basic-var v)
        (check bd basic-decl
               <span style="color: #8b2252;">"basic-decl"</span> (name id-bd) <span style="color: #8b2252;">"var"</span> (name id-v) location)))))
</pre>
</div>

<p>
For basic vars:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-basic-var</span> (bv)
  (<span style="color: #a020f0;">with-slots</span> ((id-var id) basic-decl location) bv
    (<span style="color: #a020f0;">if</span> basic-decl
        (<span style="color: #a020f0;">with-slots</span> ((id-basic-decl id) vars) basic-decl
          (<span style="color: #a020f0;">when</span> (not (member (parent bv) vars))
            (check bv basic-decl <span style="color: #8b2252;">"basic-var"</span> (name id-var) <span style="color: #8b2252;">"basic-decl"</span>
                   (name id-basic-decl) location)))
        (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"basic-var ~a has no basic-decl"</span> (name id-var)))))
</pre>
</div>

<p>
The following function is a generic function that reports an error:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check</span> (ast1 ast2 type-ast1 name-ast1 type-ast2 name-ast2 location)
  (<span style="color: #a020f0;">when</span> (not (eq ast1 ast2))
    (error-message type-ast1 name-ast1 type-ast2 name-ast2 location)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">error-message</span> (type-ast1 name-ast1 type-ast2 name-ast2 location)
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a ~a points to ~a ~a, but ~a does not point to ~a at ~a"</span>
         type-ast1 name-ast1 type-ast2 name-ast2 name-ast2 name-ast1
         location))
</pre>
</div>
</div>
</div>

<div id="outline-container-org19821db" class="outline-5">
<h5 id="org19821db"><span class="section-number-5">3.11.2.3</span> Checking the function/call relationship</h5>
<div class="outline-text-5" id="text-3-11-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-funcs-calls-consistency</span> (ast)
  (log-message <span style="color: #483d8b;">:check-consistency-part</span> <span style="color: #8b2252;">"Checking funcs-calls-relationship"</span>)
  (visit ast #'check-funcs-calls-fw #'check-funcs-calls-bw)
  ast)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-funcs-calls-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-funcs-calls-bw</span> (ast))

(defvisitor check-funcs-calls-fw ast (ast list string symbol number)
  t)

(defvisitor check-funcs-calls-bw ast (ast list string symbol number)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-funcs-calls-fw</span> ((f func))
  (<span style="color: #a020f0;">with-slots</span> (called-by (id-f id) location) f
    (<span style="color: #a020f0;">dolist</span> (c called-by)
      (<span style="color: #a020f0;">with-slots</span> (func (id-c id)) c
        (check f func <span style="color: #8b2252;">"function"</span> (name id-f) <span style="color: #8b2252;">"call"</span> (name id-c) location))))
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-funcs-calls-fw</span> ((c call))
  (<span style="color: #a020f0;">unless</span> (builtin-func-p c)
    (<span style="color: #a020f0;">with-slots</span> (func (id-c id) location) c
      (<span style="color: #a020f0;">if</span> (null func)
          (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Call ~a does not have an associated func."</span> (name id-c))
          (<span style="color: #a020f0;">with-slots</span> (called-by (id-f id)) func
            (<span style="color: #a020f0;">when</span> (not (member c called-by))
              (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Call ~a is associated with func ~a, but the func does not know about it."</span>
                     (name id-c) (name id-f)))))))
  t)
</pre>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-orgdfd5884" class="outline-3">
<h3 id="orgdfd5884"><span class="section-number-3">3.12</span> Logging</h3>
<div class="outline-text-3" id="text-3-12">
</div>
<div id="outline-container-org9dfe608" class="outline-4">
<h4 id="org9dfe608"><span class="section-number-4">3.12.1</span> The package</h4>
<div class="outline-text-4" id="text-3-12-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:logging</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-log</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:dbg</span> <span style="color: #483d8b;">:initialize-logging</span> <span style="color: #483d8b;">:log-micro-pass</span> <span style="color: #483d8b;">:set-level</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2419a8f" class="outline-4">
<h4 id="org2419a8f"><span class="section-number-4">3.12.2</span> The functionality</h4>
<div class="outline-text-4" id="text-3-12-2">
</div>

<div id="outline-container-orgd264098" class="outline-5">
<h5 id="orgd264098"><span class="section-number-5">3.12.2.1</span> External functions</h5>
<div class="outline-text-5" id="text-3-12-2-1">
<p>
The following function initializes the logging.  It creates a log manager,
starts a messenger, and sets the time to zero.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defvar</span> <span style="color: #a0522d;">*logging-initialized*</span> nil)
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*levels*</span> (make-array 10 <span style="color: #483d8b;">:initial-element</span> nil <span style="color: #483d8b;">:adjustable</span> t <span style="color: #483d8b;">:fill-pointer</span> 0))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">initialize-logging</span> ()
  (<span style="color: #a020f0;">unless</span> *logging-initialized*
    (setf (log-manager)
          (make-instance 'log-manager <span style="color: #483d8b;">:message-class</span> 'indented-message))
    (start-messenger 'text-stream-messenger <span style="color: #483d8b;">:stream</span> t <span style="color: #483d8b;">:filter</span> <span style="color: #483d8b;">:log-level</span>)
    (setf *logging-initialized* t)
    (set-level-category <span style="color: #483d8b;">:debug</span> 1)
    (set-level-category <span style="color: #483d8b;">:pass</span> 1)
    (set-level-category <span style="color: #483d8b;">:micro-pass</span> 2)
    (set-level-category <span style="color: #483d8b;">:translate</span> 2)
    (set-level-category <span style="color: #483d8b;">:check-consistency</span> 2)
    (set-level-category <span style="color: #483d8b;">:check-consistency-part</span> 3)
    (set-level 1))
  (setf (slot-value (log-manager) 'cl-log::first-time) 0))
</pre>
</div>

<p>
An example of how we can start logging an AST form in category <code>micro-pass</code> is:
</p>

<pre class="example">
(log-message :micro-pass "This is a message ~a" ast-form)
</pre>

<p>
There are several convenience methods defined:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dbg</span> (format-string <span style="color: #228b22;">&amp;rest</span> arguments)
  (log-message <span style="color: #483d8b;">:debug</span> (apply #'format nil format-string arguments)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">log-micro-pass</span> (name arg)
  (log-message <span style="color: #483d8b;">:micro-pass</span> <span style="color: #8b2252;">"Running micro-pass ~a on ~a"</span> name arg))
</pre>
</div>

<p>
The following function can set the log-level, which basically means the level
of indentation.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-level</span> (level)
  (setf (log-level) (cons 'or (get-categories-for-level level))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> (<span style="color: #0000ff;">setf log-level</span>) (new-value)
  (defcategory-fn <span style="color: #483d8b;">:log-level</span> new-value))
</pre>
</div>
</div>
</div>



<div id="outline-container-orgcea4330" class="outline-5">
<h5 id="orgcea4330"><span class="section-number-5">3.12.2.2</span> The internals</h5>
<div class="outline-text-5" id="text-3-12-2-2">
<p>
To use logging in MCL, we have to define a level for the categorie.  The level
determines to what extent the log messages are indented.  The function
<code>set-level</code> stores the levels in an array and associates the level with the
symbol.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-level-category</span> (category level)
  (setf (get 'level category) level)
  (<span style="color: #a020f0;">when</span> (&gt;= level (length *levels*))
    (adjust-array *levels* (+ level 10) <span style="color: #483d8b;">:initial-element</span> nil))
  (setf (aref *levels* level) (push category (aref *levels* level))))
</pre>
</div>


<p>
We can retrieve the level of a category with the following function that gives
an error if the categorie is unknown:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-level</span> (category)
  (aif (get 'level category)
       it
       (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to specifiy a level for categorie ~a"</span> category)))
</pre>
</div>

<p>
Likewise, we can retrieve all categories for a specific level:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-categories-for-level</span> (level)
  (<span style="color: #a020f0;">loop</span> for i from 0 to level append (aref *levels* i)))
</pre>
</div>

<p>
The class <code>formatted-message</code> creates formatted messages.  We override this to
create indented messages.  The class does not need to have a slot value, as the
level of indentation is based on the category of the message.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">indented-message</span> (formatted-message) nil)
</pre>
</div>

<p>
To create indented output, we override the following function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*indentation-width*</span> 2)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">format-message</span> ((self indented-message))
  (<span style="color: #a020f0;">let</span> ((level (1- (get-level (message-category self)))))
    (<span style="color: #a020f0;">if</span> (eql level 0)
        (format nil <span style="color: #8b2252;">"~a ~?~&amp;"</span>
                (message-category self)
                (message-description self)
                (message-arguments self))
        (format nil <span style="color: #8b2252;">"~vt~a ~?~&amp;"</span>
                (* *indentation-width* level)
                (message-category self)
                (message-description self)
                (message-arguments self)))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc9fea6e" class="outline-3">
<h3 id="orgc9fea6e"><span class="section-number-3">3.13</span> Utilities</h3>
<div class="outline-text-3" id="text-3-13">
<p>
The following library defines several utility functions for MCL.
</p>
</div>

<div id="outline-container-orgb2a88e0" class="outline-4">
<h4 id="orgb2a88e0"><span class="section-number-4">3.13.1</span> The package</h4>
<div class="outline-text-4" id="text-3-13-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:mcl-util</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span>
        <span style="color: #b22222;">;;</span><span style="color: #b22222;">:lol :util</span>
        <span style="color: #483d8b;">:errors</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:getenv</span> <span style="color: #483d8b;">:tostring</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-orga402e09" class="outline-4">
<h4 id="orga402e09"><span class="section-number-4">3.13.2</span> The utility functions</h4>
<div class="outline-text-4" id="text-3-13-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">getenv</span> (string)
  <span style="color: #8b2252;">"Get the environment variable in the string."</span>
  (aif (uiop:getenv string)
       it
       (mcl-error nil <span style="color: #8b2252;">"Environment variable ~s has not been defined"</span> string)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tostring</span> (<span style="color: #228b22;">&amp;rest</span> lines)
  (format nil <span style="color: #8b2252;">"~{~a~^~%~}"</span> lines))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgee10bd5" class="outline-2">
<h2 id="orgee10bd5"><span class="section-number-2">4</span> The hardware description language HDL</h2>
<div class="outline-text-2" id="text-4">
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbae3ddc">4.1. The AST of HDL</a>
<ul>
<li><a href="#org69bee42">4.1.1. The package</a></li>
<li><a href="#org67a4e73">4.1.2. The AST</a>
<ul>
<li><a href="#org40d8774">4.1.2.1. Toplevel</a></li>
<li><a href="#orgb3a2899">4.1.2.2. Blocks</a></li>
<li><a href="#org3ad1ab5">4.1.2.3. properties</a></li>
<li><a href="#org7cf2066">4.1.2.4. expressions</a></li>
<li><a href="#org4256690">4.1.2.5. Units</a></li>
<li><a href="#orga50a65a">4.1.2.6. identifiers</a></li>
</ul>
</li>
<li><a href="#org11d617f">4.1.3. Print functions</a></li>
</ul>
</li>
<li><a href="#org47e59df">4.2. The ESRAP parser</a>
<ul>
<li><a href="#orge474141">4.2.1. The package</a></li>
<li><a href="#org1b5252f">4.2.2. Utility functions</a></li>
<li><a href="#org382276b">4.2.3. The parser</a></li>
</ul>
</li>
<li><a href="#org5701b38">4.3. Testing the parser</a>
<ul>
<li><a href="#orgae5cb9d">4.3.1. Package</a></li>
<li><a href="#org9be25be">4.3.2. The functionality</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgbae3ddc" class="outline-3">
<h3 id="orgbae3ddc"><span class="section-number-3">4.1</span> The AST of HDL</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org69bee42" class="outline-4">
<h4 id="org69bee42"><span class="section-number-4">4.1.1</span> The package</h4>
<div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:ast-hdl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org67a4e73" class="outline-4">
<h4 id="org67a4e73"><span class="section-number-4">4.1.2</span> The AST</h4>
<div class="outline-text-4" id="text-4-1-2">
</div>

<div id="outline-container-org40d8774" class="outline-5">
<h5 id="org40d8774"><span class="section-number-5">4.1.2.1</span> Toplevel</h5>
<div class="outline-text-5" id="text-4-1-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(defast hardware-description
    ((hardware-description (id specializes hdl-blocks) ()))
  ())
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3a2899" class="outline-5">
<h5 id="orgb3a2899"><span class="section-number-5">4.1.2.2</span> Blocks</h5>
<div class="outline-text-5" id="text-4-1-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(defast hdl-block
    ((hdl-block (hdl-block-type id hdl-stats) ()))
  ())
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ad1ab5" class="outline-5">
<h5 id="org3ad1ab5"><span class="section-number-5">4.1.2.3</span> properties</h5>
<div class="outline-text-5" id="text-4-1-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(defast property
    ((property (property-type exprs) ()))
  ())
</pre>
</div>
</div>
</div>

<div id="outline-container-org7cf2066" class="outline-5">
<h5 id="org7cf2066"><span class="section-number-5">4.1.2.4</span> expressions</h5>
<div class="outline-text-5" id="text-4-1-2-4">
<div class="org-src-container">
<pre class="src src-lisp">(defast hdl-expr
    ((unlimited-literal () ())
     (true-literal () ())
     (false-literal () ())
     (id-expr (qual-id kleene-star) ())
     (int-literal (value) ())
     (mul (left right) ())
     (add (left right) ())
     (div (left right) ())
     (sub (left right) ())
     (mul-op () ())
     (add-op () ())
     (div-op () ())
     (sub-op () ())
     (string-literal (value) ()))
  ())
</pre>
</div>
</div>
</div>


<div id="outline-container-org4256690" class="outline-5">
<h5 id="org4256690"><span class="section-number-5">4.1.2.5</span> Units</h5>
<div class="outline-text-5" id="text-4-1-2-5">
<div class="org-src-container">
<pre class="src src-lisp">
(defast unit-expr
    ((unit-expr (expr unit) ()))
  ())


(defast unit
    ((unit (prefix suffix) ()))
  ())
</pre>
</div>
</div>
</div>


<div id="outline-container-orga50a65a" class="outline-5">
<h5 id="orga50a65a"><span class="section-number-5">4.1.2.6</span> identifiers</h5>
<div class="outline-text-5" id="text-4-1-2-6">
<div class="org-src-container">
<pre class="src src-lisp">(defast id 
    ((id (name) ())
     (compound-id (name compound) ()))
  ())

(defast id-stat
    ((id-stat (id) ()))
  ())
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org11d617f" class="outline-4">
<h4 id="org11d617f"><span class="section-number-4">4.1.3</span> Print functions</h4>
<div class="outline-text-4" id="text-4-1-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((ast id) stream)
   (print-unreadable-object (ast stream <span style="color: #483d8b;">:type</span> t)
     (format stream <span style="color: #8b2252;">"~s"</span> (name ast))))

(create-print-functions ((hardware-description id) (hdl-block id)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org47e59df" class="outline-3">
<h3 id="org47e59df"><span class="section-number-3">4.2</span> The ESRAP parser</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orge474141" class="outline-4">
<h4 id="orge474141"><span class="section-number-4">4.2.1</span> The package</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:parse-hdl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-hdl</span> <span style="color: #483d8b;">:esrap</span> <span style="color: #483d8b;">:parser.common-rules</span> <span style="color: #483d8b;">:parsing</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:read-file-into-string</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:parse-hdl</span> <span style="color: #483d8b;">:parse-hdl-file</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b5252f" class="outline-4">
<h4 id="org1b5252f"><span class="section-number-4">4.2.2</span> Utility functions</h4>
<div class="outline-text-4" id="text-4-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-hdl</span> (string)
  (parse 'hardware-description string))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-hdl-file</span> (filename)
 (parse-hdl (read-file-into-string filename)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org382276b" class="outline-4">
<h4 id="org382276b"><span class="section-number-4">4.2.3</span> The parser</h4>
<div class="outline-text-4" id="text-4-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(defrule hardware-description (and skippable?
                                   hardware_description-kw/?s id/?s semi-colon/?s
                                   specializes
                                   hdl-blocks/?s)
  (<span style="color: #483d8b;">:destructure</span> (sk kw id sc specializes hdl-blocks <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore sk kw sc))
                (make-hardware-description id specializes hdl-blocks (make-loc start end))))

(defrule/s specializes (? (and specializes-kw/?s id/?s semi-colon/?s))
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s hdl-blocks (* hdl-block/?s))

(defrule/s hdl-block (and block-kw/?s id/?s block-open/?s hdl-stats/?s block-close/?s)
  (<span style="color: #483d8b;">:destructure</span> (block-kw id bo hdl-stats bc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore bo bc))
                (make-hdl-block block-kw id hdl-stats (make-loc start end))))

(defrule/s hdl-stats (* hdl-stat/?s))

(defrule/s hdl-stat (or hdl-block/?s
                        id-stat/?s
                        property-stat/?s))

(defrule/s id-stat (and qual-id/?s semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (id sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore sc))
                (make-id-stat id (make-loc start end))))

(defrule/s property-stat (or keyword-stat/?s assign-stat/?s arg-property-stat/?s))

(defrule/s keyword-stat (and statement-kw/?s semi-colon/?s)
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-property (first result) nil (make-loc start end))))

(defrule/s arg-property-stat (and arg-property-kw/?s
                                  parenthesis-open/?s unit-exprs-1/?s parenthesis-close/?s semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (kw po exprs pc sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore po pc sc))
                (make-property kw exprs (make-loc start end))))

(defrule/s unit-exprs-1 (and unit-expr/?s (* comma-unit-exprs))
  (<span style="color: #483d8b;">:destructure</span> (unit-expr other-unit-exprs)
                (<span style="color: #a020f0;">if</span> other-unit-exprs
                    (cons unit-expr other-unit-exprs)
                    (list unit-expr))))

(defrule/s comma-unit-exprs (and comma/?s unit-expr/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s assign-stat (and property-kw/?s equals/?s unit-expr/?s semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (property-kw eq expr sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore eq sc))
                (make-property property-kw (list expr) (make-loc start end))))

(defrule/s unit-expr (and hdl-expr/?s (? prefix-unit/?s))
  (<span style="color: #483d8b;">:destructure</span> (expr <span style="color: #228b22;">&amp;optional</span> unit <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-unit-expr expr unit (make-loc start end))))

(defrule/s hdl-expr (and factor/?s (* (and term-op/?s factor/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s term-op (or add-op/?s minus-op/?s))

(defrule/s factor (and hdl-atom/?s (* (and factor-op/?s hdl-atom/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s factor-op (or mul-op/?s div-op/?s))

(defrule/s hdl-atom (or unlimited-kw/?s
                    true-kw/?s
                    false-kw/?s
                    id-expr/?s
                    int-literal/?s
                    string-literal/?s
                    add-instruction/?s
                    sub-instruction/?s
                    mul-instruction/?s
                    div-instruction/?s))

(defrule/s id-expr (and qual-id (? kleene-op))
  (<span style="color: #483d8b;">:destructure</span> (id <span style="color: #228b22;">&amp;optional</span> kleene-op <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-id-expr id kleene-op (make-loc start end))))

(defrule/s prefix-unit (and (? prefix) unit)
  (<span style="color: #483d8b;">:destructure</span> (prefix unit <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-unit prefix unit (make-loc start end))))

(defrule prefix (or <span style="color: #8b2252;">"G"</span> <span style="color: #8b2252;">"M"</span> <span style="color: #8b2252;">"k"</span>))

(defrule unit (or div-unit basic-unit-kw))

(defrule div-unit (and basic-unit-kw <span style="color: #8b2252;">"/"</span> basic-unit-kw)
  (<span style="color: #483d8b;">:text</span> t))

(defrule/s int-literal integer-literal
  (<span style="color: #483d8b;">:lambda</span> (int <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-int-literal int (make-loc start end))))

(defrule/s string-literal string-literal/double-quotes
  (<span style="color: #483d8b;">:lambda</span> (string <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-string-literal string (make-loc start end))))

(defrule/s qual-id (and id (? (and #\. qual-id)))
  (<span style="color: #483d8b;">:destructure</span> (before-dot dot-part <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">if</span> dot-part
                    (make-compound-id before-dot (second dot-part) (make-loc start end))
                    before-dot)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defkw-group</span> (name keyword-list)
  `(<span style="color: #a020f0;">progn</span>
     ,@(mapcar #'gen-keyword (symbol-value keyword-list))
     (defrule/s ,name (or ,@(mapcar #'gen-keyword-id (symbol-value keyword-list))))))

(<span style="color: #a020f0;">eval-when</span> (<span style="color: #483d8b;">:compile-toplevel</span> <span style="color: #483d8b;">:load-toplevel</span> <span style="color: #483d8b;">:execute</span>)
  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-keyword</span> (keyword-string)
  `(defkw ,keyword-string (<span style="color: #483d8b;">:function</span> first)))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-keyword-id</span> (keyword-string)
    (intern (format nil <span style="color: #8b2252;">"~a-KW/?S"</span> (string-upcase keyword-string))))

  (<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*block-keywords*</span> '(<span style="color: #8b2252;">"parallelism"</span> <span style="color: #8b2252;">"memory_space"</span> <span style="color: #8b2252;">"par_unit"</span> <span style="color: #8b2252;">"par_group"</span>
                                   <span style="color: #8b2252;">"device"</span> <span style="color: #8b2252;">"memory"</span> <span style="color: #8b2252;">"interconnect"</span> <span style="color: #8b2252;">"device_group"</span>
                                   <span style="color: #8b2252;">"device_unit"</span> <span style="color: #8b2252;">"execution_group"</span> <span style="color: #8b2252;">"execution_unit"</span>
                                   <span style="color: #8b2252;">"instructions"</span> <span style="color: #8b2252;">"cache"</span> <span style="color: #8b2252;">"simd_group"</span> <span style="color: #8b2252;">"simd_unit"</span>
                                   <span style="color: #8b2252;">"load_store_group"</span> <span style="color: #8b2252;">"load_store_unit"</span>))

  (<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*statement-keywords*</span> '(<span style="color: #8b2252;">"default"</span> <span style="color: #8b2252;">"read_only"</span>))

  (<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*property-keywords*</span> '(<span style="color: #8b2252;">"nr_units"</span> <span style="color: #8b2252;">"max_nr_units"</span> <span style="color: #8b2252;">"capacity"</span> <span style="color: #8b2252;">"latency"</span>
                                      <span style="color: #8b2252;">"bandwidth"</span> <span style="color: #8b2252;">"nr_banks"</span> <span style="color: #8b2252;">"clock_frequency"</span> <span style="color: #8b2252;">"addressable"</span>
                                      <span style="color: #8b2252;">"cache_line_size"</span> <span style="color: #8b2252;">"width"</span>))

  (<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*arg-property-keywords*</span> '(<span style="color: #8b2252;">"slots"</span> <span style="color: #8b2252;">"connects"</span> <span style="color: #8b2252;">"space"</span> <span style="color: #8b2252;">"op"</span>
                                          <span style="color: #8b2252;">"performance_feedback"</span>))

  (<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*other-keywords*</span> '(<span style="color: #8b2252;">"hardware_description"</span> <span style="color: #8b2252;">"specializes"</span> <span style="color: #8b2252;">"unlimited"</span> <span style="color: #8b2252;">"true"</span> <span style="color: #8b2252;">"false"</span>))

  (<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*unit-keywords*</span> '(<span style="color: #8b2252;">"k"</span> <span style="color: #8b2252;">"B"</span> <span style="color: #8b2252;">"bits"</span> <span style="color: #8b2252;">"bit"</span> <span style="color: #8b2252;">"cycles"</span> <span style="color: #8b2252;">"cycle"</span> <span style="color: #8b2252;">"s"</span> <span style="color: #8b2252;">"Hz"</span>))

  (<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*keywords*</span> (concatenate 'list *block-keywords* *statement-keywords*
                                        *property-keywords* *arg-property-keywords*
                                        *other-keywords* *unit-keywords*)))

(defkw-group arg-property-kw *arg-property-keywords*)
(defkw-group basic-unit-kw *unit-keywords*)
(defkw-group block-kw *block-keywords*)
(defkw-group statement-kw *statement-keywords*)
(defkw-group property-kw *property-keywords*)

(defkw <span style="color: #8b2252;">"hardware_description"</span>)
(defkw <span style="color: #8b2252;">"specializes"</span>)
(defkw <span style="color: #8b2252;">"unlimited"</span>
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore result))
    (make-unlimited-literal (make-loc start end))))
(defkw <span style="color: #8b2252;">"true"</span>
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore result))
    (make-true-literal (make-loc start end))))
(defkw <span style="color: #8b2252;">"false"</span>
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore result))
    (make-false-literal (make-loc start end))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">not-keyword-p</span> (id)
  (not (member id *keywords* <span style="color: #483d8b;">:test</span> #'string=)))

(defrule/s id (not-keyword-p identifier)
  (<span style="color: #483d8b;">:lambda</span> (name <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-id name (make-loc start end))))


(defrule/s add-op #\+
  (<span style="color: #483d8b;">:constant</span> #'make-add))
(defrule/s minus-op #\-
  (<span style="color: #483d8b;">:constant</span> #'make-sub))
(defrule/s mul-op #\*
  (<span style="color: #483d8b;">:constant</span> #'make-mul))
(defrule/s div-op #\/
  (<span style="color: #483d8b;">:constant</span> #'make-div))

(defrule/s add-instruction <span style="color: #8b2252;">"(+)"</span>
  (<span style="color: #483d8b;">:lambda</span> (v <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore v))
    (make-add-op (make-loc start end))))
(defrule/s sub-instruction <span style="color: #8b2252;">"(-)"</span>
  (<span style="color: #483d8b;">:lambda</span> (v <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore v))
    (make-sub-op (make-loc start end))))
(defrule/s mul-instruction <span style="color: #8b2252;">"(*)"</span>
  (<span style="color: #483d8b;">:lambda</span> (v <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore v))
    (make-mul-op (make-loc start end))))
(defrule/s div-instruction <span style="color: #8b2252;">"(/)"</span>
  (<span style="color: #483d8b;">:lambda</span> (v <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore v))
    (make-div-op (make-loc start end))))

(defrule/s kleene-op <span style="color: #8b2252;">"[*]"</span>
  (<span style="color: #483d8b;">:constant</span> t))
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org5701b38" class="outline-3">
<h3 id="org5701b38"><span class="section-number-3">4.3</span> Testing the parser</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-orgae5cb9d" class="outline-4">
<h4 id="orgae5cb9d"><span class="section-number-4">4.3.1</span> Package</h4>
<div class="outline-text-4" id="text-4-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-parse-hdl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:parse-hdl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-hdl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-parse-hdl</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9be25be" class="outline-4">
<h4 id="org9be25be"><span class="section-number-4">4.3.2</span> The functionality</h4>
<div class="outline-text-4" id="text-4-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite parse-hdl <span style="color: #483d8b;">:in</span> mcl-test-suite)

(in-suite parse-hdl)

(test minimal-hardware-description
  (<span style="color: #a020f0;">let</span> ((ast (hardware-description nil)))
    (is
      (ast= ast
            (parse-hdl <span style="color: #8b2252;">"hardware_description a ;"</span>)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hardware-description</span> (blocks)
  (make-hardware-description (make-id <span style="color: #8b2252;">"a"</span> nil) nil blocks nil))

(test minimal-block
  (<span style="color: #a020f0;">let</span> ((ast (hardware-description (list (hdl-block
                                          <span style="color: #8b2252;">"parallelism"</span>
                                          <span style="color: #8b2252;">"hierarchy"</span>
                                          nil)))))
    (is
      (ast= ast
            (parse-hdl <span style="color: #8b2252;">"hardware_description a;</span>
<span style="color: #8b2252;">parallelism hierarchy { }"</span>)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hdl-block</span> (type id stats)
  (make-hdl-block type (make-id id nil) stats nil))

(test nested-block
  (<span style="color: #a020f0;">let</span> ((ast (hardware-description
              (list (hdl-block
                     <span style="color: #8b2252;">"parallelism"</span>
                     <span style="color: #8b2252;">"hierarchy"</span>
                     (list (hdl-block
                            <span style="color: #8b2252;">"memory_space"</span>
                            <span style="color: #8b2252;">"main"</span>
                            nil)))))))
    (is
      (ast= ast
            (parse-hdl <span style="color: #8b2252;">"hardware_description a;</span>
<span style="color: #8b2252;">parallelism hierarchy {</span>
<span style="color: #8b2252;">  memory_space main {}</span>
<span style="color: #8b2252;">}"</span>)))))

(def-suite stats <span style="color: #483d8b;">:in</span> parse-hdl)
(in-suite stats)

(test various-stats
  (is (ast= (hdl-stat (make-property <span style="color: #8b2252;">"default"</span> nil nil))
          (parse-hdl (hdl-string-with-stat <span style="color: #8b2252;">"default;"</span>))))
  (is (ast= (hdl-stat (make-property
                       <span style="color: #8b2252;">"max_nr_units"</span> (list (make-unit-expr
                                             (make-unlimited-literal nil)
                                             nil
                                             nil))
                       nil))
            (parse-hdl (hdl-string-with-stat <span style="color: #8b2252;">"max_nr_units = unlimited;"</span>))))
  (is (ast= (hdl-stat (make-id-stat (make-id <span style="color: #8b2252;">"main"</span> nil) nil))
            (parse-hdl (hdl-string-with-stat <span style="color: #8b2252;">"main;"</span>))))
  (is (ast= (hdl-stat (make-property <span style="color: #8b2252;">"space"</span>
                                     (list (id-expr <span style="color: #8b2252;">"main"</span>))
                                     nil))
            (parse-hdl (hdl-string-with-stat <span style="color: #8b2252;">"space(main);"</span>))))
  (is (ast= (hdl-stat
             (make-property <span style="color: #8b2252;">"connects"</span>
                            (list (id-expr <span style="color: #8b2252;">"main"</span>)
                                  (id-expr <span style="color: #8b2252;">"a"</span>))
                            nil))
            (parse-hdl (hdl-string-with-stat <span style="color: #8b2252;">"connects(main, a);"</span>))))
  (is (ast= (hdl-stat
             (make-property <span style="color: #8b2252;">"connects"</span>
                            (list (id-expr <span style="color: #8b2252;">"main"</span>)
                                  (compound-expr <span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"b"</span>))
                            nil))
            (parse-hdl (hdl-string-with-stat <span style="color: #8b2252;">"connects(main, a.b);"</span>))))
  (is (ast= (hdl-stat (make-property <span style="color: #8b2252;">"op"</span> (list (make-unit-expr
                                                 (make-add-op nil) nil nil)) <span style="color: #ff0000; font-weight: bold;">nil))</span>
            (parse-hdl (hdl-string-with-stat <span style="color: #8b2252;">"op((+));"</span>)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hdl-stat</span> (stat)
  (hardware-description
              (list (hdl-block
                     <span style="color: #8b2252;">"parallelism"</span>
                     <span style="color: #8b2252;">"hierarchy"</span>
                     (list (hdl-block
                            <span style="color: #8b2252;">"memory_space"</span>
                            <span style="color: #8b2252;">"main"</span>
                            (list stat)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hdl-string-with-stat</span> (stat-as-string)
  (format nil <span style="color: #8b2252;">"hardware_description a;</span>
<span style="color: #8b2252;">parallelism hierarchy {</span>
<span style="color: #8b2252;">  memory_space main {</span>
<span style="color: #8b2252;">    ~a</span>
<span style="color: #8b2252;">  }</span>
<span style="color: #8b2252;">}"</span> stat-as-string))

(def-suite expressions <span style="color: #483d8b;">:in</span> parse-hdl)
(in-suite expressions)


(test various-expressions
  (is (ast= (hdl-expr (make-unit-expr (make-unlimited-literal nil)
                                      (make-unit nil <span style="color: #8b2252;">"B"</span> nil)
                                      nil))
          (parse-hdl (hdl-string-with-expr <span style="color: #8b2252;">"unlimited B"</span>))))
  (is (ast= (hdl-expr (make-unit-expr (make-unlimited-literal nil)
                                      (make-unit <span style="color: #8b2252;">"G"</span> <span style="color: #8b2252;">"B"</span> nil)
                                      nil))
            (parse-hdl (hdl-string-with-expr <span style="color: #8b2252;">"unlimited GB"</span>))))
  (is (ast= (hdl-expr (make-unit-expr (make-unlimited-literal nil)
                                      (make-unit <span style="color: #8b2252;">"k"</span> <span style="color: #8b2252;">"B"</span> nil)
                                      nil))
            (parse-hdl (hdl-string-with-expr <span style="color: #8b2252;">"unlimited kB"</span>))))
  (is (ast= (hdl-expr (make-unit-expr (make-unlimited-literal nil)
                                      (make-unit <span style="color: #8b2252;">"G"</span> <span style="color: #8b2252;">"B/s"</span> nil)
                                      nil))
            (parse-hdl (hdl-string-with-expr <span style="color: #8b2252;">"unlimited GB/s"</span>))))
  (is (ast= (hdl-expr (make-unit-expr (make-id-expr
                                       (make-compound-id
                                        (make-id <span style="color: #8b2252;">"cores"</span> nil) (make-id <span style="color: #8b2252;">"core"</span> nil)
                                        nil)
                                       t nil)
                                      nil nil))
            (parse-hdl (hdl-string-with-expr <span style="color: #8b2252;">"cores.core[*]"</span>))))
  (is (ast= (hdl-expr (make-unit-expr (make-int-literal 1 nil) nil nil))
            (parse-hdl (hdl-string-with-expr <span style="color: #8b2252;">"1"</span>))))
  (is (ast= (hdl-expr (make-unit-expr (make-mul
                                       (make-int-literal 10 nil)
                                       (make-int-literal 32 nil)
                                       nil)
                                      (make-unit nil <span style="color: #8b2252;">"bit"</span> nil)
                                      nil))
            (parse-hdl (hdl-string-with-expr <span style="color: #8b2252;">"10 * 32 bit"</span>)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hdl-expr</span> (expr)
  (hdl-stat (make-property <span style="color: #8b2252;">"max_nr_units"</span> (list expr) nil)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hdl-string-with-expr</span> (string-expr)
  (hdl-string-with-stat (format nil <span style="color: #8b2252;">"max_nr_units = ~a;"</span> string-expr)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">id-expr</span> (name)
  (make-unit-expr
   (make-id-expr
    (make-id name nil)
    nil <span style="color: #b22222;">; kleene star</span>
    nil)
   nil <span style="color: #b22222;">; unit</span>
   nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compound-expr</span> (l r)
  (make-unit-expr
   (make-id-expr
    (make-compound-id
     (make-id l nil)
     (make-id r nil)
     nil)
    nil <span style="color: #b22222;">; kleene star</span>
    nil)
   nil <span style="color: #b22222;">; unit</span>
   nil))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org5d80b01" class="outline-2">
<h2 id="org5d80b01"><span class="section-number-2">5</span> Many-Core Programming Language</h2>
<div class="outline-text-2" id="text-5">
<div id="text-table-of-contents">
<ul>
<li><a href="#orgfbb7adc">5.1. The AST of MCPL</a>
<ul>
<li><a href="#orgcb63bd5">5.1.1. The package</a></li>
<li><a href="#org4948ca4">5.1.2. The AST</a>
<ul>
<li><a href="#org47b92c8">5.1.2.1. top-level</a></li>
<li><a href="#org0c6520c">5.1.2.2. declarations</a></li>
<li><a href="#org25eeac1">5.1.2.3. types</a></li>
<li><a href="#org7593a99">5.1.2.4. statements</a></li>
<li><a href="#org2c2096c">5.1.2.5. vars</a></li>
<li><a href="#orgc3ea0ae">5.1.2.6. expressions</a></li>
</ul>
</li>
<li><a href="#org485e8c3">5.1.3. Printing functions</a></li>
<li><a href="#orged1a6e2">5.1.4. Accessor functions</a>
<ul>
<li><a href="#orgc0fc93d">5.1.4.1. Retrieving basic declarations</a></li>
<li><a href="#orgccf17e7">5.1.4.2. Retrieving the identifier</a></li>
<li><a href="#org3bdd716">5.1.4.3. Retrieving the basic declaration of a variable</a></li>
<li><a href="#org5ddfc00">5.1.4.4. Retrieving the basic declarations in scope</a></li>
<li><a href="#org1376e6c">5.1.4.5. Builtin functions.</a></li>
<li><a href="#org93ec0d8">5.1.4.6. Checking for casting functions</a></li>
<li><a href="#org5a67ff5">5.1.4.7. Parameters and calls</a></li>
<li><a href="#org17bef02">5.1.4.8. Checking whether a parameter is written</a></li>
<li><a href="#orgc9fd5a5">5.1.4.9. Retrieve the index of parameter</a></li>
<li><a href="#org09c2585">5.1.4.10. Retrieve the module of an AST form</a></li>
<li><a href="#orgb79a5ba">5.1.4.11. Retrieve the enclosing function of an AST form</a></li>
<li><a href="#org772e30d">5.1.4.12. Information about expressions</a></li>
<li><a href="#org37ef299">5.1.4.13. Checking whether something is constant</a></li>
<li><a href="#org4793ef8">5.1.4.14. Getting the base type of an array</a></li>
<li><a href="#org508e310">5.1.4.15. Getting the names of memory spaces</a></li>
<li><a href="#orga800058">5.1.4.16. Whether a memory space is disallowed</a></li>
<li><a href="#org20c17a3">5.1.4.17. Whether an AST is in a foreach</a></li>
<li><a href="#org8370207">5.1.4.18. Typedef variables and declarations</a></li>
<li><a href="#org9a971a4">5.1.4.19. Global constants</a></li>
<li><a href="#org693f024">5.1.4.20. Whether functions exist</a></li>
<li><a href="#org126856c">5.1.4.21. Ancestors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge0ad2ee">5.2. The parser</a>
<ul>
<li><a href="#org47e8b18">5.2.1. The parser</a>
<ul>
<li><a href="#org186d843">5.2.1.1. the package</a></li>
<li><a href="#orgc2a52f3">5.2.1.2. top-level</a></li>
<li><a href="#org71c93a3">5.2.1.3. top declarations</a></li>
<li><a href="#org127da4d">5.2.1.4. functions</a></li>
<li><a href="#org0136625">5.2.1.5. Statements</a></li>
<li><a href="#org8655500">5.2.1.6. declarations</a></li>
<li><a href="#org8b3378a">5.2.1.7. types</a></li>
<li><a href="#orgd3f9f3c">5.2.1.8. expressions</a></li>
<li><a href="#orga98765d">5.2.1.9. variables</a></li>
<li><a href="#orgf54647e">5.2.1.10. identifiers</a></li>
<li><a href="#org460676c">5.2.1.11. keywords</a></li>
<li><a href="#orgac7623a">5.2.1.12. tokens</a></li>
<li><a href="#orgb7af9a3">5.2.1.13. utility functions</a></li>
<li><a href="#org0675cf7">5.2.1.14. library</a></li>
</ul>
</li>
<li><a href="#org862c636">5.2.2. Testing the parser</a>
<ul>
<li><a href="#org4e0a4be">5.2.2.1. The package</a></li>
<li><a href="#org41608c2">5.2.2.2. top-level</a></li>
<li><a href="#org8513675">5.2.2.3. minimal module</a></li>
<li><a href="#orgaeedae3">5.2.2.4. declarations</a></li>
<li><a href="#orgb9dc689">5.2.2.5. expresssions</a></li>
<li><a href="#orgd18710b">5.2.2.6. vars</a></li>
<li><a href="#org326c06c">5.2.2.7. calls</a></li>
<li><a href="#orga6dc2ba">5.2.2.8. types</a></li>
<li><a href="#org5ea364a">5.2.2.9. statements</a></li>
<li><a href="#orgb41b2a3">5.2.2.10. test exports</a></li>
<li><a href="#org7f92420">5.2.2.11. test qualified ids</a></li>
<li><a href="#orga36a707">5.2.2.12. helper functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgfbb7adc" class="outline-3">
<h3 id="orgfbb7adc"><span class="section-number-3">5.1</span> The AST of MCPL</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orgcb63bd5" class="outline-4">
<h4 id="orgcb63bd5"><span class="section-number-4">5.1.1</span> The package</h4>
<div class="outline-text-4" id="text-5-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:ast-mcpl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:def-methods</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:compose</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:get-basic-decls</span>
           <span style="color: #483d8b;">:get-basic-decl</span>
           <span style="color: #483d8b;">:get-basic-decls-in-scope</span>
           <span style="color: #483d8b;">:get-id</span>
           <span style="color: #483d8b;">:normal-id-p</span>
           <span style="color: #483d8b;">:func-id-p</span>
           <span style="color: #483d8b;">:type-id-p</span>
           <span style="color: #483d8b;">:const-id-p</span>

           <span style="color: #483d8b;">:param-written-p</span>
           <span style="color: #483d8b;">:param-p</span>
           <span style="color: #483d8b;">:get-position-in-call</span>
           <span style="color: #483d8b;">:param-call-&gt;param-func</span>
           <span style="color: #483d8b;">:get-decl-param</span>
           <span style="color: #483d8b;">:get-basic-decl-param</span>
           <span style="color: #483d8b;">:decl-calling-func-&gt;called-func</span>
           <span style="color: #483d8b;">:decl-called-func-&gt;calling-func</span>
           <span style="color: #483d8b;">:decl-calling-func-in-called-func-p</span>
           <span style="color: #483d8b;">:decl-called-func-in-calling-func-p</span>
           <span style="color: #483d8b;">:call-expr-p</span>
           <span style="color: #483d8b;">:call-stat-p</span>

           <span style="color: #483d8b;">:get-decl-var</span>
           <span style="color: #483d8b;">:constant-p</span>
           <span style="color: #483d8b;">:global-p</span>
           <span style="color: #483d8b;">:priority</span>
           <span style="color: #483d8b;">:binary-p</span>
           <span style="color: #483d8b;">:unary-p</span>
           <span style="color: #483d8b;">:left-associative-p</span>
           <span style="color: #483d8b;">:right-associative-p</span>


           <span style="color: #483d8b;">:get-module</span>

           <span style="color: #483d8b;">:get-func</span>
           <span style="color: #483d8b;">:func-exists-p</span>

           <span style="color: #483d8b;">:get-base-type</span>

           <span style="color: #483d8b;">:get-memory-spaces-modifier</span>

           <span style="color: #483d8b;">:memory-space-disallowed</span>
           <span style="color: #483d8b;">:primitive-decl-p</span>
           <span style="color: #483d8b;">:primitive-type-p</span>
           <span style="color: #483d8b;">:get-type-decl</span>

           <span style="color: #483d8b;">:in-foreach-p</span>
           <span style="color: #483d8b;">:top-level-foreach-p</span>
           <span style="color: #483d8b;">:inner-foreach-p</span>

           <span style="color: #483d8b;">:builtin-func-p</span>
           <span style="color: #483d8b;">:cast-func-p</span>
           <span style="color: #483d8b;">:get-type-builtin-func</span>
           <span style="color: #483d8b;">:transfer-p</span>

           <span style="color: #483d8b;">:global-constant-p</span>
           <span style="color: #483d8b;">:typedef-var-p</span>
           <span style="color: #483d8b;">:typedef-decl-p</span>

           <span style="color: #483d8b;">:ancestors-match</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4948ca4" class="outline-4">
<h4 id="org4948ca4"><span class="section-number-4">5.1.2</span> The AST</h4>
<div class="outline-text-4" id="text-5-1-2">
</div>

<div id="outline-container-org47b92c8" class="outline-5">
<h5 id="org47b92c8"><span class="section-number-5">5.1.2.1</span> top-level</h5>
<div class="outline-text-5" id="text-5-1-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(defast module
        ((module (pkg id exports imports code) ())) 
        ())

(defast lib-import 
        ((lib-import (id) ())) 
        ())

(defast code 
        ((code (top-decls funcs) ())) 
        ())

(defast func 
        ((func (hw-desc mcl-type id params code-block)
               (cfgraph called-by
                        <span style="color: #b22222;">;; </span><span style="color: #b22222;">written-on-device-entry</span>
                        <span style="color: #b22222;">;; </span><span style="color: #b22222;">read-on-device-entry</span>
                        <span style="color: #b22222;">;; </span><span style="color: #b22222;">written-on-device-exit</span>
                        <span style="color: #b22222;">;; </span><span style="color: #b22222;">read-on-device-exit</span>
                        entry-on-device-variables
                        exit-on-device-variables)))
        ())
</pre>
</div>
</div>
</div>

<div id="outline-container-org0c6520c" class="outline-5">
<h5 id="org0c6520c"><span class="section-number-5">5.1.2.2</span> declarations</h5>
<div class="outline-text-5" id="text-5-1-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(defast top-decl 
        ((const-decl (decl) ())
         (typedef (id params fields) ()))
        ())

(defast decl 
        ((normal-decl (modifiers basic-decls) ())
         (assign-decl (modifiers basic-decl expr) ())) 
        (as-basic-decls written loaded))

(defast decl-modifier 
        ((const () ())
         (user-defined (modifier) ()))
        ())

(defast basic-decl 
        ((basic-decl (mcl-type id) (decl vars)))
        ())
</pre>
</div>
</div>
</div>

<div id="outline-container-org25eeac1" class="outline-5">
<h5 id="org25eeac1"><span class="section-number-5">5.1.2.3</span> types</h5>
<div class="outline-text-5" id="text-5-1-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(defast mcl-type 
        ((void () ())
         (int () ())
         (flt () ())
         (double () ())
         (bool () ())
         (mcl-byte () ())
         (custom-type (id params) (typedef))
         (array-type (base-type sizes) ()))
        ())

(defast array-size 
        ((decl-array-size (size decl) ())
         (overlap (left size right) ()))
        ())
</pre>
</div>
</div>
</div>

<div id="outline-container-org7593a99" class="outline-5">
<h5 id="org7593a99"><span class="section-number-5">5.1.2.4</span> statements</h5>
<div class="outline-text-5" id="text-5-1-2-4">
<div class="org-src-container">
<pre class="src src-lisp">(defast stat 
        ((decl-stat (decl) ())
         (assign-stat (var expr) ())
         (block-stat (code-block) ())
         (inc-stat (inc) ())
         (call-stat (call) ())
         (return-stat (expr) ())
         (if-stat (cond-expr stat elseStat) ())
         (for-stat (decl cond-expr inc stat) ())
         (as-stat (var basic-decls) ())
         (foreach-stat (decl nr-iters par-group stat))
         (barrier-stat (mem-space) ())
         (swap-stat (var-left var-right) ()))
        ())

(defast code-block 
        ((code-block (stats) ()))
        ())

(defast increment 
        ((inc (var option) ())
         (inc-step (var option expr) ()))
        ())

(defast call 
        ((call (id params) (func)))
        ())
</pre>
</div>
</div>
</div>

<div id="outline-container-org2c2096c" class="outline-5">
<h5 id="org2c2096c"><span class="section-number-5">5.1.2.5</span> vars</h5>
<div class="outline-text-5" id="text-5-1-2-5">
<div class="org-src-container">
<pre class="src src-lisp">(defast var 
    ((normal-var (basic-var) ())
     (dot-var (basic-var var) ()))
  ())

(defast basic-var 
    ((basic-var (id array-exprs) (basic-decl)))
  ())

(defast id 
    ((id (name) ())
     (compound-id (name compound) ()))
  ())
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc3ea0ae" class="outline-5">
<h5 id="orgc3ea0ae"><span class="section-number-5">5.1.2.6</span> expressions</h5>
<div class="outline-text-5" id="text-5-1-2-6">
<div class="org-src-container">
<pre class="src src-lisp">(defast expr 
        ((log-or (l r) ())
         (log-and (l r) ())
         (bitor (l r) ())
         (bitand (l r) ())
         (equ (l r) ())
         (ne (l r) ())
         (lt (l r) ())
         (gt (l r) ())
         (le (l r) ())
         (ge (l r) ())
         (bitshl (l r) ())
         (bitshr (l r) ())
         (pow (l r) ())
         (add (l r) ())
         (sub (l r) ())
         (mul (l r) ())
         (div (l r) ())
         (modulo (l r) ())
         (minus (e) ())
         (neg (e) ())
         (call-expr (call) ())
         (var-expr (var) ())
         (int-constant (int-value) ())
         (float-constant (float-value) ())
         (bool-constant (bool-value) ()))
  (eval-type))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org485e8c3" class="outline-4">
<h4 id="org485e8c3"><span class="section-number-4">5.1.3</span> Printing functions</h4>
<div class="outline-text-4" id="text-5-1-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((ast id) stream)
   (print-unreadable-object (ast stream <span style="color: #483d8b;">:type</span> t)
     (format stream <span style="color: #8b2252;">"~s"</span> (name ast))))


(create-print-functions ((module id) (lib-import id) (func id) (const-decl decl)
                         (decl get-basic-decl)
                         (basic-decl id) (typedef id) (custom-type id)
                         (call id) (var basic-var) (basic-var id)
                         (call-stat call) (var-expr var)
                         (assign-stat var) (decl-stat decl)
                         (user-defined modifier)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orged1a6e2" class="outline-4">
<h4 id="orged1a6e2"><span class="section-number-4">5.1.4</span> Accessor functions</h4>
<div class="outline-text-4" id="text-5-1-4">
</div>

<div id="outline-container-orgc0fc93d" class="outline-5">
<h5 id="orgc0fc93d"><span class="section-number-5">5.1.4.1</span> Retrieving basic declarations</h5>
<div class="outline-text-5" id="text-5-1-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-basic-decls</span> (ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decls</span> ((d normal-decl))
  (append (basic-decls d) (as-basic-decls d)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decls</span> ((d assign-decl))
  (append (list (basic-decl d)) (as-basic-decls d)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-basic-decl</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the main basic-decl of a decl."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl</span> ((d normal-decl))
  (first (basic-decls d)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl</span> ((d assign-decl))
  (basic-decl d))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl</span> ((v var))
  (get-basic-decl (basic-var v)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl</span> ((bv basic-var))
  (basic-decl bv))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgccf17e7" class="outline-5">
<h5 id="orgccf17e7"><span class="section-number-5">5.1.4.2</span> Retrieving the identifier</h5>
<div class="outline-text-5" id="text-5-1-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-id</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the id of an ast-form"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-id</span> ((d decl))
  (get-id (get-basic-decl d)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-id</span> ((bd basic-decl))
  (id bd))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-id</span> ((v var))
  (id (basic-var v)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-id</span> ((td typedef))
  (id td))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-id</span> ((bv basic-var))
  (id bv))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-id</span> ((cd const-decl))
  (get-id (decl cd)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">normal-id-p</span> (id)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether id is a normal id"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">normal-id-p</span> ((id id))
  (lower-case-p (elt (name id) 0)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">normal-id-p</span> ((ci compound-id))
  (normal-id-p (compound ci)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">func-id-p</span> (id)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether id is an identifier for a function"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">func-id-p</span> ((id id))
  (normal-id-p id))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">type-id-p</span> (id)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether id is an identifier for a type"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">type-id-p</span> ((id id))
  (<span style="color: #a020f0;">with-slots</span> (name) id
    (and (&gt;= (length name) 2)
         (upper-case-p (elt name 0))
         (lower-case-p (elt name 1)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">type-id-p</span> ((ci compound-id))
  (type-id-p (compound ci)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">const-id-p</span> (id)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether id is an identifier for a constant."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">const-id-p</span> ((id id))
  (<span style="color: #a020f0;">with-slots</span> (name) id
    (and (&gt;= (length name) 2)
         (upper-case-p (elt name 0))
         (<span style="color: #a020f0;">let</span> ((c (elt name 1)))
           (or (upper-case-p c)
               (eql c #\_))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">const-id-p</span> ((ci compound-id))
  (const-id-p (compound ci)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3bdd716" class="outline-5">
<h5 id="org3bdd716"><span class="section-number-5">5.1.4.3</span> Retrieving the basic declaration of a variable</h5>
<div class="outline-text-5" id="text-5-1-4-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-decl-var</span> (var)
  <span style="color: #8b2252;">"Get the declaration of the variable."</span>
  (<span style="color: #a020f0;">let</span> ((d (decl (get-basic-decl-var var))))
    (<span style="color: #ff0000; font-weight: bold;">assert</span> d)
    d))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-basic-decl-var</span> (var)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the basic declaration of the var."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl-var</span> ((ve var-expr))
  (get-basic-decl-var (var ve)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl-var</span> ((v var))
  (get-basic-decl-var (basic-var v)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl-var</span> ((bv basic-var))
  (<span style="color: #a020f0;">let</span> ((bd (basic-decl bv)))
    (<span style="color: #ff0000; font-weight: bold;">assert</span> bd)
    bd))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ddfc00" class="outline-5">
<h5 id="org5ddfc00"><span class="section-number-5">5.1.4.4</span> Retrieving the basic declarations in scope</h5>
<div class="outline-text-5" id="text-5-1-4-4">
<p>
First, we find a parent of the ast-form, for which the analysis would also
hold.  This means that we find a parent in forms that cannot introduce
declarations that are also in the scope of ast-form.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-basic-decls-in-scope</span> (ast)
  (<span style="color: #a020f0;">let</span> ((until-parent (find-until-parent ast)))
    (<span style="color: #a020f0;">if</span> (null until-parent)
        nil
        (append (find-decls (parent until-parent) until-parent)
                (get-basic-decls-in-scope (parent until-parent))))))
</pre>
</div>


<p>
The function <code>find-decls</code> finds the declarations in an ast-form until it hits
<code>until-ast</code>.   The parents can only be ast-forms that introduce a new scope.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">find-decls</span> (parent until-ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((parent ast) (until-ast ast))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"illegal find-decls for ~a and ~a"</span> parent until-ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((cb code-block) (until stat))
  (<span style="color: #a020f0;">loop</span> for s in (stats cb)
     until (eq s until)
     append (get-basic-decls-stat s)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fe foreach-stat) (d decl))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fe foreach-stat) (e expr))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fe foreach-stat) (id id))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fe foreach-stat) (s stat))
  (basic-decls (decl fe)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fs for-stat) (d decl))
  nil)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-basic-decls-decl</span> (decl)
  (<span style="color: #a020f0;">typecase</span> decl
    (assign-decl (list (basic-decl decl)))
    (normal-decl (basic-decls decl))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fs for-stat) (e expr))
  (get-basic-decls-decl (decl fs)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fs for-stat) (i increment))
  (get-basic-decls-decl (decl fs)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((fs for-stat) (s stat))
  (get-basic-decls-decl (decl fs)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((f func) (id id))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((f func) (mcl-type mcl-type))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((f func) (d decl))
  (<span style="color: #a020f0;">loop</span> for p in (params f)
        until (eq p d)
        append (get-basic-decls-decl p)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-decls</span> ((f func) (cb code-block))
  (<span style="color: #a020f0;">loop</span> for p in (params f) appending (get-basic-decls-decl p)))
</pre>
</div>

<p>
Now we have defined the ast-forms that introduce a new scope, it is possible to
define a function that finds the parent for which the analysis stops.  The
following macro makes it easier to define <code>find-until-parent</code> functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">find-until-parent</span> (ast))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">def-find-until-parent</span> (ast-type parent-types)
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-until-parent</span> ((ast ,ast-type))
     (<span style="color: #a020f0;">if</span> (member (type-of (parent ast)) ,parent-types)
         ast
         (find-until-parent (parent ast)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-until-parent</span> ((ast ast))
  (<span style="color: #a020f0;">if</span> (null (parent ast))
      nil
      (find-until-parent (parent ast))))
</pre>
</div>

<p>
The <code>def-find-until-parent</code> macro specifies that if we for example a <code>decl</code>,
then the parent must be a <code>foreach-stat</code>, <code>for-stat</code>, or <code>func</code>.  Otherwise, the
search continues.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-find-until-parent decl '(foreach-stat for-stat func))
(def-find-until-parent expr '(foreach-stat for-stat))
(def-find-until-parent id '(foreach-stat func))
(def-find-until-parent stat '(foreach-stat for-stat code-block))
(def-find-until-parent increment '(for-stat))
(def-find-until-parent mcl-type '(func))
(def-find-until-parent code-block '(func))
</pre>
</div>

<p>
The function <code>get-basic-decls-stat</code> retrieves all basic-decls from a statement.
If the statement is a <code>decl-stat</code>, it continues in the <code>decls</code>.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-basic-decls-stat</span> (stat))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decls-stat</span> ((s stat))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decls-stat</span> ((ds decl-stat))
  (get-basic-decls-decl (decl ds)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decls</span> ((as as-stat))
  (basic-decls as))
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orgab179ff"></a>Testing<br />
<ul class="org-ul">
<li><a id="org916db8b"></a>The package<br />
<div class="outline-text-7" id="text-org916db8b">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-ast-mcpl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-ast-mcpl</span>))
</pre>
</div>
</div>
</li>

<li><a id="org7a1b720"></a>The tests<br />
<div class="outline-text-7" id="text-org7a1b720">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite ast-mcpl <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite mcl-test-suite)

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*module*</span> 
<span style="color: #8b2252;">"package a;</span>
<span style="color: #8b2252;">module b;</span>

<span style="color: #8b2252;">perfect void f(int a) {</span>
<span style="color: #8b2252;">  int b;</span>
<span style="color: #8b2252;">  int c = a;</span>
<span style="color: #8b2252;">}"</span>)

(test get-basic-decls-in-scope
  (is
    (do-get-basic-decls-in-scope *module* <span style="color: #8b2252;">"a"</span> 'var '(<span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"b"</span>))))



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-get-basic-decls-in-scope</span> (module-string name type basic-decl-strings)
  (<span style="color: #a020f0;">let*</span> ((module (set-parents (parse-mcpl module-string)))
         (from-ast (get-ast-form name type module)))
    (null (set-exclusive-or basic-decl-strings
                            (mapcar #'(<span style="color: #a020f0;">lambda</span> (x) (name (get-id x)))
                                    (get-basic-decls-in-scope from-ast))
                            <span style="color: #483d8b;">:test</span> #'string=))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-ast-form</span> (name type module)
  (retrieve-all module #'(<span style="color: #a020f0;">lambda</span> (x)
                           (and (typep x type)
                                (equal (name (get-id x)) name)))))


</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-org1376e6c" class="outline-5">
<h5 id="org1376e6c"><span class="section-number-5">5.1.4.5</span> Builtin functions.</h5>
<div class="outline-text-5" id="text-5-1-4-5">
<p>
The following variable contains the name of the function, the type, and a list
for each parameter and whether it is written (t) or not (nil).
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*specs-builtin-funcs*</span>
  `((<span style="color: #8b2252;">"toFloat"</span> ,(make-flt) (nil))
    (<span style="color: #8b2252;">"toDouble"</span> ,(make-double) (nil))
    (<span style="color: #8b2252;">"mcl_builtin_read"</span> ,(make-void) (nil))
    (<span style="color: #8b2252;">"mcl_builtin_write"</span> ,(make-void) (t))
    (<span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span> ,(make-void) (nil))
    (<span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span> ,(make-void) (t))
    (<span style="color: #8b2252;">"mcl_builtin_allocate_on_device"</span> ,(make-void) (nil))
    (<span style="color: #8b2252;">"mcl_builtin_deallocate_on_device"</span> ,(make-void) (nil))
    (<span style="color: #8b2252;">"min"</span> ,(make-int) (nil))
    (<span style="color: #8b2252;">"max"</span> ,(make-int) (nil))
    (<span style="color: #8b2252;">"divide_up"</span> ,(make-int) (nil))))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*builtin-funcs*</span>
  (mapcar #'first *specs-builtin-funcs*))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">builtin-func-p</span> (function)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether a function is builtin."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">builtin-func-p</span> ((func func))
  (<span style="color: #a020f0;">let</span> ((stat (first (stats (code-block func)))))
    (and stat
         (typep stat 'call-stat)
         (builtin-func-p (call stat)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">builtin-func-p</span> ((call call))
  (builtin-func-p (id call)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">builtin-func-p</span> ((id id))
  (builtin-func-p (name id)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">builtin-func-p</span> ((name-function string))
  (member name-function *builtin-funcs* <span style="color: #483d8b;">:test</span> #'string=))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-type-builtin-func</span> (function)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the type of a builtin function."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type-builtin-func</span> ((name-function string))
  (second (assoc name-function *specs-builtin-funcs* <span style="color: #483d8b;">:test</span> #'string=)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">transfer-p</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether an AST-form a transfer is."</span>))

(def-methods transfer-p ((ast (ast string number symbol list)))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">transfer-p</span> ((cs call-stat))
  (member (name (id (call cs)))
          '(<span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span>
            <span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span>
            <span style="color: #8b2252;">"mcl_builtin_allocate_on_device"</span>
            <span style="color: #8b2252;">"mcl_builtin_deallocate_on_device"</span>)
          <span style="color: #483d8b;">:test</span> #'string=))

</pre>
</div>
</div>
</div>
<div id="outline-container-org93ec0d8" class="outline-5">
<h5 id="org93ec0d8"><span class="section-number-5">5.1.4.6</span> Checking for casting functions</h5>
<div class="outline-text-5" id="text-5-1-4-6">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">cast-func-p</span> (function))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">cast-func-p</span> ((ce call-expr))
  (cast-func-p (call ce)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">cast-func-p</span> ((call call))
  (cast-func-p (id call)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">cast-func-p</span> ((id id))
  (member (name id) '(<span style="color: #8b2252;">"toFloat"</span>) <span style="color: #483d8b;">:test</span> #'string=))
</pre>
</div>
</div>
</div>
<div id="outline-container-org5a67ff5" class="outline-5">
<h5 id="org5a67ff5"><span class="section-number-5">5.1.4.7</span> Parameters and calls</h5>
<div class="outline-text-5" id="text-5-1-4-7">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">param-p</span> (expr-decl-or-var)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether an expression, declaration or variable is </span>
<span style="color: #8b2252;">a parameter.  In case it is a declaration, it will be treated as formal</span>
<span style="color: #8b2252;"> parameter, otherwise, it will be treated as actual parameter."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-p</span> ((ast ast))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-p</span> ((d decl))
  (eq (type-of (parent d)) 'func))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-p</span> ((e expr))
  (eq (type-of (parent e)) 'call))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-p</span> ((v var))
  (param-p (parent v)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-position-in-call</span> (decl-expr-var call)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the position of a declaration, expression or variable</span>
<span style="color: #8b2252;">in a call"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-position-in-call</span> ((decl decl) call)
  (<span style="color: #a020f0;">with-slots</span> (params) call
    (<span style="color: #a020f0;">loop</span>
       for i from 0 below (length params)
       for param in params
       when (typep param 'var-expr)
       when (eq decl (get-decl-var (var param)))
       do (<span style="color: #a020f0;">return</span> i))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">param-call-&gt;param-func</span> (expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-call-&gt;param-func</span> ((expr expr))
  (<span style="color: #a020f0;">let</span> ((call (parent expr)))
    (nth (position expr call) (func call))))
</pre>
</div>

<p>
The following two functions transform decls from the called functions to the
calling function and vice versa.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">decl-called-func-in-calling-func-p</span> (decl-called-func call)
  (<span style="color: #a020f0;">let</span> ((pos (position decl-called-func (params (func call)))))
    (and pos
         (<span style="color: #a020f0;">let</span> ((expr (nth pos (params call))))
           (typep expr 'var-expr)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">decl-called-func-&gt;calling-func</span> (decl-called-func call)
  (<span style="color: #a020f0;">let</span> ((expr (nth (position decl-called-func (params (func call)))
                   (params call))))
    (get-decl-param expr)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">decl-calling-func-in-called-func-p</span> (decl-calling-func call)
  (position decl-calling-func (mapcar #'get-decl-param (params call))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">decl-calling-func-&gt;called-func</span> (decl-calling-func call)
  (nth (position decl-calling-func (mapcar #'get-decl-param (params call)))
       (params (func call))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-decl-param</span> (param))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-decl-param</span> ((param decl))
  param)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-decl-param</span> ((param var-expr))
  (get-decl-param (var param)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-decl-param</span> ((param var))
  (get-decl-var param))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-decl-param</span> ((param expr))
  nil)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-basic-decl-param</span> (param))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl-param</span> ((param basic-decl))
  param)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl-param</span> ((param var-expr))
  (get-basic-decl-param (var param)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl-param</span> ((param var))
  (get-basic-decl-var param))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-basic-decl-param</span> ((param expr))
  nil)
</pre>
</div>


<p>
Whether a call is an expression call or a statement call:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">call-stat-p</span> (call))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">call-stat-p</span> ((call-stat call-stat))
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">call-stat-p</span> ((call-expr call-expr))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">call-stat-p</span> ((stat stat))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">call-stat-p</span> ((call call))
  (call-stat-p (parent call)))


</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">call-expr-p</span> (call))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">call-expr-p</span> ((call-stat call-stat))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">call-expr-p</span> ((call-expr call-expr))
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">call-expr-p</span> ((call call))
  (call-expr-p (parent call)))


</pre>
</div>
</div>
</div>

<div id="outline-container-org17bef02" class="outline-5">
<h5 id="org17bef02"><span class="section-number-5">5.1.4.8</span> Checking whether a parameter is written</h5>
<div class="outline-text-5" id="text-5-1-4-8">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">param-written-p</span> (expr-decl-or-var)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether a param is written. The argument can be</span>
<span style="color: #8b2252;">an expr, decl or var."</span>))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">param-written-builtin-p</span> (func index))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-written-builtin-p</span> ((call call) index)
  (param-written-builtin-p (id call) index))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-written-builtin-p</span> ((id id) index)
  (param-written-builtin-p (name id) index))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-written-builtin-p</span> ((s string) index)
  (nth index (third (assoc s *specs-builtin-funcs*))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-written-p</span> ((e expr))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (param-p e))
  (and (eq (type-of e) 'var-expr)
       (<span style="color: #a020f0;">let</span> ((index (get-index-param e))
             (call (parent e)))
         (<span style="color: #a020f0;">if</span> (builtin-func-p call)
             (param-written-builtin-p call index)
             (param-written-p (nth index (params (func call))))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-written-p</span> ((bd basic-decl))
  (param-written-p (decl bd)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-written-p</span> ((d decl))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (param-p d))
  (written d))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">param-written-p</span> ((v var))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (param-p v))
  (param-written-p (parent v)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc9fd5a5" class="outline-5">
<h5 id="orgc9fd5a5"><span class="section-number-5">5.1.4.9</span> Retrieve the index of parameter</h5>
<div class="outline-text-5" id="text-5-1-4-9">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-index-param</span> (expr-or-decl)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"get the index of the parameter in the parameter list"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-index-param</span> ((e expr))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (param-p e))
  (position e (params (parent e))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-index-param</span> ((d decl))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (param-p d))
  (position d (params (parent d))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org09c2585" class="outline-5">
<h5 id="org09c2585"><span class="section-number-5">5.1.4.10</span> Retrieve the module of an AST form</h5>
<div class="outline-text-5" id="text-5-1-4-10">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-module</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the module of this ast-form if it exists or nil."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-module</span> ((ast ast))
  (get-module (parent ast)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-module</span> ((module module))
  module)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb79a5ba" class="outline-5">
<h5 id="orgb79a5ba"><span class="section-number-5">5.1.4.11</span> Retrieve the enclosing function of an AST form</h5>
<div class="outline-text-5" id="text-5-1-4-11">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-func</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the function of this ast-form if it exists or nil."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-func</span> ((ast ast))
  (get-func (parent ast)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-func</span> ((module module))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-func</span> ((func func))
  func)
</pre>
</div>
</div>
</div>

<div id="outline-container-org772e30d" class="outline-5">
<h5 id="org772e30d"><span class="section-number-5">5.1.4.12</span> Information about expressions</h5>
<div class="outline-text-5" id="text-5-1-4-12">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">binary-p</span> (expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">binary-p</span> ((expr expr))
  (member (type-of expr) '(pow mul div modulo add sub bitshl bitshr lt gt le ge
                           equ ne bitand bitor log-and log-or)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">unary-p</span> (expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">unary-p</span> ((expr expr))
  (member (type-of expr) '(neg minus)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">priority</span> (expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">priority</span> ((expr expr))
  (<span style="color: #a020f0;">etypecase</span> expr
    (minus 40)
    (neg 40)
    (pow 35)
    (mul 30)
    (div 30)
    (modulo 30)
    (add 25)
    (sub 25)
    (bitshl 20)
    (bitshr 20)
    (lt 15)
    (gt 15)
    (le 15)
    (ge 15)
    (equ 10)
    (ne 10)
    (bitand 9)
    (bitor 8)
    (log-and 7)
    (log-or 6)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">left-associative-p</span> (expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">left-associative-p</span> ((expr expr))
  (member (type-of expr) '(mul div add sub modulo)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">right-associative-p</span> (expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">right-associative-p</span> ((expr expr))
  nil)
</pre>
</div>
</div>
</div>

<div id="outline-container-org37ef299" class="outline-5">
<h5 id="org37ef299"><span class="section-number-5">5.1.4.13</span> Checking whether something is constant</h5>
<div class="outline-text-5" id="text-5-1-4-13">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">constant-p</span> (decl)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Check whether a declaration is constant."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">constant-p</span> ((decl decl))
  (find (make-const nil) (modifiers decl) <span style="color: #483d8b;">:test</span> #'ast=))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">constant-p</span> ((var var))
  (constant-p (get-decl-var var)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">constant-p</span> ((e expr))
  (<span style="color: #a020f0;">cond</span> ((unary-p e)
         (constant-p (e e)))
        ((binary-p e)
         (and (constant-p (l e)) (constant-p (r e))))
        ((typep e 'var-expr)
         (constant-p (var e)))
        (t
         t)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">constant-p</span> ((ce call-expr))
  (<span style="color: #a020f0;">if</span> (cast-func-p ce) (constant-p (first (params (call ce)))) nil))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">global-p</span> (decl)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Check whether a declaration is a global declaration."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">global-p</span> ((decl decl))
  (typep (parent decl) 'const-decl))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">global-p</span> ((var var))
  (global-p (get-decl-var var)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4793ef8" class="outline-5">
<h5 id="org4793ef8"><span class="section-number-5">5.1.4.14</span> Getting the base type of an array</h5>
<div class="outline-text-5" id="text-5-1-4-14">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-base-type</span> (type)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Retrieve the base-type of an array."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-base-type</span> ((type mcl-type))
  type)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-base-type</span> ((at array-type))
  (get-base-type (base-type at)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org508e310" class="outline-5">
<h5 id="org508e310"><span class="section-number-5">5.1.4.15</span> Getting the names of memory spaces</h5>
<div class="outline-text-5" id="text-5-1-4-15">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:ast-mcpl</span>)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-memory-spaces-modifier</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the memory spaces in the modifier of the decl that</span>
<span style="color: #8b2252;">belongs to AST form ast."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-memory-spaces-modifier</span> ((decl decl))
  (mapcar #'modifier
          (remove-if (complement #'(<span style="color: #a020f0;">lambda</span> (x) (typep x 'user-defined))) (modifiers decl))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga800058" class="outline-5">
<h5 id="orga800058"><span class="section-number-5">5.1.4.16</span> Whether a memory space is disallowed</h5>
<div class="outline-text-5" id="text-5-1-4-16">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:ast-mcpl</span>)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">memory-space-disallowed</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether a memory space is disallowed for the ast form."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">memory-space-disallowed</span> ((decl decl))
  (and (primitive-decl-p decl) (constant-p decl)))
</pre>
</div>

<p>
Checking whether a memory-space is disallowed in the following functions is
from the perspective of a call:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">memory-space-disallowed</span> ((e expr))
  (<span style="color: #a020f0;">if</span> (typep e 'var-expr)
      (memory-space-disallowed (var e))
      (constant-p e)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">memory-space-disallowed</span> ((v var))
  (memory-space-disallowed (get-decl-var v)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*primitive-types*</span>
  (list (make-int) (make-flt) (make-bool) (make-mcl-byte) (make-double)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">primitive-decl-p</span> (decl)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether a decl or var is primitive."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">primitive-decl-p</span> ((decl decl))
  (primitive-type-p (get-type-decl decl)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">primitive-decl-p</span> ((bd basic-decl))
  (primitive-type-p (mcl-type bd)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">primitive-type-p</span> (type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">primitive-type-p</span> ((type mcl-type))
  (find type *primitive-types* <span style="color: #483d8b;">:test</span> #'ast=))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-type-decl</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the type of a declaration form"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type-decl</span> ((decl decl))
  (get-type-decl (get-basic-decl decl)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type-decl</span> ((basic-decl basic-decl))
  (mcl-type basic-decl))
</pre>
</div>
</div>
</div>

<div id="outline-container-org20c17a3" class="outline-5">
<h5 id="org20c17a3"><span class="section-number-5">5.1.4.17</span> Whether an AST is in a foreach</h5>
<div class="outline-text-5" id="text-5-1-4-17">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">in-foreach-p</span> (ast)
  (<span style="color: #a020f0;">let</span> ((parent (parent ast)))
    (<span style="color: #a020f0;">if</span> (or (null parent) (typep parent 'func))
        nil
        (or (typep parent 'foreach-stat) (in-foreach-p parent)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">top-level-foreach-p</span> (ast)
  (and (typep ast 'foreach-stat)
       (not (in-foreach-p ast))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">inner-foreach-p</span> (ast)
  (and (typep ast 'foreach-stat)
       (null (remove-if (complement #'(<span style="color: #a020f0;">lambda</span> (x) (typep x 'foreach-stat)))
                     (stats (code-block (stat ast)))))))

</pre>
</div>
</div>
</div>

<div id="outline-container-org8370207" class="outline-5">
<h5 id="org8370207"><span class="section-number-5">5.1.4.18</span> Typedef variables and declarations</h5>
<div class="outline-text-5" id="text-5-1-4-18">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">typedef-var-p</span> (var)
  (typedef-decl-p (get-decl-var var)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">typedef-decl-p</span> (decl)
  (typep (parent decl) 'typedef))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a971a4" class="outline-5">
<h5 id="org9a971a4"><span class="section-number-5">5.1.4.19</span> Global constants</h5>
<div class="outline-text-5" id="text-5-1-4-19">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">global-constant-p</span> (var-expr-or-decl)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether a variable, expression, or declaration is a</span>
<span style="color: #8b2252;"> global constant."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">global-constant-p</span> ((var var))
  (global-constant-p (get-decl-var var)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">global-constant-p</span> ((decl decl))
  (typep (parent decl) 'const-decl))
</pre>
</div>
</div>
</div>

<div id="outline-container-org693f024" class="outline-5">
<h5 id="org693f024"><span class="section-number-5">5.1.4.20</span> Whether functions exist</h5>
<div class="outline-text-5" id="text-5-1-4-20">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">func-exists-p</span> (func ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Whether a function exists in the module of ast"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">func-exists-p</span> ((name-func string) (code code))
  (member name-func (funcs code) <span style="color: #483d8b;">:key</span> (compose #'name #'id) <span style="color: #483d8b;">:test</span> #'string=))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">func-exists-p</span> (func (module module))
  (func-exists-p func (code module)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">func-exists-p</span> (func (ast ast))
  (func-exists-p func (parent ast)))
</pre>
</div>
</div>
</div>



<div id="outline-container-org126856c" class="outline-5">
<h5 id="org126856c"><span class="section-number-5">5.1.4.21</span> Ancestors</h5>
<div class="outline-text-5" id="text-5-1-4-21">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">ancestors-match</span> (ast ancestors)
  (<span style="color: #a020f0;">if</span> (null ancestors)
      t
      (<span style="color: #a020f0;">let</span> ((parent (parent ast)))
        (<span style="color: #a020f0;">destructuring-bind</span> (f <span style="color: #228b22;">&amp;rest</span> r) ancestors
          (and parent (typep parent f) (ancestors-match parent r))))))
</pre>
</div>
</div>
</div>
</div>
</div>



<div id="outline-container-orge0ad2ee" class="outline-3">
<h3 id="orge0ad2ee"><span class="section-number-3">5.2</span> The parser</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-org47e8b18" class="outline-4">
<h4 id="org47e8b18"><span class="section-number-4">5.2.1</span> The parser</h4>
<div class="outline-text-4" id="text-5-2-1">
</div>
<div id="outline-container-org186d843" class="outline-5">
<h5 id="org186d843"><span class="section-number-5">5.2.1.1</span> the package</h5>
<div class="outline-text-5" id="text-5-2-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:parse-mcpl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:esrap</span> <span style="color: #483d8b;">:parser.common-rules</span>
        <span style="color: #483d8b;">:parser.common-rules.operators</span> <span style="color: #483d8b;">:parsing</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:read-file-into-string</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:parse-mcpl-expr</span> <span style="color: #483d8b;">:parse-mcpl-file</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc2a52f3" class="outline-5">
<h5 id="orgc2a52f3"><span class="section-number-5">5.2.1.2</span> top-level</h5>
<div class="outline-text-5" id="text-5-2-1-2">
<p>
An MCL file is a contains a module with a package declaration.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*keywords*</span> '(<span style="color: #8b2252;">"package"</span> <span style="color: #8b2252;">"module"</span> <span style="color: #8b2252;">"export"</span> <span style="color: #8b2252;">"import"</span> <span style="color: #8b2252;">"type"</span> <span style="color: #8b2252;">"void"</span> <span style="color: #8b2252;">"int"</span>
                           <span style="color: #8b2252;">"double"</span> <span style="color: #8b2252;">"float"</span> <span style="color: #8b2252;">"byte"</span> <span style="color: #8b2252;">"bool"</span> <span style="color: #8b2252;">"as"</span> <span style="color: #8b2252;">"return"</span>
                           <span style="color: #8b2252;">"foreach"</span> <span style="color: #8b2252;">"barrier"</span> <span style="color: #8b2252;">"in"</span> <span style="color: #8b2252;">"if"</span> <span style="color: #8b2252;">"else"</span> <span style="color: #8b2252;">"const"</span>
                           <span style="color: #8b2252;">"for"</span>))

(defrule skippable (+  (or whitespace
                           c-style-comment/rest-of-line
                           c-style-comment/delimited)))

(defrule skippable? (* (or whitespace
                          c-style-comment/rest-of-line
                          c-style-comment/delimited)))


(defrule module (and skippable? package-kw/?s qual-id/?s semi-colon/?s
                       module-kw/?s id/?s semi-colon/?s
                       module-exports/?s
                       lib-imports/?s
                       code/?s)
  (<span style="color: #483d8b;">:destructure</span> (skippable
                 package-kw qual-id semi-colon
                 module-kw id semi-colon2
                 exports
                 imports
                 code)
                (<span style="color: #a020f0;">declare</span> (ignore skippable package-kw semi-colon semi-colon2))
                (make-module qual-id id exports imports code module-kw)))

(defrule/s module-exports (? (and export-kw/?s module-exports-1/?s semi-colon/?s))
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s module-exports-1 (and module-export (* comma-module-export))
  (<span style="color: #483d8b;">:destructure</span> (module-export <span style="color: #228b22;">&amp;optional</span> other-module-exports)
                (<span style="color: #a020f0;">if</span> other-module-exports
                    (cons module-export other-module-exports)
                    (list module-export))))

(defrule/s comma-module-export (and comma/?s module-export)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s module-export (or id camel-id caps-id))

(defrule/s lib-imports (* lib-import/?s))

(defrule/s lib-import (and import-kw/?s qual-id/?s semi-colon/?s)
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-lib-import (second result) (make-loc start end))))

(defrule/s code (and top-decls/?s funcs/?s)
  (<span style="color: #483d8b;">:destructure</span> (top-decls funcs) (make-code top-decls funcs nil)))

</pre>
</div>
</div>
</div>

<div id="outline-container-org71c93a3" class="outline-5">
<h5 id="org71c93a3"><span class="section-number-5">5.2.1.3</span> top declarations</h5>
<div class="outline-text-5" id="text-5-2-1-3">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s top-decls (* top-decl/?s))

(defrule/s top-decl (or const-decl typedef))

(defrule/s const-decl (and const-kw/?s type/?s caps-id/?s equals/?s exp/?s semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (const type id eq expr sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore eq sc))
                (make-const-decl
                 (make-assign-decl
                  (list const)
                  (make-basic-decl type id (location id))
                  expr
                  (location id))
                 (make-loc start end))))

(defrule/s typedef (and type-kw/?s camel-id/?s (? formal-params/?s) block-open/?s
                        (* decl-separated/?s)
                        block-close/?s)
  (<span style="color: #483d8b;">:destructure</span> (kw id params bo decls bc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore kw bo bc))
                (make-typedef id params decls (make-loc start end))))

(defrule/s decl-separated (and decl/?s semi-colon/?s)
  (<span style="color: #483d8b;">:function</span> first))

</pre>
</div>
</div>
</div>



<div id="outline-container-org127da4d" class="outline-5">
<h5 id="org127da4d"><span class="section-number-5">5.2.1.4</span> functions</h5>
<div class="outline-text-5" id="text-5-2-1-4">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s funcs (* func/?s))

(defrule/s func (and id/?s type/?s id/?s formal-params/?s block/?s)
  (<span style="color: #483d8b;">:destructure</span> (hw-desc mcl-type id-func params block)
                (make-func hw-desc mcl-type id-func params block (location hw-desc))))

(defrule/s formal-params (and parenthesis-open/?s
                              decl-comma-separated/?s
                              parenthesis-close/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s decl-comma-separated (? (and decl/?s (* comma-decl/?s)))
  (<span style="color: #483d8b;">:destructure</span> (<span style="color: #228b22;">&amp;optional</span> decl other-decls)
                (<span style="color: #a020f0;">if</span> decl
                    (<span style="color: #a020f0;">if</span> other-decls
                        (cons decl other-decls)
                        (list decl))
                    nil)))

(defrule/s comma-decl (and comma/?s decl/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s block
    (and block-open/?s stats/?s block-close/?s)
  (<span style="color: #483d8b;">:destructure</span> (open stats close <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore open close))
                (make-code-block stats (make-loc start end))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org0136625" class="outline-5">
<h5 id="org0136625"><span class="section-number-5">5.2.1.5</span> Statements</h5>
<div class="outline-text-5" id="text-5-2-1-5">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s stats (* stat))

(defrule/s stat (or block-stat
                    barrier-stat
                    foreach-stat
                    for-stat
                    if-stat
                    return-stat
                    call-stat
                    assign-stat
                    as-stat
                    inc-stat
                    decl-stat
                    swap-stat))

(defrule/s block-stat block
  (<span style="color: #483d8b;">:lambda</span> (b <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-block-stat b (make-loc start end))))

(defrule/s foreach-stat (and foreach-kw/?s parenthesis-open/?s decl/?s in-kw/?s exp/?s id/?s parenthesis-close/?s stat/?s)
  (<span style="color: #483d8b;">:destructure</span> (kw po decl in exp id pc stat <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore kw po in pc))
                (make-foreach-stat decl exp id stat (make-loc start end))))

(defrule/s for-stat (and for-kw/?s parenthesis-open/?s decl/?s semi-colon/?s exp/?s semi-colon/?s inc/?s parenthesis-close/?s stat/?s)
  (<span style="color: #483d8b;">:destructure</span> (kw po decl sc1 cond-expr sc2 inc pc stat <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore kw po sc1 sc2 pc))
                (make-for-stat decl cond-expr inc stat (make-loc start end))))

(defrule/s return-stat (and return-kw/?s exp/?s semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (kw exp semi-colon <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore kw semi-colon))
                (make-return-stat exp (make-loc start end))))

(defrule/s if-stat (and if-kw/?s parenthesis-open/?s exp parenthesis-close/?s stat/?s
                        (? (and else-kw/?s stat/?s)))
  (<span style="color: #483d8b;">:destructure</span> (kw po cond-expr pc stat <span style="color: #228b22;">&amp;optional</span> else <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore kw po pc))
                (make-if-stat cond-expr stat (second else) (make-loc start end))))

(defrule/s barrier-stat (and barrier-kw/?s parenthesis-open/?s id/?s parenthesis-close/?s semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (kw po id pc sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore kw po pc sc))
                (make-barrier-stat id (make-loc start end))))

(defrule/s decl-stat (and decl/?s semi-colon/?s)
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-decl-stat (first result) (make-loc start end))))

(defrule/s assign-stat (and var/?s equals/?s  exp/?s semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (var eq expr sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore eq sc))
                (make-assign-stat var expr (make-loc start end))))

(defrule/s as-stat (and var/?s as-kw/?s basic-decl/?s (* as-decl/?s) semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (var as-kw bd as-decls sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore as-kw sc))
                (make-as-stat var (cons bd as-decls) (make-loc start end))))

(defrule/s call-stat (and call/?s semi-colon/?s)
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-call-stat (first result) (make-loc start end))))

(defrule/s inc-stat (and inc/?s semi-colon/?s)
  (<span style="color: #483d8b;">:lambda</span> (result <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-inc-stat (first result) (make-loc start end))))

(defrule/s swap-stat (and var/?s swap-op/?s var semi-colon/?s)
  (<span style="color: #483d8b;">:destructure</span> (var-left sw var-right sc <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore sw sc))
                (make-swap-stat var-left var-right (make-loc start end))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(defrule/s call (and qual-id actual-params-0)
  (<span style="color: #483d8b;">:destructure</span> (id params <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-call id params (make-loc start end))))

(defrule/s actual-params-0 (and parenthesis-open/?s exp-comma-separated-0/?s parenthesis-close/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s actual-params-1 (and parenthesis-open/?s exp-comma-separated-1/?s parenthesis-close/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s inc (or incr/?s decr/?s step/?s))

(defrule/s incr (and var incr-op/?s)
  (<span style="color: #483d8b;">:lambda</span> (r <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-inc (first r) t (make-loc start end))))

(defrule/s decr (and var decr-op/?s)
  (<span style="color: #483d8b;">:lambda</span> (r <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-inc (first r) nil (make-loc start end))))

(defrule/s step (and var/?s step-op/?s exp/?s)
  (<span style="color: #483d8b;">:destructure</span> (v op exp)
                (make-inc-step v op exp)))

(defrule/s step-op (or step-add step-sub step-mul step-div step-bitshr))
</pre>
</div>
</div>
</div>


<div id="outline-container-org8655500" class="outline-5">
<h5 id="org8655500"><span class="section-number-5">5.2.1.6</span> declarations</h5>
<div class="outline-text-5" id="text-5-2-1-6">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s decl (or assign-decl/?s normal-decl/?s))

(defrule/s assign-decl (and modifiers/?s basic-decl/?s equals/?s exp/?s)
  (<span style="color: #483d8b;">:destructure</span> (modifiers basic-decl equals exp)
                (<span style="color: #a020f0;">declare</span> (ignore equals))
                (make-assign-decl modifiers basic-decl exp)))

(defrule/s normal-decl (and modifiers/?s basic-decl/?s (* as-decl))
  (<span style="color: #483d8b;">:destructure</span> (modifiers basic-decl as-basic-decls <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-normal-decl modifiers (cons basic-decl as-basic-decls) (make-loc start end))))

(defrule/s as-decl (and as-kw/s basic-decl/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s modifiers (* modifier/s))

(defrule/s modifier (or const-kw user-defined-modifier))

(defrule/s user-defined-modifier (and id (! dot))
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">we have to add here that id is not followed by a dot.  Otherwise we cannot</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">parse a qualified custom type.</span>
  (<span style="color: #483d8b;">:destructure</span> (id not-followed-by-dot <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore not-followed-by-dot))
                (make-user-defined id (make-loc start end))))

(defrule/s basic-decl (and type/?s id/?s)
  (<span style="color: #483d8b;">:destructure</span> (type id <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-basic-decl type id (make-loc start end))))

</pre>
</div>
</div>
</div>

<div id="outline-container-org8b3378a" class="outline-5">
<h5 id="org8b3378a"><span class="section-number-5">5.2.1.7</span> types</h5>
<div class="outline-text-5" id="text-5-2-1-7">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s type (and basic-type/?s (* array/?s))
  (<span style="color: #483d8b;">:destructure</span> (bt sizes)
                (do-type bt sizes)))

(defrule/s basic-type (or void int float double byte bool custom-type))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">type-literal</span> (type-string <span style="color: #228b22;">&amp;optional</span> make-func)
  (<span style="color: #a020f0;">let</span> ((rule-sym (intern (string-upcase type-string)))
        (make-sym (intern (format nil <span style="color: #8b2252;">"MAKE-~a"</span> (string-upcase (<span style="color: #a020f0;">if</span> make-func make-func type-string))))))
    (alexandria:with-gensyms (item start end)
      `(defrule ,rule-sym (and ,type-string (! (character-ranges (#\a #\z))))
         (<span style="color: #483d8b;">:lambda</span> (,item <span style="color: #228b22;">&amp;bounds</span> ,start ,end)
           (<span style="color: #a020f0;">declare</span> (ignore ,item))
           (,make-sym (make-loc ,start ,end)))))))

(type-literal <span style="color: #8b2252;">"void"</span>)
(type-literal <span style="color: #8b2252;">"int"</span>)
(type-literal <span style="color: #8b2252;">"float"</span> <span style="color: #8b2252;">"flt"</span>)
(type-literal <span style="color: #8b2252;">"double"</span>)
(type-literal <span style="color: #8b2252;">"byte"</span> <span style="color: #8b2252;">"mcl-byte"</span>)
(type-literal <span style="color: #8b2252;">"bool"</span>)

(defrule/s custom-type (and qual-camel-id/?s (? actual-params-1/?s))
  (<span style="color: #483d8b;">:destructure</span> (id <span style="color: #228b22;">&amp;optional</span> params <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-custom-type id params (make-loc start end))))

(defrule/s array (and bracket-open/?s array-sizes-1/?s bracket-close/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s array-sizes-1 (and array-size/?s (* comma-array-size/?s))
  (<span style="color: #483d8b;">:destructure</span> (array-size <span style="color: #228b22;">&amp;optional</span> other-array-sizes)
                (<span style="color: #a020f0;">if</span> other-array-sizes
                    (cons array-size other-array-sizes)
                    (list array-size))))

(defrule/s comma-array-size (and comma/?s array-size/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s array-size exp
  (<span style="color: #483d8b;">:lambda</span> (e <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-decl-array-size e nil (make-loc start end))))
</pre>
</div>
</div>
</div>




<div id="outline-container-orgd3f9f3c" class="outline-5">
<h5 id="orgd3f9f3c"><span class="section-number-5">5.2.1.8</span> expressions</h5>
<div class="outline-text-5" id="text-5-2-1-8">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s exp logic-or/?s)

(defrule/s logic-or (and logic-and/?s (* (and logic-or-op/?s logic-and/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s logic-and (and bit-or/?s (* (and logic-and-op/?s bit-or/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s bit-or (and bit-and/?s (* (and bitwise-or-op/?s bit-and/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s bit-and (and equality/?s (* (and bitwise-and-op/?s equality/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s equality (and logic-cmp/?s (? (and equality-op/?s logic-cmp/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-non-assoc exp op-exp-list)))

(defrule/s equality-op (or equals-op/?s not-equals-op/?s))

(defrule/s logic-cmp (and bitsh/?s (? (and logic-cmp-op/?s bitsh/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-non-assoc exp op-exp-list)))

(defrule/s logic-cmp-op (or le-op/?s ge-op/?s lt-op/?s gt-op/?s))

(defrule/s bitsh (and term/?s (* (and bitsh-op/?s term/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s bitsh-op (or bitshl-op/?s bitshr-op/?s))

(defrule/s term (and factor/?s (* (and term-op/?s factor/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s term-op (or add-op/?s minus-op/?s))

(defrule/s factor (and power/?s (* (and factor-op/?s power/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-left-assoc exp op-exp-list)))

(defrule/s factor-op/?s (or mul-op/?s div-op/?s mod-op/?s))

(defrule/s power (and unary/?s (* (and pow-op/?s unary/?s)))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> op-exp-list)
                (do-right-assoc exp op-exp-list)))

(defrule/s unary (or minus/?s negate/?s atom/?s))

(defrule/s minus/?s (and minus-op/?s atom/?s)
  (<span style="color: #483d8b;">:destructure</span> (minus atom <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore minus))
                (make-minus atom (make-loc start end))))

(defrule/s negate/?s (and neg-op/?s atom/?s)
  (<span style="color: #483d8b;">:destructure</span> (neg atom <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">declare</span> (ignore neg))
                (make-neg atom (make-loc start end))))

(defrule/s atom (or call-exp/?s var-exp/?s float-lit/?s int-lit/?s parenthesized-exp/?s))

(defrule/s call-exp call/?s
  (<span style="color: #483d8b;">:lambda</span> (c <span style="color: #228b22;">&amp;bounds</span> start end) (make-call-expr c (make-loc start end))))

(defrule/s var-exp var/?s
  (<span style="color: #483d8b;">:lambda</span> (v <span style="color: #228b22;">&amp;bounds</span> start end) (make-var-expr v (make-loc start end))))

(defrule/s parenthesized-exp (and parenthesis-open/?s exp/?s parenthesis-close/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s int-lit integer-literal
  (<span style="color: #483d8b;">:lambda</span> (int <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-int-constant int (make-loc start end))))

(defrule/s float-lit single-float-literal
  (<span style="color: #483d8b;">:lambda</span> (f <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-float-constant f (make-loc start end))))
</pre>
</div>
</div>
</div>




<div id="outline-container-orga98765d" class="outline-5">
<h5 id="orga98765d"><span class="section-number-5">5.2.1.9</span> variables</h5>
<div class="outline-text-5" id="text-5-2-1-9">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s var (and basic-var/?s (? dot-part/?s))
  (<span style="color: #483d8b;">:destructure</span> (bv <span style="color: #228b22;">&amp;optional</span> v <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">if</span> v
                    (make-dot-var bv v (make-loc start end))
                    (make-normal-var bv (make-loc start end)))))

(defrule/s dot-part (and dot/?s var/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s basic-var (and id-possibly-capitalized/?s (* array-exp/?s))
  (<span style="color: #483d8b;">:destructure</span> (id <span style="color: #228b22;">&amp;optional</span> array-exps <span style="color: #228b22;">&amp;bounds</span> start end)
                (make-basic-var id array-exps (make-loc start end))))


(defrule/s array-exp (and bracket-open/?s exp-comma-separated-1/?s bracket-close/?s)
  (<span style="color: #483d8b;">:function</span> second))

(defrule/s exp-comma-separated-1 (and exp/?s (* comma-exp/?s))
  (<span style="color: #483d8b;">:destructure</span> (exp <span style="color: #228b22;">&amp;optional</span> other-exps)
                (<span style="color: #a020f0;">if</span> other-exps
                    (cons exp other-exps)
                    (list exp))))

(defrule/s exp-comma-separated-0 (? (and exp/?s (* comma-exp/?s)))
  (<span style="color: #483d8b;">:destructure</span> (<span style="color: #228b22;">&amp;optional</span> exp other-exps)
                (<span style="color: #a020f0;">if</span> exp
                    (<span style="color: #a020f0;">if</span> other-exps
                        (cons exp other-exps)
                        (list exp))
                    nil)))

(defrule/s comma-exp (and comma/?s exp/?s)
  (<span style="color: #483d8b;">:function</span> second))
</pre>
</div>
</div>
</div>



<div id="outline-container-orgf54647e" class="outline-5">
<h5 id="orgf54647e"><span class="section-number-5">5.2.1.10</span> identifiers</h5>
<div class="outline-text-5" id="text-5-2-1-10">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">not-keyword-p</span> (id)
  (not (member id *keywords* <span style="color: #483d8b;">:test</span> #'string=)))

(defrule/s id (not-keyword-p identifier)
  (<span style="color: #483d8b;">:lambda</span> (name <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-id name (make-loc start end))))

(defrule/s qual-id (and id (? (and #\. qual-id)))
  (<span style="color: #483d8b;">:destructure</span> (before-dot dot-part <span style="color: #228b22;">&amp;bounds</span> start end)
                (<span style="color: #a020f0;">if</span> dot-part
                    (make-compound-id (name before-dot) (second dot-part) (make-loc start end))
                    before-dot)))

(defrule/s id-possibly-capitalized (or id caps-id))

(defrule/s caps-id (and (character-ranges (#\A #\Z))
                        (* (or (character-ranges (#\A #\Z) (#\0 #\9))
                               #\_)))
  (<span style="color: #483d8b;">:text</span> t)
  (<span style="color: #483d8b;">:lambda</span> (name <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-id name (make-loc start end))))

(defrule/s qual-camel-id (or camel-id dot-camel-id))

(defrule/s camel-id (and (character-ranges (#\A #\Z))
                         (character-ranges (#\a #\z))
                         (* (character-ranges (#\a #\z) (#\A #\Z) (#\0 #\9))))
  (<span style="color: #483d8b;">:text</span> t)
  (<span style="color: #483d8b;">:lambda</span> (name <span style="color: #228b22;">&amp;bounds</span> start end)
    (make-id name (make-loc start end))))

(defrule/s dot-camel-id (and qual-id dot camel-id)
  (<span style="color: #483d8b;">:destructure</span> (qual-id dot camel-id)
                (<span style="color: #a020f0;">declare</span> (ignore dot))
                (make-camel-compound-id qual-id camel-id)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org460676c" class="outline-5">
<h5 id="org460676c"><span class="section-number-5">5.2.1.11</span> keywords</h5>
<div class="outline-text-5" id="text-5-2-1-11">
<div class="org-src-container">
<pre class="src src-lisp">(defkw <span style="color: #8b2252;">"package"</span>)
(defkw <span style="color: #8b2252;">"module"</span>
  (<span style="color: #483d8b;">:lambda</span> (kw <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore kw))
    (make-loc start end)))
(defkw <span style="color: #8b2252;">"export"</span>)
(defkw <span style="color: #8b2252;">"import"</span>)
(defkw <span style="color: #8b2252;">"type"</span>)
(defkw <span style="color: #8b2252;">"as"</span>)
(defkw <span style="color: #8b2252;">"return"</span>)
(defkw <span style="color: #8b2252;">"foreach"</span>)
(defkw <span style="color: #8b2252;">"barrier"</span>)
(defkw <span style="color: #8b2252;">"in"</span>)
(defkw <span style="color: #8b2252;">"if"</span>)
(defkw <span style="color: #8b2252;">"else"</span>)
(defkw <span style="color: #8b2252;">"const"</span>
  (<span style="color: #483d8b;">:lambda</span> (item <span style="color: #228b22;">&amp;bounds</span> start end)
    (<span style="color: #a020f0;">declare</span> (ignore item))
    (make-const (make-loc start end))))
(defkw <span style="color: #8b2252;">"for"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgac7623a" class="outline-5">
<h5 id="orgac7623a"><span class="section-number-5">5.2.1.12</span> tokens</h5>
<div class="outline-text-5" id="text-5-2-1-12">
<div class="org-src-container">
<pre class="src src-lisp">(defrule/s logic-or-op <span style="color: #8b2252;">"||"</span>
  (<span style="color: #483d8b;">:constant</span> #'make-log-or))
(defrule/s logic-and-op <span style="color: #8b2252;">"&amp;&amp;"</span>
  (<span style="color: #483d8b;">:constant</span> #'make-log-and))
(defrule/s bitwise-or-op <span style="color: #8b2252;">"|"</span>
  (<span style="color: #483d8b;">:constant</span> #'make-bitor))
(defrule/s bitwise-and-op <span style="color: #8b2252;">"&amp;"</span>
  (<span style="color: #483d8b;">:constant</span> #'make-bitand))
(defrule/s equals-op <span style="color: #8b2252;">"=="</span>
  (<span style="color: #483d8b;">:constant</span> #'make-equ))
(defrule/s not-equals-op <span style="color: #8b2252;">"!="</span>
  (<span style="color: #483d8b;">:constant</span> #'make-ne))
(defrule/s lt-op #\&lt;
  (<span style="color: #483d8b;">:constant</span> #'make-lt))
(defrule/s gt-op #\&gt;
  (<span style="color: #483d8b;">:constant</span> #'make-gt))
(defrule/s le-op <span style="color: #8b2252;">"&lt;="</span>
  (<span style="color: #483d8b;">:constant</span> #'make-le))
(defrule/s ge-op <span style="color: #8b2252;">"&gt;="</span>
  (<span style="color: #483d8b;">:constant</span> #'make-ge))
(defrule/s bitshl-op <span style="color: #8b2252;">"&lt;&lt;"</span>
  (<span style="color: #483d8b;">:constant</span> #'make-bitshl))
(defrule/s bitshr-op <span style="color: #8b2252;">"&gt;&gt;"</span>
  (<span style="color: #483d8b;">:constant</span> #'make-bitshr))
(defrule/s add-op #\+
  (<span style="color: #483d8b;">:constant</span> #'make-add))
(defrule/s minus-op #\-
  (<span style="color: #483d8b;">:constant</span> #'make-sub))
(defrule/s mul-op #\*
  (<span style="color: #483d8b;">:constant</span> #'make-mul))
(defrule/s div-op #\/
  (<span style="color: #483d8b;">:constant</span> #'make-div))
(defrule/s mod-op #\%
  (<span style="color: #483d8b;">:constant</span> #'make-modulo))
(defrule/s pow-op #\^
  (<span style="color: #483d8b;">:constant</span> #'make-pow))
(defrule/s neg-op #\!)

(defrule/s incr-op <span style="color: #8b2252;">"++"</span>)
(defrule/s decr-op <span style="color: #8b2252;">"--"</span>)
(defrule/s step-add <span style="color: #8b2252;">"+="</span>)
(defrule/s step-sub <span style="color: #8b2252;">"+="</span>)
(defrule/s step-mul <span style="color: #8b2252;">"*="</span>)
(defrule/s step-div <span style="color: #8b2252;">"/="</span>)
(defrule/s step-bitshr <span style="color: #8b2252;">"&gt;&gt;="</span>)

(defrule/s swap-op <span style="color: #8b2252;">"&lt;=&gt;"</span>)
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb7af9a3" class="outline-5">
<h5 id="orgb7af9a3"><span class="section-number-5">5.2.1.13</span> utility functions</h5>
<div class="outline-text-5" id="text-5-2-1-13">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-mcpl-expr</span> (expr)
  (parse 'exp expr))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-mcpl</span> (string)
  (parse 'module string))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-mcpl-file</span> (filename)
  (<span style="color: #a020f0;">let</span> ((*filename* filename))
    (<span style="color: #a020f0;">let</span> ((file-as-string (read-file-into-string *filename*)))
      (<span style="color: #a020f0;">handler-case</span> (parse-mcpl file-as-string)
        (esrap-parse-error (e)
          (<span style="color: #a020f0;">let</span> ((position (esrap-error-position e)))
            (errors:parse-mcpl-error
             (list (cons position (1+ position))
                   filename)
             (format nil <span style="color: #8b2252;">"~a"</span> e))))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0675cf7" class="outline-5">
<h5 id="org0675cf7"><span class="section-number-5">5.2.1.14</span> library</h5>
<div class="outline-text-5" id="text-5-2-1-14">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-type</span> (bt sizes)
  (<span style="color: #a020f0;">if</span> (null sizes)
    bt
    (make-array-type (do-type bt (cdr sizes)) (car sizes) (location bt))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">make-camel-compound-id</span> (compound-id camel-id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">make-camel-compound-id</span> ((id ast-mcpl:id) camel-id)
  (<span style="color: #a020f0;">with-slots</span> (name location) id
    (make-compound-id name camel-id location)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">make-camel-compound-id</span> ((ci compound-id) camel-id)
  (<span style="color: #a020f0;">with-slots</span> (name compound location) ci
    (make-compound-id name (make-camel-compound-id compound camel-id) location)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org862c636" class="outline-4">
<h4 id="org862c636"><span class="section-number-4">5.2.2</span> Testing the parser</h4>
<div class="outline-text-4" id="text-5-2-2">
</div>
<div id="outline-container-org4e0a4be" class="outline-5">
<h5 id="org4e0a4be"><span class="section-number-5">5.2.2.1</span> The package</h5>
<div class="outline-text-5" id="text-5-2-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-parse-mcpl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-parse-mcpl</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org41608c2" class="outline-5">
<h5 id="org41608c2"><span class="section-number-5">5.2.2.2</span> top-level</h5>
<div class="outline-text-5" id="text-5-2-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite parse-mcpl <span style="color: #483d8b;">:in</span> mcl-test-suite)

(in-suite parse-mcpl)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(test minimal-module
  (<span style="color: #a020f0;">let</span> ((ast (module-for-decls nil)))
    (is (ast= ast
              (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                    module a;</span>
<span style="color: #8b2252;">                    perfect void f() {</span>
<span style="color: #8b2252;">                    }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8513675" class="outline-5">
<h5 id="org8513675"><span class="section-number-5">5.2.2.3</span> minimal module</h5>
<div class="outline-text-5" id="text-5-2-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(test minimal-module 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-decls nil)))
    (is
      (ast= ast
            (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                    module a;</span>
<span style="color: #8b2252;">                    perfect void f() {</span>
<span style="color: #8b2252;">                    }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaeedae3" class="outline-5">
<h5 id="orgaeedae3"><span class="section-number-5">5.2.2.4</span> declarations</h5>
<div class="outline-text-5" id="text-5-2-2-4">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite decls <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite decls)

(test function-with-one-param
  (<span style="color: #a020f0;">let</span> ((ast (module-for-decls (list (make-normal-decl
                             nil 
                             (list (make-basic-decl 
                                     (make-int nil)
                                     (make-id <span style="color: #8b2252;">"a"</span> nil)
                                     nil))
                             nil)))))
    (is
      (ast= ast
            (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                    module a;</span>
<span style="color: #8b2252;">                    perfect void f(int a) {</span>
<span style="color: #8b2252;">                    }"</span>)))))


(test function-with-as-param
  (<span style="color: #a020f0;">let</span> ((ast (module-for-decls (list (make-normal-decl
                                   nil 
                                   (list (make-basic-decl 
                                           (make-int nil)
                                           (make-id <span style="color: #8b2252;">"a"</span> nil)
                                           nil)
                                         (make-basic-decl 
                                           (make-int nil)
                                           (make-id <span style="color: #8b2252;">"b"</span> nil)
                                           nil))
                                   nil)))))
    (is
      (ast= ast
            (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                    module a;</span>
<span style="color: #8b2252;">                    perfect void f(int a as int b) {</span>
<span style="color: #8b2252;">                    }"</span>)))))


(test function-with-params 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-decls (list (make-normal-decl
                                   nil 
                                   (list (make-basic-decl 
                                           (make-int nil)
                                           (make-id <span style="color: #8b2252;">"a"</span> nil)
                                           nil))
                                   nil)
                                 (make-normal-decl
                                   nil
                                   (list (make-basic-decl 
                                           (make-int nil)
                                           (make-id <span style="color: #8b2252;">"b"</span> nil)
                                           nil))
                                   nil)))))
    (is
      (ast= ast
            (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                    module a;</span>
<span style="color: #8b2252;">                    perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                    }"</span>)))))

(test function-with-const-param 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-decls (list (make-normal-decl
                                   (list (make-const nil))
                                   (list (make-basic-decl 
                                           (make-int nil)
                                           (make-id <span style="color: #8b2252;">"a"</span> nil)
                                           nil))
                                   nil)))))
    (is
      (ast= ast
            (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                    module a;</span>
<span style="color: #8b2252;">                    perfect void f(const int a) {</span>
<span style="color: #8b2252;">                    }"</span>)))))

(test function-with-modifiers-param 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-decls (list (make-normal-decl
                                   (list (make-const nil) 
                                         (make-user-defined 
                                           (make-id <span style="color: #8b2252;">"shared"</span> nil) nil))
                                   (list (make-basic-decl 
                                           (make-int nil)
                                           (make-id <span style="color: #8b2252;">"a"</span> nil)
                                           nil))
                                   nil)))))
    (is
      (ast= ast
            (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                    module a;</span>
<span style="color: #8b2252;">                    perfect void f(const shared int a) {</span>
<span style="color: #8b2252;">                    }"</span>)))))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb9dc689" class="outline-5">
<h5 id="orgb9dc689"><span class="section-number-5">5.2.2.5</span> expresssions</h5>
<div class="outline-text-5" id="text-5-2-2-5">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite exprs <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite exprs)

(test int-constant 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr (make-int-constant 1 nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = 1) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test add 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-add 
                 (make-int-constant 1 nil)
                 (make-int-constant 1 nil)
                 nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = 1 + 1) {</span>
<span style="color: #8b2252;">                        }"</span>)))))


(test multiple-add 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
              (make-sub
               (make-add 
                 (make-int-constant 1 nil)
                 (make-int-constant 2 nil))
               (make-int-constant 3 nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = 1 + 2 - 3) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test mul-add 
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-add 
                 (make-int-constant 1 nil)
                 (make-mul 
                   (make-int-constant 2 nil)
                   (make-int-constant 3 nil)
                   nil)
                 nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = 1 + 2 * 3) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test mul-add-var
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-add 
                 (make-int-constant 1 nil)
                 (make-mul 
                   (make-int-constant 2 nil)
                   (make-var-expr (make-normal-var (make-basic-var (make-id <span style="color: #8b2252;">"a"</span>) nil)))
                   nil)
                 nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = 1 + 2 * a) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test brackets
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-mul 
                 (make-add 
                   (make-int-constant 1 nil)
                   (make-int-constant 2 nil)
                   nil)
                 (make-int-constant 3 nil)
                 nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = (1 + 2) * 3) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test unary
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-minus (make-int-constant 1 nil) nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = -1) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test unary-bracket
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-minus (make-add 
                               (make-int-constant 1 nil)
                               (make-int-constant 2 nil)
                               nil)
                             nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = -(1 + 2)) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test modulo
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-modulo (make-int-constant 1 nil)
                            (make-int-constant 2 nil)
                            nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        /* comment */</span>
<span style="color: #8b2252;">                        perfect void f(int a = 1 % 2) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test non-assoc
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr 
               (make-lt 
                 (make-int-constant 1 nil)
                 (make-int-constant 2 nil)
                 nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = 1 &lt; 2) {</span>
<span style="color: #8b2252;">                        }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd18710b" class="outline-5">
<h5 id="orgd18710b"><span class="section-number-5">5.2.2.6</span> vars</h5>
<div class="outline-text-5" id="text-5-2-2-6">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite vars <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite vars)


(test var
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr (make-var-expr 
                                (make-normal-var 
                                 (make-basic-var 
                                  (make-id <span style="color: #8b2252;">"b"</span> nil) nil nil) 
                                 nil) 
                                nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = b) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test var-array
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr (make-var-expr 
                                (make-normal-var 
                                  (make-basic-var 
                                    (make-id <span style="color: #8b2252;">"b"</span> nil) 
                                    (list 
                                      (list 
                                        (make-int-constant 1 nil))) 
                                    nil) <span style="color: #ff0000; font-weight: bold;">nil) nil))))</span>
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = b[1]) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test var-array-tiled
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr (make-var-expr 
                                (make-normal-var 
                                  (make-basic-var 
                                    (make-id <span style="color: #8b2252;">"b"</span> nil) 
                                    (list 
                                      (list 
                                        (make-int-constant 1 nil))
                                      (list 
                                        (make-int-constant 2 nil))) 
                                    nil) <span style="color: #ff0000; font-weight: bold;">nil) nil))))</span>
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = b[1][2]) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test var-array-multi-dim
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr (make-var-expr 
                                (make-normal-var 
                                  (make-basic-var 
                                    (make-id <span style="color: #8b2252;">"b"</span> nil) 
                                    (list 
                                      (list 
                                        (make-int-constant 1 nil)
                                        (make-int-constant 2 nil)))
                                    nil) <span style="color: #ff0000; font-weight: bold;">nil) nil))))</span>
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = b[1,2]) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test var-dot
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr (make-var-expr 
                                (make-dot-var
                                  (make-basic-var 
                                    (make-id <span style="color: #8b2252;">"b"</span> nil) 
                                    nil
                                    nil) 
                                  (make-normal-var
                                    (make-basic-var
                                      (make-id <span style="color: #8b2252;">"c"</span> nil)
                                      nil
                                      nil)
                                    nil) <span style="color: #ff0000; font-weight: bold;">nil) nil))))</span>
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = b.c) {</span>
<span style="color: #8b2252;">                        }"</span>)))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org326c06c" class="outline-5">
<h5 id="org326c06c"><span class="section-number-5">5.2.2.7</span> calls</h5>
<div class="outline-text-5" id="text-5-2-2-7">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite calls <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite calls)

(test call
  (<span style="color: #a020f0;">let</span> ((ast (module-for-expr (make-call-expr 
                                (make-call 
                                  (make-id <span style="color: #8b2252;">"b"</span> nil) 
                                  (list (make-int-constant 1 nil)
                                        (make-int-constant 2 nil))
                                  nil)
                                nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int a = b(1, 2)) {</span>
<span style="color: #8b2252;">                        }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga6dc2ba" class="outline-5">
<h5 id="orga6dc2ba"><span class="section-number-5">5.2.2.8</span> types</h5>
<div class="outline-text-5" id="text-5-2-2-8">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite types <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite types)

(test array-type
  (<span style="color: #a020f0;">let</span> ((ast (module-for-type (make-array-type 
                                (make-int nil) 
                                (list (make-decl-array-size
                                        (make-int-constant 2 nil)
                                        nil
                                        nil))
                                nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int[2] a) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test tiled-array-type
  (<span style="color: #a020f0;">let</span> ((ast (module-for-type (make-array-type
                                (make-array-type 
                                  (make-int nil) 
                                  (list (make-decl-array-size 
                                          (make-int-constant 3 nil)
                                          nil
                                          nil))
                                  nil)
                                (list (make-decl-array-size 
                                        (make-int-constant 2 nil)
                                        nil 
                                        nil))
                                nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int[2][3] a) {</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test multi-dim-array-type
  (<span style="color: #a020f0;">let</span> ((ast (module-for-type (make-array-type
                                (make-int nil) 
                                (list (make-decl-array-size 
                                        (make-int-constant 2 nil)
                                        nil
                                        nil)
                                      (make-decl-array-size 
                                        (make-int-constant 3 nil)
                                        nil
                                        nil))
                                nil))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f(int[2,3] a) {</span>
<span style="color: #8b2252;">                        }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ea364a" class="outline-5">
<h5 id="org5ea364a"><span class="section-number-5">5.2.2.9</span> statements</h5>
<div class="outline-text-5" id="text-5-2-2-9">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite stats <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite stats)

(test return-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-return-stat (make-int-constant 1 nil) nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          return 1;</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test foreach-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-foreach-stat 
                       (make-normal-decl
                         nil
                         (list (make-basic-decl 
                                 (make-int nil)
                                 (make-id <span style="color: #8b2252;">"a"</span> nil)
                                 nil))
                         nil)
                       (make-int-constant 1 nil)
                       (make-id <span style="color: #8b2252;">"threads"</span> nil)
                       (make-block-stat 
                         (make-code-block 
                           (list (make-barrier-stat 
                                   (make-id <span style="color: #8b2252;">"b"</span> nil) nil)) <span style="color: #ff0000; font-weight: bold;">nil) nil)</span>
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          foreach (int a in 1 threads) {</span>
<span style="color: #8b2252;">                            barrier(b);</span>
<span style="color: #8b2252;">                          }</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test if-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-if-stat
                       (make-int-constant 1 nil)
                       (make-block-stat 
                         (make-code-block 
                           (list (make-barrier-stat 
                                   (make-id <span style="color: #8b2252;">"b"</span> nil) nil)) <span style="color: #ff0000; font-weight: bold;">nil) nil)</span>
                       nil
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          if (1) {</span>
<span style="color: #8b2252;">                            barrier(b);</span>
<span style="color: #8b2252;">                          }</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test if-else-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-if-stat
                       (make-int-constant 1 nil)
                       (make-block-stat 
                         (make-code-block 
                           (list (make-barrier-stat 
                                   (make-id <span style="color: #8b2252;">"b"</span> nil) nil)) <span style="color: #ff0000; font-weight: bold;">nil) nil)</span>
                       (make-block-stat 
                         (make-code-block 
                           (list (make-barrier-stat 
                                   (make-id <span style="color: #8b2252;">"c"</span> nil) nil)) <span style="color: #ff0000; font-weight: bold;">nil) nil)</span>
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          if (1) {</span>
<span style="color: #8b2252;">                            barrier(b);</span>
<span style="color: #8b2252;">                          }</span>
<span style="color: #8b2252;">                          else {</span>
<span style="color: #8b2252;">                            barrier(c);</span>
<span style="color: #8b2252;">                          }</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test for-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-for-stat
                       (make-assign-decl 
                         nil 
                         (make-basic-decl 
                           (make-int nil) (make-id <span style="color: #8b2252;">"i"</span> nil) nil)
                         (make-int-constant 0 nil)
                         nil)
                       (make-lt 
                         (make-var-expr 
                           (make-normal-var 
                             (make-basic-var (make-id <span style="color: #8b2252;">"i"</span> nil) nil nil)
                             nil)
                           nil)
                         (make-int-constant 2 nil)
                         nil)
                       (make-inc 
                         (make-normal-var 
                           (make-basic-var 
                             (make-id <span style="color: #8b2252;">"i"</span> nil) nil nil) 
                           nil)
                         t 
                         nil)
                       (make-block-stat 
                         (make-code-block 
                           (list (make-barrier-stat 
                                   (make-id <span style="color: #8b2252;">"b"</span> nil) nil)) <span style="color: #ff0000; font-weight: bold;">nil) nil)</span>
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">                            barrier(b);</span>
<span style="color: #8b2252;">                          }</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test id-stat-decl
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-decl-stat 
                       (make-normal-decl 
                         (list (make-user-defined (make-id <span style="color: #8b2252;">"a"</span> nil) nil))
                         (list (make-basic-decl 
                                 (make-int nil)
                                 (make-id <span style="color: #8b2252;">"b"</span> nil) 
                                 nil))
                         nil)
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          a int b;</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test id-stat-assign
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-assign-stat
                       (make-normal-var 
                         (make-basic-var (make-id <span style="color: #8b2252;">"a"</span> nil) nil nil)
                         nil)
                       (make-int-constant 1 nil)
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          a = 1;</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test id-stat-as
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-as-stat
                       (make-normal-var 
                         (make-basic-var (make-id <span style="color: #8b2252;">"a"</span> nil) nil nil)
                         nil)
                       (list (make-basic-decl
                               (make-int nil)
                               (make-id <span style="color: #8b2252;">"b"</span> nil)
                               nil))
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          a as int b;</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test id-stat-call
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-call-stat 
                       (make-call (make-id <span style="color: #8b2252;">"a"</span> nil) nil nil)
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          a(); </span>
<span style="color: #8b2252;">                        }"</span>)))))                       

(test const-decl-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-decl-stat
                       (make-normal-decl (list (make-const nil)
                                                 (make-user-defined 
                                                   (make-id <span style="color: #8b2252;">"shared"</span> nil)
                                                   nil))
                                           (list (make-basic-decl
                                                   (make-int nil)
                                                   (make-id <span style="color: #8b2252;">"a"</span> nil)
                                                   nil))
                                           nil) <span style="color: #ff0000; font-weight: bold;">nil)))))</span>
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          const shared int a;</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test empty-decl-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-decl-stat
                       (make-normal-decl nil
                                           (list (make-basic-decl
                                                   (make-int nil)
                                                   (make-id <span style="color: #8b2252;">"a"</span> nil)
                                                   nil))
                                           nil) <span style="color: #ff0000; font-weight: bold;">nil)))))</span>
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          int a;</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test inc-stat
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-inc-stat 
                       (make-inc 
                         (make-normal-var 
                           (make-basic-var (make-id <span style="color: #8b2252;">"a"</span> nil) nil nil)
                           nil)
                         t
                         nil)
                       nil)))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          a++;</span>
<span style="color: #8b2252;">                        }"</span>)))))

(test inc-stat-exp
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats 
               (list (make-inc-stat 
                       (make-inc-step
                         (make-normal-var 
                           (make-basic-var (make-id <span style="color: #8b2252;">"a"</span> nil) nil))
                         <span style="color: #8b2252;">"+="</span>
                         (make-int-constant 2)))))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                          a += 2;</span>
<span style="color: #8b2252;">                        }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb41b2a3" class="outline-5">
<h5 id="orgb41b2a3"><span class="section-number-5">5.2.2.10</span> test exports</h5>
<div class="outline-text-5" id="text-5-2-2-10">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite exports <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite exports)

(test exports
  (<span style="color: #a020f0;">let</span> ((ast (make-module
              (make-id <span style="color: #8b2252;">"m"</span>)
              (make-id <span style="color: #8b2252;">"a"</span>)
              (list (make-id <span style="color: #8b2252;">"function"</span>) (make-id <span style="color: #8b2252;">"Type"</span>) (make-id <span style="color: #8b2252;">"CONSTANT"</span>))
              nil
              (make-code
               nil
               (list (make-func
                      (make-id <span style="color: #8b2252;">"perfect"</span>)
                      (make-void)
                      (make-id <span style="color: #8b2252;">"f"</span>)
                      nil
                      (make-code-block nil)))))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        export function, Type, CONSTANT;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                        }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f92420" class="outline-5">
<h5 id="org7f92420"><span class="section-number-5">5.2.2.11</span> test qualified ids</h5>
<div class="outline-text-5" id="text-5-2-2-11">
<div class="org-src-container">
<pre class="src src-lisp">
(def-suite qualified-ids <span style="color: #483d8b;">:in</span> parse-mcpl)
(in-suite qualified-ids)


(test qualified-ids
  (<span style="color: #a020f0;">let</span> ((ast (module-for-stats
              (list (make-decl-stat
                     (make-normal-decl
                      nil
                      (list (make-basic-decl
                             (make-custom-type
                              (make-compound-id
                               <span style="color: #8b2252;">"m"</span>
                               (make-compound-id
                                <span style="color: #8b2252;">"b"</span>
                                (make-id <span style="color: #8b2252;">"Type"</span>)))
                              (list (var-expr <span style="color: #8b2252;">"a"</span>) (var-expr <span style="color: #8b2252;">"b"</span>)))
                             (make-id <span style="color: #8b2252;">"c"</span>)))))
                    (make-call-stat
                     (make-call
                      (make-compound-id
                       <span style="color: #8b2252;">"m"</span>
                       (make-compound-id
                        <span style="color: #8b2252;">"b"</span>
                        (make-id <span style="color: #8b2252;">"call"</span>)))
                      (list (var-expr <span style="color: #8b2252;">"a"</span>) (var-expr <span style="color: #8b2252;">"b"</span>))))))))
    (is
      (ast= ast (parse-mcpl <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                        module a;</span>
<span style="color: #8b2252;">                        perfect void f() {</span>
<span style="color: #8b2252;">                           m.b.Type(a, b) c;</span>
<span style="color: #8b2252;">                           m.b.call(a, b);</span>
<span style="color: #8b2252;">                        }"</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga36a707" class="outline-5">
<h5 id="orga36a707"><span class="section-number-5">5.2.2.12</span> helper functions</h5>
<div class="outline-text-5" id="text-5-2-2-12">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">module-for-decls-stats</span> (decls stats)
  (make-module
   (make-id <span style="color: #8b2252;">"m"</span>)
   (make-id <span style="color: #8b2252;">"a"</span>)
   nil
   nil
   (make-code 
    nil 
    (list 
     (make-func
      (make-id <span style="color: #8b2252;">"perfect"</span> nil)
      (make-void nil)
      (make-id <span style="color: #8b2252;">"f"</span> nil)
      decls
      (make-code-block stats nil)
      nil))
    nil)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">module-for-decls</span> (decls)
  (module-for-decls-stats decls nil))

 (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">module-for-stats</span> (stats)
   (module-for-decls-stats nil stats))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">module-for-expr</span> (expr)
  (<span style="color: #a020f0;">let</span> ((decls (list (make-assign-decl
                       nil
                       (make-basic-decl 
                         (make-int nil)
                         (make-id <span style="color: #8b2252;">"a"</span> nil)
                         nil)
                       expr 
                       nil))))
    (module-for-decls decls)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">module-for-type</span> (tp)
  (<span style="color: #a020f0;">let</span> ((decl (make-normal-decl
                nil
                (list (make-basic-decl 
                        tp
                        (make-id <span style="color: #8b2252;">"a"</span> nil)
                        nil))
                nil)))
    (module-for-decls (list decl))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">var-expr</span> (name)
  (make-var-expr (make-normal-var (make-basic-var (make-id name) nil))))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb460fb6" class="outline-2">
<h2 id="orgb460fb6"><span class="section-number-2">6</span> Passes</h2>
<div class="outline-text-2" id="text-6">
<p>
In this section we define several passes.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org566d5a8">6.1. The package</a></li>
<li><a href="#org36e9b0b">6.2. Semantic analysis</a>
<ul>
<li><a href="#org6b8824b">6.2.1. Parsing all modules</a></li>
<li><a href="#orgc235787">6.2.2. Check all exports</a></li>
<li><a href="#org3e505a2">6.2.3. Create a callgraph</a></li>
</ul>
</li>
<li><a href="#org8fe14e8">6.3. Translate</a></li>
<li><a href="#orgef8e598">6.4. Flatten types</a></li>
<li><a href="#org0023e17">6.5. Print pretty</a></li>
<li><a href="#org88f2004">6.6. Print AST JSON</a></li>
<li><a href="#org08713c8">6.7. Generate code</a></li>
<li><a href="#org226522f">6.8. Generate Cashmere code</a></li>
<li><a href="#org663e21f">6.9. Remove hardware variables</a></li>
<li><a href="#org0326ca4">6.10. Moving dimension constants out foreach</a></li>
<li><a href="#orgbb1f3da">6.11. Moving foreach statements to functions</a></li>
<li><a href="#org5e10991">6.12. Moving foreach statements to functions Cashmere</a></li>
<li><a href="#org65a97b3">6.13. Generating transfers</a></li>
<li><a href="#org875a4c5">6.14. Specializing functions on memory-space</a></li>
<li><a href="#orge30a880">6.15. Transform tile expressions</a></li>
</ul>
</div>
</div>

<div id="outline-container-org566d5a8" class="outline-3">
<h3 id="org566d5a8"><span class="section-number-3">6.1</span> The package</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:passes</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span>
        <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:pass-library</span> <span style="color: #483d8b;">:hardware-descriptions</span> <span style="color: #483d8b;">:mcl-util</span>
        <span style="color: #483d8b;">:parse-mcpl</span>
        <span style="color: #483d8b;">:check-package</span>
        <span style="color: #483d8b;">:set-parents</span>
        <span style="color: #483d8b;">:check-exports</span>
        <span style="color: #483d8b;">:load-hardware-descriptions</span>
        <span style="color: #483d8b;">:resolve-calls</span>
        <span style="color: #483d8b;">:resolve-types</span>
        <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:generate-code</span>
        <span style="color: #483d8b;">:set-callgraph</span>
        <span style="color: #483d8b;">:set-vars-written</span>
        <span style="color: #483d8b;">:check-types</span>
        <span style="color: #483d8b;">:check-memory-spaces</span>
        <span style="color: #483d8b;">:set-cfgraphs</span>
        <span style="color: #483d8b;">:print-pretty</span>
        <span style="color: #483d8b;">:code-emitter</span>)
  (<span style="color: #483d8b;">:shadow</span>  <span style="color: #483d8b;">:generate-cashmere-code</span> <span style="color: #483d8b;">:generate-code</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:pass-library</span> <span style="color: #483d8b;">:exports</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:appendf</span> <span style="color: #483d8b;">:copy-hash-table</span> <span style="color: #483d8b;">:flatten</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:cl-fad</span> <span style="color: #483d8b;">:pathname-as-directory</span> <span style="color: #483d8b;">:file-exists-p</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:mcl-quickutil</span> <span style="color: #483d8b;">:transpose</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:fixed-point</span> <span style="color: #483d8b;">:hash-table=</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org36e9b0b" class="outline-3">
<h3 id="org36e9b0b"><span class="section-number-3">6.2</span> Semantic analysis</h3>
<div class="outline-text-3" id="text-6-2">
<p>
First we define the pass and the <code>do</code> function.  Semantic analysis has no
dependencies.  First, we parse the file that was given as input and register it
in the <code>pass-data</code> datastructure.  After that, we compute a fixed point by
parsing all modules that are imported by the modules registered in the
<code>pass-data</code> data structure.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defpass semantic-analysis)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-semantic-analysis</span> (pass-data name-mcpl-file)
  (<span style="color: #a020f0;">with-slots</span> (modules callgraph exports) pass-data
    (parse-module name-mcpl-file pass-data)
    (fixed-point modules #'copy-hash-table #'hash-table=
      (parse-all-modules pass-data))
    (domodules (m modules) (set-parents m))
    (check-all-exports pass-data)
    (domodules (m modules) (resolve-calls m exports))
    (create-callgraph pass-data)
    (domodules (m modules) (resolve-types m exports))
    (domodules (m modules) (resolve-vars m exports))
    (domodules (m modules) (check-types m))
    (domodules (m modules) (set-cfgraphs m))
    (set-vars-written callgraph)
    (check-memory-spaces callgraph)
    modules))

</pre>
</div>
</div>

<div id="outline-container-org6b8824b" class="outline-4">
<h4 id="org6b8824b"><span class="section-number-4">6.2.1</span> Parsing all modules</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
Parsing a module based on a file name first checks whether the file exists,
then parses the file and registers the module in a map with a key, unique for
that file based on the package and the module name.  The package of a module
has to correspond with the directory structure, from which we can infer the
root directory for all modules.  For each file we check whether the root
directory corresponds.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-module</span> (name-mcpl-file pass-data)
  (<span style="color: #a020f0;">if</span> (file-exists-p name-mcpl-file)
      (<span style="color: #a020f0;">let</span> ((module (parse-mcpl-file name-mcpl-file)))
        (setf (gethash (get-key module) (modules pass-data)) module)
        (set-root-directory pass-data module name-mcpl-file))
      (mcl-error nil <span style="color: #8b2252;">"File ~a does not exist"</span> name-mcpl-file)))
</pre>
</div>


<p>
Setting the root directory calls the micro-pass <code>check-package</code> that verifies
the name of the file and the package/module structure.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-root-directory</span> (pass-data module name-mcpl-file)
  (<span style="color: #a020f0;">with-slots</span> (root-directory) pass-data
    (<span style="color: #a020f0;">let</span> ((found-root-directory (check-package module name-mcpl-file)))
      (<span style="color: #a020f0;">if</span> (null root-directory)
          (setf root-directory found-root-directory)
          (<span style="color: #a020f0;">when</span> (not (equal root-directory found-root-directory))
            (pkg-error (location module)
                       <span style="color: #8b2252;">"Found more than one root directories: ~a and ~a"</span>
                       root-directory found-root-directory))))))
</pre>
</div>


<p>
The function <code>parse-all-modules</code> processes all imports from all modules in the
<code>pass-data</code> data structure.  This means that each imported module gets an entry
in <code>pass-data</code> with initial value <code>nil</code>.  After this, we parse each key with
value <code>nil</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-all-modules</span> (pass-data)
  (<span style="color: #a020f0;">with-slots</span> (root-directory modules) pass-data
    (<span style="color: #a020f0;">loop</span> for v being the hash-values in (copy-hash-table modules)
         do (process-imports v pass-data))
    (<span style="color: #a020f0;">loop</span> for k being the hash-keys using (hash-value v) in modules
       when (null v) do
         (parse-module (format nil <span style="color: #8b2252;">"~a~a.mcl"</span> root-directory k) pass-data))))
</pre>
</div>

<p>
The following functions process the imports.  An import can be an MCPL module
or a hardware description.  If the name of the module is a hardware
description, we load the hardware description, otherwise, we add the key of the
identifier of the import to the <code>pass-data</code> data structure.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">process-imports</span> (module pass-data)
  (<span style="color: #a020f0;">dolist</span> (i (imports module))
    (process-import i pass-data)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">process-import</span> (import pass-data))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">process-import</span> ((import lib-import) pass-data)
  (<span style="color: #a020f0;">with-slots</span> (id) import
    (<span style="color: #a020f0;">when</span> (not (process-import-id id))
      (<span style="color: #a020f0;">let</span> ((key (get-key id)))
        (<span style="color: #a020f0;">with-slots</span> (modules) pass-data
          (<span style="color: #a020f0;">when</span> (not (nth-value 1 (gethash key modules)))
            (setf (gethash key modules) nil)))))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">process-import-id</span> (import))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">process-import-id</span> ((id id))
  (<span style="color: #a020f0;">with-slots</span> (name) id
    (<span style="color: #a020f0;">if</span> (hardware-description-p name)
        (load-hardware-description name)
        nil)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">process-import-id</span> ((ci compound-id))
  (<span style="color: #a020f0;">declare</span> (ignore ci))
  nil)
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc235787" class="outline-4">
<h4 id="orgc235787"><span class="section-number-4">6.2.2</span> Check all exports</h4>
<div class="outline-text-4" id="text-6-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-all-exports</span> (pass-data)
  (<span style="color: #a020f0;">with-slots</span> (modules exports) pass-data
    (<span style="color: #a020f0;">loop</span> for k being the hash-keys in (modules pass-data) using (hash-value v)
          do (setf (gethash k exports) (check-exports v)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e505a2" class="outline-4">
<h4 id="org3e505a2"><span class="section-number-4">6.2.3</span> Create a callgraph</h4>
<div class="outline-text-4" id="text-6-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-callgraph</span> (pass-data)
  (setf (callgraph pass-data) (set-callgraph (get-funcs pass-data))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-funcs</span> (pass-data)
  (<span style="color: #a020f0;">loop</span> for m being the hash-values in (modules pass-data)
     append (funcs (code m))))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8fe14e8" class="outline-3">
<h3 id="org8fe14e8"><span class="section-number-3">6.3</span> Translate</h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">
<pre class="src src-lisp">(defpass translate
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-translate</span> (pass-data target)
  (<span style="color: #a020f0;">with-slots</span> (modules callgraph exports) pass-data
    (translate:translate
     (alexandria:hash-table-values modules) callgraph target exports)
    pass-data))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgef8e598" class="outline-3">
<h3 id="orgef8e598"><span class="section-number-3">6.4</span> Flatten types</h3>
<div class="outline-text-3" id="text-6-4">
<div class="org-src-container">
<pre class="src src-lisp">(defpass flatten-types
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis remove-hardware-vars))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-flatten-types</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">with-slots</span> (modules exports) pass-data
    (domodules (m modules) (flatten-module m))
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-vars m exports))
    <span style="color: #b22222;">;;</span><span style="color: #b22222;">(domodules (m modules) (check-types m))</span>
    ))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">flatten-module</span> (module)
  (visit module #'flatten-var-fw #'flatten-var-bw)
  (visit module #'flatten-type-fw #'flatten-type-bw))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">flatten-var-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">flatten-var-bw</span> (ast))

(defvisitor flatten-var-fw ast (ast string symbol list number)
  t)

(defvisitor flatten-var-bw ast (ast string symbol list number)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">flatten-var-bw</span> ((v var))
  (replace-in-ast v <span style="color: #483d8b;">:with</span> (flatten-var:flatten-var v)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">flatten-type-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">flatten-type-bw</span> (ast))

(defvisitor flatten-type-fw ast (ast string symbol list number)
  t)

(defvisitor flatten-type-bw ast (ast string symbol list number)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">flatten-type-fw</span> ((type mcl-type))
  (replace-in-ast type <span style="color: #483d8b;">:with</span> (flatten-types:flatten-type type)))

</pre>
</div>
</div>
</div>

<div id="outline-container-org0023e17" class="outline-3">
<h3 id="org0023e17"><span class="section-number-3">6.5</span> Print pretty</h3>
<div class="outline-text-3" id="text-6-5">
<div class="org-src-container">
<pre class="src src-lisp">(defpass print-pretty
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis)
  (<span style="color: #483d8b;">:options</span> translate flatten-types move-foreach-to-func remove-hardware-vars
            generate-transfers remove-hardware-vars
            move-dimension-constants-out-foreach))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-print-pretty</span> (pass-data name-mcpl-file)
  (<span style="color: #a020f0;">let</span> ((module (gethash (get-key-from-filename name-mcpl-file pass-data)
                         (modules pass-data))))
    (pp module)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org88f2004" class="outline-3">
<h3 id="org88f2004"><span class="section-number-3">6.6</span> Print AST JSON</h3>
<div class="outline-text-3" id="text-6-6">
<div class="org-src-container">
<pre class="src src-lisp">(defpass print-ast-json
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis)
  (<span style="color: #483d8b;">:options</span> 
   <span style="color: #b22222;">;; </span><span style="color: #b22222;">translate flatten-types move-foreach-to-func remove-hardware-vars</span>
   <span style="color: #b22222;">;; </span><span style="color: #b22222;">generate-transfers remove-hardware-vars</span>
   <span style="color: #b22222;">;; </span><span style="color: #b22222;">move-dimension-constants-out-foreach</span>
            ))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-print-ast-json</span> (pass-data name-mcpl-file)
  (<span style="color: #a020f0;">let</span> ((module (gethash (get-key-from-filename name-mcpl-file pass-data)
                         (modules pass-data))))
    (print-ast-json:print-ast-json module)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org08713c8" class="outline-3">
<h3 id="org08713c8"><span class="section-number-3">6.7</span> Generate code</h3>
<div class="outline-text-3" id="text-6-7">
<div class="org-src-container">
<pre class="src src-lisp">(defpass generate-code
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis translate flatten-types
                 move-dimension-constants-out-foreach
                 remove-hardware-vars move-foreach-to-func generate-transfers
                 specialize-funcs-on-memory-space transform-tile-expressions)
  (<span style="color: #483d8b;">:options</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-generate-code</span> (pass-data options)
  (<span style="color: #a020f0;">destructuring-bind</span> (type-code target entry-funcs output-dir) options
    (<span style="color: #a020f0;">with-slots</span> (modules callgraph) pass-data
      (<span style="color: #a020f0;">loop</span> for m being the hash-values in modules
         collect (generate-code:generate-code
                  m type-code (read-codegen target) entry-funcs output-dir
                  callgraph)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">read-codegen</span> (target)
  (<span style="color: #a020f0;">let</span> ((codegen-filename (create-codegen-filename target)))
    (<span style="color: #a020f0;">if</span> (file-exists-p codegen-filename)
        (<span style="color: #a020f0;">with-open-file</span> (in codegen-filename)
            (<span style="color: #a020f0;">with-standard-io-syntax</span>
              (first (rest (read in)))))
        (mcl-error nil <span style="color: #8b2252;">"target ~s does not exist"</span> target))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-codegen-filename</span> (target)
  (format nil <span style="color: #8b2252;">"~a/input/codegen/~a.lisp"</span> (getenv <span style="color: #8b2252;">"MCL_ROOT_DIR"</span>) target))
</pre>
</div>
</div>
</div>

<div id="outline-container-org226522f" class="outline-3">
<h3 id="org226522f"><span class="section-number-3">6.8</span> Generate Cashmere code</h3>
<div class="outline-text-3" id="text-6-8">
<div class="org-src-container">
<pre class="src src-lisp">(defpass generate-cashmere-code
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis translate flatten-types
                 move-dimension-constants-out-foreach
                 remove-hardware-vars 
                 specialize-funcs-on-memory-space)
  (<span style="color: #483d8b;">:options</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-generate-cashmere-code</span> (pass-data options)
  (<span style="color: #a020f0;">destructuring-bind</span> (type-code target output-dir) options
    (<span style="color: #a020f0;">with-slots</span> (modules callgraph) pass-data
      (<span style="color: #a020f0;">loop</span> for m being the hash-values in modules
         when (generate-code:generate-code
                  m type-code (read-codegen target) nil output-dir
                  callgraph)
         collect it))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*targets*</span> '(<span style="color: #8b2252;">"fermi"</span>))
</pre>
</div>

<p>
We not only generate an OpenCL file for every mcl-file, but we also generate
one overall <code>MCL.java</code> file which allows one to call MCL kernels from java with
convenience.  The <code>write-mcl-file</code> takes as input a list of <code>cashmere-info</code>'s
that contains the information to create the convenience functions.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-cashmere-code</span> (mcl-file-names targets output-dir)
  (write-mcl-file
   (<span style="color: #a020f0;">loop</span> for mcl-file-name in mcl-file-names
      append (generate-cashmere-code-for-file
              mcl-file-name targets output-dir))
   output-dir))
</pre>
</div>

<p>
In the following function we generate a <code>cashmere-info</code> for every target and
every file.  Every file contains one entry-point to a kernel and we generate
various Java call functions from it.  Some have the original array-types and
others have Buffer or Pointer types instead of the array types.  Per target, we
have then several variants.  However, we would like to have several targets per
variant, so that we can adjust the way we call the kernel accordingly per
variant.  We then merge the target-versions together in these cashmere-info's.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-cashmere-code-for-file</span> (mcl-file-name targets output-dir)
  (<span style="color: #a020f0;">let</span> ((variants-per-target (<span style="color: #a020f0;">loop</span> for target in targets
                       append (generate-cashmere-code-for-target
                               target mcl-file-name output-dir))))
    (<span style="color: #a020f0;">loop</span> for target in (targets-per-variant variants-per-target)
       append (merge-for-target target))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">targets-per-variant</span> (variants-per-target)
  (transpose variants-per-target))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">merge-for-target</span> (cashmere-infos)
  (<span style="color: #a020f0;">let</span> ((hash-table (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (<span style="color: #a020f0;">loop</span> for ci in (flatten cashmere-infos)
       do (add-or-merge ci hash-table))
    (<span style="color: #a020f0;">loop</span> for m being the hash-values in hash-table collect m)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-or-merge</span> (cashmere-info hash-table)
  (aif (gethash (module cashmere-info) hash-table)
       (merge-into it cashmere-info)
       (setf (gethash (module cashmere-info) hash-table) cashmere-info)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">merge-into</span> (merge to-be-merged)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (string= (module merge) (module to-be-merged)))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (string= (default-func merge ) (default-func to-be-merged)))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (string= (copy-func-header merge) (copy-func-header to-be-merged)))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (string= (set-argument merge) (set-argument to-be-merged)))
  (appendf (call-conditions merge) (call-conditions to-be-merged)))
</pre>
</div>

<p>
The following function generates for a target and mcl-file an OpenCL file and
returns in principal one cashmere-info that indicates how the kernel can be
called from Java.  However, since we want to be able to call the kernel both
with array types and <code>Buffer</code> or <code>Pointer</code> types in Java, we generate several
variants.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-cashmere-code-for-target</span> (target mcl-file-name output-dir)
  (enable-pass 'specialize-funcs-on-memory-space 'move-foreach-to-func-cashmere)
  (run-pass 'generate-cashmere-code
            (list (cons 'semantic-analysis mcl-file-name)
                  (cons 'translate target)
                  (cons 'generate-cashmere-code
                        (list <span style="color: #8b2252;">"cashmere"</span> target output-dir)))))
</pre>
</div>

<p>
This function writes the <code>MCL.java</code> file based on the <code>cashmere-info</code>
information. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">write-mcl-file</span> (cashmere-infos output-dir)
  (<span style="color: #a020f0;">let*</span> ((base-dir (pathname-as-directory output-dir))
         (file (merge-pathnames <span style="color: #8b2252;">"MCL.java"</span> base-dir)))
    (<span style="color: #a020f0;">with-open-file</span> (out (ensure-directories-exist file)
                         <span style="color: #483d8b;">:direction</span> <span style="color: #483d8b;">:output</span> <span style="color: #483d8b;">:if-exists</span> <span style="color: #483d8b;">:supersede</span>)
        (format out (make-contents-mcl-file cashmere-infos)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-contents-mcl-file</span> (cashmere-infos)
  (emit <span style="color: #8b2252;">"import org.jocl.Pointer;"</span>
        <span style="color: #8b2252;">""</span>
        <span style="color: #8b2252;">"import ibis.cashmere.constellation.Argument;"</span>
        <span style="color: #8b2252;">"import ibis.cashmere.constellation.Buffer;"</span>
        <span style="color: #8b2252;">"import ibis.cashmere.constellation.KernelLaunch;"</span>
        <span style="color: #8b2252;">"import ibis.cashmere.constellation.MCCashmereNotAvailable;"</span>
        <span style="color: #8b2252;">""</span>
        <span style="color: #8b2252;">""</span>
        <span style="color: #8b2252;">"class MCL {"</span>
        <span style="color: #8b2252;">""</span>
        <span style="color: #8b2252;">"    ~a"</span> (emit-list cashmere-infos <span style="color: #483d8b;">:nr-lines</span> 2 <span style="color: #483d8b;">:function</span> #'make-funcs)
        <span style="color: #8b2252;">"}"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-funcs</span> (cashmere-info)
  (<span style="color: #a020f0;">with-slots</span> (default-func copy-func-header set-argument call-conditions)
      cashmere-info
    (emit <span style="color: #8b2252;">"~a"</span> (emit-list (split-lines default-func))
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a {"</span> copy-func-header
          <span style="color: #8b2252;">"    ~a"</span> (emit-list (split-lines set-argument))
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"    ~a"</span> (make-call-conditions call-conditions)
          <span style="color: #8b2252;">"    else {"</span>
          <span style="color: #8b2252;">"        throw new MCCashmereNotAvailable(\"no compatible device found\");"</span>
          <span style="color: #8b2252;">"    }"</span>
          <span style="color: #8b2252;">"}"</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-call-conditions</span> (call-conditions)
  (<span style="color: #a020f0;">destructuring-bind</span> (f <span style="color: #228b22;">&amp;rest</span> r) call-conditions
    (<span style="color: #a020f0;">if</span> r
        (emit <span style="color: #8b2252;">"~a"</span> (make-call-condition f nil)
              <span style="color: #8b2252;">"~a"</span> (emit-list r <span style="color: #483d8b;">:nr-lines</span> 0 <span style="color: #483d8b;">:function</span> #'make-call-condition))
        (emit <span style="color: #8b2252;">"~a"</span> (make-call-condition f nil)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-call-condition</span> (call-condition else)
  (<span style="color: #a020f0;">destructuring-bind</span> (condition stats call) call-condition
    (emit <span style="color: #8b2252;">"~aif (~a) {"</span> (<span style="color: #a020f0;">if</span> else <span style="color: #8b2252;">"else"</span> <span style="color: #8b2252;">""</span>) condition
          <span style="color: #8b2252;">"    ~a"</span> (emit-list stats)
          <span style="color: #8b2252;">"    ~a;"</span> call
          <span style="color: #8b2252;">"}"</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org663e21f" class="outline-3">
<h3 id="org663e21f"><span class="section-number-3">6.9</span> Remove hardware variables</h3>
<div class="outline-text-3" id="text-6-9">
<div class="org-src-container">
<pre class="src src-lisp">(defpass remove-hardware-vars
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis translate))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-remove-hardware-vars</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">loop</span> for m being the hash-values in (modules pass-data)
        do (remove-hardware-vars:remove-hardware-vars m)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0326ca4" class="outline-3">
<h3 id="org0326ca4"><span class="section-number-3">6.10</span> Moving dimension constants out foreach</h3>
<div class="outline-text-3" id="text-6-10">
<div class="org-src-container">
<pre class="src src-lisp">(defpass move-dimension-constants-out-foreach
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis translate))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-move-dimension-constants-out-foreach</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">with-slots</span> (modules callgraph exports) pass-data
    (domodules (m modules)
      (move-dimension-constants:move-dimension-constants m))
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-calls m exports))
    (create-callgraph pass-data)
    (domodules (m modules) (resolve-vars m exports))
    <span style="color: #b22222;">;;</span><span style="color: #b22222;">(domodules (m modules) (check-types m))</span>
    (domodules (m modules) (set-cfgraphs m))
    (set-vars-written callgraph)
    modules))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb1f3da" class="outline-3">
<h3 id="orgbb1f3da"><span class="section-number-3">6.11</span> Moving foreach statements to functions</h3>
<div class="outline-text-3" id="text-6-11">
<div class="org-src-container">
<pre class="src src-lisp">(defpass move-foreach-to-func
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis flatten-types
                 move-dimension-constants-out-foreach
                 generate-transfers))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-move-foreach-to-func</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">with-slots</span> (modules callgraph exports) pass-data
    (domodules (m modules) (move-foreach-to-func:move-foreach-to-func m))
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-calls m exports))
    (create-callgraph pass-data)
    (domodules (m modules) (resolve-types m exports))
    (domodules (m modules) (resolve-vars m exports))
    (domodules (m modules) (check-types m))
    (domodules (m modules) (set-cfgraphs m))
    (set-vars-written callgraph)
    <span style="color: #b22222;">;;</span><span style="color: #b22222;">(domodules (m modules) (check-types m))</span>
    modules))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5e10991" class="outline-3">
<h3 id="org5e10991"><span class="section-number-3">6.12</span> Moving foreach statements to functions Cashmere</h3>
<div class="outline-text-3" id="text-6-12">
<div class="org-src-container">
<pre class="src src-lisp">(defpass move-foreach-to-func-cashmere
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis flatten-types
                 move-dimension-constants-out-foreach))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-move-foreach-to-func-cashmere</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">with-slots</span> (modules callgraph exports) pass-data
    (domodules (m modules)
      (move-foreach-to-func-cashmere:move-foreach-to-func-cashmere m))
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-calls m exports))
    (create-callgraph pass-data)
    (domodules (m modules) (resolve-types m exports))
    (domodules (m modules) (resolve-vars m exports))
    (domodules (m modules) (check-types m))
    (domodules (m modules) (set-cfgraphs m))
    (set-vars-written callgraph)
    <span style="color: #b22222;">;;</span><span style="color: #b22222;">(domodules (m modules) (check-types m))</span>
    modules))
</pre>
</div>
</div>
</div>

<div id="outline-container-org65a97b3" class="outline-3">
<h3 id="org65a97b3"><span class="section-number-3">6.13</span> Generating transfers</h3>
<div class="outline-text-3" id="text-6-13">
<div class="org-src-container">
<pre class="src src-lisp">(defpass generate-transfers
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis flatten-types))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-generate-transfers</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">with-slots</span> (modules callgraph exports) pass-data
    (domodules (m modules) (set-cfgraphs m t t))
    (set-entry-exit-on-device-variables:set-entry-exit-on-device-variables
     callgraph)
    (generate-transfers:generate-transfers callgraph)
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-vars m exports))
    (domodules (m modules) (set-cfgraphs m))

    (generate-allocations:generate-allocations callgraph)
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-vars m exports))

    (domodules (m modules)
      (remove-unnecessary-transfers:remove-unnecessary-transfers m))
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-calls m exports))
    (create-callgraph pass-data)
    (domodules (m modules) (resolve-vars m exports))
    (set-vars-written callgraph)
    (domodules (m modules) (set-cfgraphs m))
    modules))
</pre>
</div>
</div>
</div>

<div id="outline-container-org875a4c5" class="outline-3">
<h3 id="org875a4c5"><span class="section-number-3">6.14</span> Specializing functions on memory-space</h3>
<div class="outline-text-3" id="text-6-14">
<div class="org-src-container">
<pre class="src src-lisp">(defpass specialize-funcs-on-memory-space
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis)
  (<span style="color: #483d8b;">:at-most-one</span> (move-foreach-to-func move-foreach-to-func-cashmere)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-specialize-funcs-on-memory-space</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">with-slots</span> (modules callgraph exports) pass-data
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(loop for v being the hash-values in modules</span>
    <span style="color: #b22222;">;;    </span><span style="color: #b22222;">do (format t (print-pretty:pp v)))</span>
    (specialize-funcs-on-memory-space:specialize-funcs-on-memory-space
     (alexandria:hash-table-values modules) callgraph exports)
    (clrhash exports)
    (check-all-exports pass-data)
    (domodules (m modules) (set-parents m))
    (domodules (m modules) (resolve-calls m exports))
    (create-callgraph pass-data)
    (domodules (m modules) (resolve-types m exports))
    (domodules (m modules) (resolve-vars m exports))
    (domodules (m modules) (check-types m))
    (domodules (m modules) (set-cfgraphs m))
    (set-vars-written callgraph)
    modules))
</pre>
</div>
</div>
</div>




<div id="outline-container-orge30a880" class="outline-3">
<h3 id="orge30a880"><span class="section-number-3">6.15</span> Transform tile expressions</h3>
<div class="outline-text-3" id="text-6-15">
<div class="org-src-container">
<pre class="src src-lisp">(defpass transform-tile-expressions
  (<span style="color: #483d8b;">:dependencies</span> semantic-analysis move-foreach-to-func flatten-types))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-transform-tile-expressions</span> (pass-data options)
  (<span style="color: #a020f0;">declare</span> (ignore options))
  (<span style="color: #a020f0;">with-slots</span> (modules exports) pass-data
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(domodules (m modules)</span>
    <span style="color: #b22222;">;;   </span><span style="color: #b22222;">(transform-tile-expressions:transform-tile-expressions m exports))</span>
    modules))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfdd9db2" class="outline-2">
<h2 id="orgfdd9db2"><span class="section-number-2">7</span> Micro-passes</h2>
<div class="outline-text-2" id="text-7">
<p>
This section contains many small categorized micro-passes that perform a single
pass over the AST.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org7b57157">7.1. Resolution</a></li>
<li><a href="#org5eb12ac">7.2. Checking</a></li>
<li><a href="#org3b98d04">7.3. Transformations</a></li>
<li><a href="#orgd9da4f3">7.4. Translating between abstraction levels</a></li>
<li><a href="#orga21d863">7.5. Generate Code</a></li>
<li><a href="#orgcb10b82">7.6. Dataflow-values</a></li>
<li><a href="#org83cff71">7.7. Dataflow</a></li>
<li><a href="#org2eb1fbd">7.8. Printing</a></li>
<li><a href="#org03c4550">7.9. Visualization</a></li>
<li><a href="#org652f86e">7.10. Transfers</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7b57157" class="outline-3">
<h3 id="org7b57157"><span class="section-number-3">7.1</span> Resolution</h3>
<div class="outline-text-3" id="text-7-1">
<p>
This section shows several micro-passes that do some form of resolution, for
example resolving variables and calls.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org0899f74">7.1.1. Resolve exports</a></li>
<li><a href="#org73a390b">7.1.2. set vars written</a></li>
<li><a href="#org9cd7325">7.1.3. set callgraph</a></li>
<li><a href="#org75b51a7">7.1.4. resolve calls</a></li>
<li><a href="#orgf498ba9">7.1.5. Resolve Types</a></li>
<li><a href="#org7a307e3">7.1.6. Resolve Vars</a></li>
<li><a href="#org59ffd2d">7.1.7. loading hardware descriptions</a></li>
<li><a href="#org3963fe2">7.1.8. replace identifier statements</a></li>
<li><a href="#org08d1264">7.1.9. set control flow graphs</a></li>
<li><a href="#org02839a7">7.1.10. set parents</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0899f74" class="outline-4">
<h4 id="org0899f74"><span class="section-number-4">7.1.1</span> Resolve exports</h4>
<div class="outline-text-4" id="text-7-1-1">
</div>
<div id="outline-container-org79f73bd" class="outline-5">
<h5 id="org79f73bd"><span class="section-number-5">7.1.1.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:resolve-exports</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:resolve-exports</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb56e67a" class="outline-5">
<h5 id="orgb56e67a"><span class="section-number-5">7.1.1.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-exports</span> (imports-module id exports)
  (pass-library:resolve-exports imports-module id exports))
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org73a390b" class="outline-4">
<h4 id="org73a390b"><span class="section-number-4">7.1.2</span> set vars written</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
This pass determines whether variables are written or not.  It depends on a
callgraph being defined and on alias analysis.  It also relies on a matching
number of arguments in calls and in functions.  This is checked in the
<code>resolve-calls</code> micro-pass.
</p>
</div>

<div id="outline-container-org8c3c07d" class="outline-5">
<h5 id="org8c3c07d"><span class="section-number-5">7.1.2.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:set-vars-written</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:string-case</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span>
        <span style="color: #483d8b;">:aliases</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:set-vars-written</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org724b9bd" class="outline-5">
<h5 id="org724b9bd"><span class="section-number-5">7.1.2.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-2-2">
<p>
The function <code>set-vars-written</code> visits all functions from leave functions to
the top.  It then sets all variables that are written as being written.  A
subsequent pass sets all declarations that are not written as being constant.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-vars-written</span> (callgraph)
  (log-micro-pass <span style="color: #8b2252;">"set-vars-written"</span> callgraph)
  (<span style="color: #a020f0;">let</span> ((funcs (reverse (funcs-ordered callgraph))))
    (visit funcs #'set-vars-written-fw #'set-vars-written-bw)
    (visit funcs #'set-vars-read-fw #'set-vars-read-bw)
    (visit funcs #'set-decl-constant-fw #'set-decl-constant-bw)
    callgraph))
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="orga30b97a"></a>Setting vars written<br />
<div class="outline-text-6" id="text-orga30b97a">
<p>
The forward pass <code>set-vars-written-fw</code> visits all AST forms that can write to a
variable.  The backward pass does nothing.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-vars-written-fw</span> (ast))

(defvisitor set-vars-written-fw ast (ast list string symbol number)
  t)
</pre>
</div>

<p>
A parameter of a call may be written.  Several builtin functions write to a
variable.  If a parameter of a called function is written, we try to set it
written:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor set-vars-written-fw c (call)
  (<span style="color: #a020f0;">if</span> (builtin-func-p c)
      (set-vars-written-builtin c)
      (<span style="color: #a020f0;">dolist</span> (e (params c))
        (<span style="color: #a020f0;">when</span> (param-written-p e)
          (try-set-written (var e)))))
  t)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-vars-written-builtin</span> (call)
  (string-case ((name (id call)))
    (<span style="color: #8b2252;">"mcl_builtin_read"</span> nil)
    (<span style="color: #8b2252;">"mcl_builtin_write"</span> (set-vars-written-builtin-write call))
    (<span style="color: #8b2252;">"toFloat"</span> nil)
    (<span style="color: #8b2252;">"toDouble"</span> nil)
    (<span style="color: #8b2252;">"mcl_builtin_allocate_on_device"</span> nil)
    (<span style="color: #8b2252;">"mcl_builtin_deallocate_on_device"</span> nil)
    (<span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span> nil)
    (<span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span> (set-vars-written-builtin-write call))
    (<span style="color: #8b2252;">"min"</span> nil)
    (<span style="color: #8b2252;">"max"</span> nil)
    (<span style="color: #8b2252;">"divide_up"</span> nil)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-vars-written-builtin-write</span> (call)
  (<span style="color: #a020f0;">with-slots</span> (id params) call
    (<span style="color: #a020f0;">with-slots</span> (name location) id
      (<span style="color: #a020f0;">dolist</span> (e params)
        (<span style="color: #a020f0;">if</span> (typep e 'var-expr)
            (try-set-written (var e))
            (non-var-written-error
             location
             <span style="color: #8b2252;">"Expecting variables as arguments for special form ~a"</span>
             name))))))
</pre>
</div>

<p>
The following AST-forms also write to a variable:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor set-vars-written-fw ast (inc inc-step assign-stat)
  (try-set-written (var ast))
  t)
</pre>
</div>

<p>
A swap stat is defined to be written for both variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">set-vars-written-fw</span> ((ss swap-stat))
  (<span style="color: #a020f0;">with-slots</span> (var-left var-right) ss
    (try-set-written var-left)
    (try-set-written var-right)
    t))
</pre>
</div>

<p>
The following function tries to set a variable as written.  If the declaration
is constant, an error is thrown.  Each alias is set written.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">try-set-written</span> (var)
  (<span style="color: #a020f0;">let</span> ((alias-decls (cons (get-decl-var var) (get-decls-aliased-to-var var))))
    (<span style="color: #a020f0;">dolist</span> (d alias-decls)
      (try-set-written-decl var d))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">try-set-written-decl</span> (var decl)
  (<span style="color: #a020f0;">let</span> ((id-var (get-id var))
        (id-decl (get-id decl)))
    (<span style="color: #a020f0;">if</span> (constant-p decl)
        (<span style="color: #a020f0;">with-slots</span> (location name) id-var
          (constant-var-written-error
           location
           <span style="color: #8b2252;">"variable ~a is written while being constant~a"</span>
           name
           (alias-message id-var id-decl)))
        (setf (written decl) t))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">alias-message</span> (id-var id-decl)
  (<span style="color: #a020f0;">if</span> (ast= id-var id-decl)
      <span style="color: #8b2252;">""</span>
      (format nil <span style="color: #8b2252;">" (through alias ~a)"</span> (name id-decl))))
</pre>
</div>




<p>
The backward pass that does nothing:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-vars-written-bw</span> (ast))

(defvisitor set-vars-written-bw ast (ast list string symbol number)
  nil)
</pre>
</div>
</div>
</li>







<li><a id="orgfdd311c"></a>Setting vars read<br />
<div class="outline-text-6" id="text-orgfdd311c">
<p>
The forward pass <code>set-vars-read-fw</code> visits all AST forms that can write to a
variable.  The backward pass does nothing.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-vars-read-fw</span> (ast))

(defvisitor set-vars-read-fw ast (ast list string symbol number)
  t)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(defvisitor set-vars-read-fw f (func)
  (<span style="color: #a020f0;">let</span> ((vars (collect-all f #'(<span style="color: #a020f0;">lambda</span> (ast) (typep ast 'var)))))
    (<span style="color: #a020f0;">loop</span> for var in vars
       do (check-var var))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-var</span> (var)
  (<span style="color: #a020f0;">cond</span>
    ((typep (parent var) 'var-expr)
     (check-var-expr (parent var) var))
    ((typep (parent var) 'assign-stat)
     nil)
    ((typep (parent var) 'dot-var)
     nil)
    ((typep (parent var) 'inc)
     (set-read var))
    ((typep (parent var) 'inc-step)
     (set-read var))
    ((typep (parent var) 'swap-stat)
     (set-read var))
    (t
     (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"case that has to be handled"</span>))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-var-expr</span> (var-expr var)
  (<span style="color: #a020f0;">if</span> (typep (parent var-expr) 'call)
      (check-reads-call (parent var-expr) var-expr var)
      (set-read var)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-reads-call</span> (call var-expr var)
  (<span style="color: #a020f0;">if</span> (builtin-func-p call)
      (set-read-vars-builtin call var)
      (<span style="color: #a020f0;">let</span> ((func (func call)))
        (<span style="color: #a020f0;">when</span> (loaded (nth (position var-expr (params call)) (params func)))
          (set-read var)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-read-vars-builtin</span> (call var)
  (string-case ((name (id call)))
    (<span style="color: #8b2252;">"mcl_builtin_read"</span> (set-read var))
    (<span style="color: #8b2252;">"mcl_builtin_write"</span> nil)
    (<span style="color: #8b2252;">"toFloat"</span> (set-read var))
    (<span style="color: #8b2252;">"toDouble"</span> (set-read var))
    (<span style="color: #8b2252;">"mcl_builtin_allocate_on_device"</span> nil)
    (<span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span> (set-read var))
    (<span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span> nil)
    (<span style="color: #8b2252;">"mcl_builtin_deallocate_on_device"</span> nil)
    (<span style="color: #8b2252;">"min"</span> (set-read var))
    (<span style="color: #8b2252;">"max"</span> (set-read var))
    (<span style="color: #8b2252;">"divide_up"</span> (set-read var))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-read</span> (var)
  (<span style="color: #a020f0;">let</span> ((alias-decls (cons (get-decl-var var) (get-decls-aliased-to-var
                                                var))))
    (<span style="color: #a020f0;">dolist</span> (d alias-decls)
      (setf (loaded d) t))))
</pre>
</div>




<p>
The backward pass that does nothing:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-vars-read-bw</span> (ast))

(defvisitor set-vars-read-bw ast (ast list string symbol number)
  nil)
</pre>
</div>
</div>
</li>








<li><a id="org8be6ee0"></a>Setting declarations constant<br />
<div class="outline-text-6" id="text-org8be6ee0">
<p>
The forward pass finds declarations that are not written and adds a <code>const</code>
modifier:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-decl-constant-fw</span> (ast))

(defvisitor set-decl-constant-fw ast (ast list string symbol number)
  t)

(defvisitor set-decl-constant-fw decl (decl)
  (<span style="color: #a020f0;">when</span> (not (written decl))
    (<span style="color: #a020f0;">let</span> ((const (make-const)))
      (setf (parent const) decl)
      (pushnew const (modifiers decl) <span style="color: #483d8b;">:test</span> #'ast=)))
  t)
</pre>
</div>

<p>
The backward pass does nothing:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-decl-constant-bw</span> (ast))
(defvisitor set-decl-constant-bw ast (ast list string symbol number)
  nil)
</pre>
</div>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgf41d1a4" class="outline-5">
<h5 id="orgf41d1a4"><span class="section-number-5">7.1.2.3</span> The tests</h5>
<div class="outline-text-5" id="text-7-1-2-3">
</div>
<ul class="org-ul">
<li><a id="org77ff7de"></a>The package<br />
<div class="outline-text-6" id="text-org77ff7de">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-set-vars-written</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span>
        <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:callgraph</span>
        <span style="color: #483d8b;">:parse-mcpl</span>
        <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:resolve-vars</span> <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:set-cfgraphs</span>
        <span style="color: #483d8b;">:set-vars-written</span>)
  (<span style="color: #483d8b;">:shadow</span> <span style="color: #483d8b;">:get-module</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-set-vars-written</span>))
</pre>
</div>
</div>
</li>

<li><a id="org72426ed"></a>The functionality<br />
<div class="outline-text-6" id="text-org72426ed">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite set-vars-written <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite set-vars-written)

(test simple
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>

<span style="color: #8b2252;">                  perfect void f(int a) {</span>
<span style="color: #8b2252;">                      a = 0;</span>
<span style="color: #8b2252;">                  }</span>

<span style="color: #8b2252;">                  perfect void g(int b, int c) {</span>
<span style="color: #8b2252;">                      f(b);</span>
<span style="color: #8b2252;">                  }"</span>)

         (module (get-module input))
         (funcs (funcs (code module)))
         (g (second funcs)))
    (set-vars-written (set-callgraph funcs))
    (is (and (written (first (params g)))
             (constant-p (second (params g)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-module</span> (input)
  (<span style="color: #a020f0;">let</span> ((module (parse-mcpl input)))
    (set-parents module)
    (resolve-calls module nil)
    (resolve-vars module nil)
    (set-cfgraphs module)
    module))

(test aliases
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                   module a;</span>

<span style="color: #8b2252;">                   perfect void f(int n, float[n] a) {</span>
<span style="color: #8b2252;">                     float[n] b = a;</span>
<span style="color: #8b2252;">                     b[0] = 0.0;</span>
<span style="color: #8b2252;">                   }"</span>)
         (module (get-module input))
         (funcs (funcs (code module)))
         (f (first funcs)))
    (set-vars-written (set-callgraph funcs))
    (is (and (constant-p (first (params f)))
             (written (second (params f)))))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org9cd7325" class="outline-4">
<h4 id="org9cd7325"><span class="section-number-4">7.1.3</span> set callgraph</h4>
<div class="outline-text-4" id="text-7-1-3">
</div>
<div id="outline-container-org7c8a434" class="outline-5">
<h5 id="org7c8a434"><span class="section-number-5">7.1.3.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:set-callgraph</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:set-callgraph</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org905c73f" class="outline-5">
<h5 id="org905c73f"><span class="section-number-5">7.1.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-edges</span> (callgraph func calls)
  (<span style="color: #a020f0;">dolist</span> (c calls)
    (<span style="color: #a020f0;">let</span> ((calling-func (get-func c)))
      (add-edge-between-vertexes callgraph calling-func func))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-callgraph</span> (funcs)
  (log-micro-pass <span style="color: #8b2252;">"set-callgraph"</span> funcs)
  (<span style="color: #a020f0;">let</span> ((callgraph (make-callgraph)))
    (<span style="color: #a020f0;">dolist</span> (f funcs)
      (add-edges callgraph f (called-by f))
      (add-vertex callgraph f))
    callgraph))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org75b51a7" class="outline-4">
<h4 id="org75b51a7"><span class="section-number-4">7.1.4</span> resolve calls</h4>
<div class="outline-text-4" id="text-7-1-4">
</div>
<div id="outline-container-org5ecd942" class="outline-5">
<h5 id="org5ecd942"><span class="section-number-5">7.1.4.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:resolve-calls</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:resolve-exports</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:awhen</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:resolve-calls</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8fcf0c6" class="outline-5">
<h5 id="org8fcf0c6"><span class="section-number-5">7.1.4.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">let</span> (funcs resolve-imported-func)

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">lookup</span> (call)
    (<span style="color: #a020f0;">with-slots</span> (id) call
      (<span style="color: #a020f0;">dolist</span> (f funcs)
        (<span style="color: #a020f0;">when</span> (ast= id (id f))
          (<span style="color: #a020f0;">return-from</span> lookup f)))
      (<span style="color: #a020f0;">let</span> ((resolved-func (funcall resolve-imported-func id)))
        (<span style="color: #a020f0;">cond</span> (resolved-func
               resolved-func)
              ((builtin-func-p id)
               nil)
              (t
               (undefined-func-error
                (location id) <span style="color: #8b2252;">"Unkown function: ~a"</span> (name id)))))))

  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve-bw</span> (ast))
  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve-fw</span> (ast))

  (defvisitor resolve-bw ast (ast string list number symbol) 
    nil)
  (defvisitor resolve-fw ast (ast string list number symbol) 
    t)



  (defvisitor resolve-fw call (call)
    (awhen (lookup call)
      (check-parameters call it)
      (setf (func call) it)
      (pushnew call (called-by it)))
    t)


  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-calls</span> (module exports)
    (log-micro-pass <span style="color: #8b2252;">"resolve-calls"</span> module)
    (setf funcs (funcs (code module)))
    (setf resolve-imported-func (get-resolve-func exports))
    (visit module #'resolve-fw #'resolve-bw)
    module))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-resolve-func</span> (exports)
  #'(<span style="color: #a020f0;">lambda</span> (id) (resolve-exports (imports (get-module id)) id exports)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-parameters</span> (call func)
  (<span style="color: #a020f0;">when</span> (not (eql (length (params call)) (length (params func))))
    (unequal-nr-params-error (location call)
                <span style="color: #8b2252;">"The number of parameters does not match for function call ~a"</span>
                (name (id call)))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org47e2704" class="outline-5">
<h5 id="org47e2704"><span class="section-number-5">7.1.4.3</span> Testing resolving calls</h5>
<div class="outline-text-5" id="text-7-1-4-3">
</div>
<ul class="org-ul">
<li><a id="org09a72c6"></a>The package<br />
<div class="outline-text-6" id="text-org09a72c6">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-resolve-calls</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>
        <span style="color: #483d8b;">:resolve-calls</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-resolve-calls</span>))
</pre>
</div>
</div>
</li>

<li><a id="orgc40feea"></a>The functionality<br />
<div class="outline-text-6" id="text-orgc40feea">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite resolve-calls)
(in-suite resolve-calls)

(test resolve-calls
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>

<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                  }</span>

<span style="color: #8b2252;">                  perfect void g() {</span>
<span style="color: #8b2252;">                      f();</span>
<span style="color: #8b2252;">                  }"</span>)
         (module (parse-mcpl input))
         (funcs (funcs (code (resolve-calls module #'(<span style="color: #a020f0;">lambda</span> (id) (<span style="color: #a020f0;">declare</span> (ignore id)) nil)))))
         (f (first funcs))
         (g (second funcs)))
    (is (and (null (called-by g))
             (eql (length (called-by f)) 1)
             (eq (func (first (called-by f))) f)))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgf498ba9" class="outline-4">
<h4 id="orgf498ba9"><span class="section-number-4">7.1.5</span> Resolve Types</h4>
<div class="outline-text-4" id="text-7-1-5">
</div>
<div id="outline-container-org39950e6" class="outline-5">
<h5 id="org39950e6"><span class="section-number-5">7.1.5.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-5-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:resolve-types</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:resolve-exports</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:resolve-types</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org18c0f04" class="outline-5">
<h5 id="org18c0f04"><span class="section-number-5">7.1.5.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-5-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve-bw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve-fw</span> (ast))

(defvisitor resolve-bw ast (ast string list number symbol) 
  nil)
(defvisitor resolve-fw ast (ast string list number symbol) 
  t)

(<span style="color: #a020f0;">let</span> (typedefs funcs resolve-imported-func)
  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-types</span> (module exports)
    (log-micro-pass <span style="color: #8b2252;">"resolve-types"</span> module)
    (setf funcs (funcs (code module)))
    (setf resolve-imported-func (get-resolve-imported-func exports))
    (visit module #'resolve-fw #'resolve-bw)
    module)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve-fw</span> ((td typedef))
    (push td typedefs)
    t)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve-fw</span> ((ct custom-type))
    (setf (typedef ct) (lookup (id ct)))
    t)

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">lookup</span> (id)
    (<span style="color: #a020f0;">dolist</span> (td typedefs)
      (<span style="color: #a020f0;">when</span> (ast= id (id td))
        (<span style="color: #a020f0;">return-from</span> lookup td)))
    (<span style="color: #a020f0;">let</span> ((resolved-typedef (funcall resolve-imported-func id)))
      (aif resolved-typedef
           it
           (undefined-type-error (location id) <span style="color: #8b2252;">"Unkown type: ~a"</span> (name id))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-resolve-imported-func</span> (exports)
  #'(<span style="color: #a020f0;">lambda</span> (id) (resolve-exports (imports (get-module id)) id exports)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org7a307e3" class="outline-4">
<h4 id="org7a307e3"><span class="section-number-4">7.1.6</span> Resolve Vars</h4>
<div class="outline-text-4" id="text-7-1-6">
</div>
<div id="outline-container-orgc9ba63b" class="outline-5">
<h5 id="orgc9ba63b"><span class="section-number-5">7.1.6.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-6-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:resolve-vars</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:query-hdl-mcpl</span>
        <span style="color: #483d8b;">:resolve-exports</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:resolve-vars</span> <span style="color: #483d8b;">:skip</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org759da8e" class="outline-5">
<h5 id="org759da8e"><span class="section-number-5">7.1.6.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-6-2">
<p>
In this package we are resolving variables, which means that we are going to
map it to their declarations.  We define a visitor <code>define-fw/bw</code> that walks
the AST.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">define-bw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">define-fw</span> (ast))

(defvisitor define-bw ast (ast string list number symbol) 
  nil)
(defvisitor define-fw ast (ast string list number symbol) 
  t)
</pre>
</div>

<p>
The function <code>resolve-vars</code> operates on a module.  This is necessary as in any
AST form, there may be references to declarations higher-up in the tree. 
</p>

<p>
We keep a list of scopes with declarations.  Each scope represents a list of
declarations with the found declarations in this scope.  The <code>resolve-vars</code>
function initializes this with an empty list and starts visiting the AST.  Each
new scope that is introduced, we push a new empty list of declarations onto the
list of scopes.
</p>

<p>
As soon as we discover a variable, we will search the declarations for a match.
We start with the first scope and continue until we have seen all scopes.  If
we found a match, we return the basic declaration, otherwise we throw an error.
</p>

<p>
To be able to do this, we have to associate each <code>basic-decl</code> with its <code>decl</code>.
This is easy with <code>normal-decls</code> and <code>assign-decls</code>, but more difficult with
<code>as</code> statements.  As soon we discover an <code>as</code> statement, we request the <code>decl</code>
of its variable and add the <code>basic-decls</code> of the <code>as</code> statement to the list of
<code>as-basic-decls</code> of the <code>decl</code>.
</p>

<p>
This means that if we find a declaration, we register the declaration with each
of its basic-declarations and we push the declaration to the first scope in the
<code>scopes-with-declaration</code> variable.  If we discover an <code>as</code> statement, we
should be able to resolve the variable, and hence retrieve its <code>decl</code>.  We then
set up all the links.
</p>

<p>
If we find a variable, we resolve it, find its basic-declaration and register
it with this variable.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*scopes-with-declarations*</span> (list nil))
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*get-constant-decl-func*</span> (constantly nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-vars</span> (module exports)
  <span style="color: #8b2252;">"Resolve variables in a module based on exports."</span>
  (log-micro-pass <span style="color: #8b2252;">"resolve-vars"</span> module)
  (setf *scopes-with-declarations* (list nil))
  (setf *get-constant-decl-func* (constant-decl-func exports))
  (visit module #'define-fw #'define-bw)
  module)
</pre>
</div>

<p>
The function below creates a function that resolve identifiers for constants.
These constants can be defined in the module, but also in other files.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">constant-decl-func</span> (exports)
  #'(<span style="color: #a020f0;">lambda</span> (id)
      (<span style="color: #a020f0;">if</span> (const-id-p id)
          (aif (resolve-exports (imports (get-module id)) id exports)
               (decl it)
               nil)
          nil)))

(defvisitor define-fw ast (func code-block foreach-stat for-stat typedef)
  (push '() *scopes-with-declarations*)
  t)

(defvisitor define-bw ast (func code-block foreach-stat for-stat typedef)
  (pop *scopes-with-declarations*))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve</span> (var))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-with-error</span> (ast)
  (aif (resolve ast)
       it
       (undeclared-var-error (location ast)
                   <span style="color: #8b2252;">"variable ~a is not declared"</span> (name (get-id ast)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((id id))
  (<span style="color: #a020f0;">with-slots</span> (name location) id
      (<span style="color: #a020f0;">dolist</span> (decls *scopes-with-declarations*)
        (<span style="color: #a020f0;">dolist</span> (d decls)
          (<span style="color: #a020f0;">dolist</span> (bd (get-basic-decls d))
            (<span style="color: #a020f0;">when</span> (equal (name (id bd)) name)
              (<span style="color: #a020f0;">return-from</span> resolve bd)))))
      (aif (funcall *get-constant-decl-func* id)
           (basic-decl it)
           (values nil name location))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((bv basic-var))
  (resolve (get-id bv)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((bd basic-decl))
  (resolve (get-id bd)))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((v var))
  (<span style="color: #a020f0;">if</span> (var-in-dot-var-p v)
      (resolve-in-dot-var v)
      (resolve (basic-var v))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">var-in-dot-var-p</span> (v)
  (<span style="color: #a020f0;">let</span> ((parent (parent v)))
    (and (typep parent 'dot-var)
         (eq v (var parent)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">error-already-declared</span> (loc id)
  (already-declared-error loc <span style="color: #8b2252;">"~a already declared"</span> (name id)))

(defvisitor define-fw d (normal-decl)
  (<span style="color: #a020f0;">dolist</span> (bd (basic-decls d))
    (<span style="color: #a020f0;">with-slots</span> (id location) bd
      (<span style="color: #a020f0;">when</span> (resolve bd)
        (error-already-declared (location bd) id))
      (setf (decl bd) d)))
  (push d (first *scopes-with-declarations*))
  t)

(defvisitor define-fw d (assign-decl)
  (<span style="color: #a020f0;">with-slots</span> (basic-decl) d
    (<span style="color: #a020f0;">with-slots</span> (id location) basic-decl
      (<span style="color: #a020f0;">when</span> (resolve basic-decl)
        (error-already-declared location id)))
    (setf (decl (basic-decl d)) d)
    (push d (first *scopes-with-declarations*)))
  t)


(defvisitor define-fw as (as-stat)
  (<span style="color: #a020f0;">with-slots</span> (var basic-decls) as
    (<span style="color: #a020f0;">let</span> ((d (decl (resolve-with-error var))))
      (setf (as-basic-decls d) (append (as-basic-decls d) basic-decls))
      (<span style="color: #a020f0;">dolist</span> (bd basic-decls)
        (setf (decl bd) d))))
  t)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-decls</span> (bd v)
  (setf (basic-decl (basic-var v)) bd)
  (push v (vars bd)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">define-fw</span> ((v normal-var))
  (<span style="color: #a020f0;">restart-case</span>
      (<span style="color: #a020f0;">let</span> ((bd (resolve-with-error v)))
        (set-decls bd v))
    (skip () nil))
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">define-fw</span> ((v dot-var))
  (<span style="color: #a020f0;">if</span> (hardware-description-var-p v)
      (<span style="color: #a020f0;">progn</span>
        (check-hwd-var v)
        nil)
      (<span style="color: #a020f0;">let</span> ((bd (resolve-with-error (basic-var v))))
        (set-decls bd v)
        t)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-in-dot-var</span> (v)
  (<span style="color: #a020f0;">let*</span> ((dot-var (parent v))
         (bd-dot-var (resolve-with-error (basic-var dot-var)))
         (type-dot-var (get-base-type (mcl-type bd-dot-var))))
    (<span style="color: #a020f0;">if</span> (typep type-dot-var 'custom-type)
        (<span style="color: #a020f0;">let</span> ((*scopes-with-declarations* 
               (list (fields (typedef type-dot-var)))))
          (resolve-with-error (basic-var v)))
        (<span style="color: #a020f0;">let</span> ((id (get-id dot-var)))
          (non-primitive-type-error
           (location (get-id v))
           <span style="color: #8b2252;">"Expecting a non-primitive type for variable ~a."</span>
           (name id))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-hwd-var</span> (hwd-var)
  (<span style="color: #a020f0;">when</span> (not (resolve-hardware-description-var hwd-var))
    (undefined-hardware-description-var-error
     (location hwd-var)
     <span style="color: #8b2252;">"unknown hardware description variable."</span> hwd-var)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org59ffd2d" class="outline-4">
<h4 id="org59ffd2d"><span class="section-number-4">7.1.7</span> loading hardware descriptions</h4>
<div class="outline-text-4" id="text-7-1-7">
</div>
<div id="outline-container-org99d7259" class="outline-5">
<h5 id="org99d7259"><span class="section-number-5">7.1.7.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-7-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:load-hardware-descriptions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:mcl-util</span> <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-hdl</span>
        <span style="color: #483d8b;">:hardware-descriptions</span> <span style="color: #483d8b;">:parse-hdl</span> <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:replace-id-stats</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:awhen</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:cl-fad</span> <span style="color: #483d8b;">:file-exists-p</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:load-hardware-description</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaaa5644" class="outline-5">
<h5 id="orgaaa5644"><span class="section-number-5">7.1.7.2</span> Loading a hardware description</h5>
<div class="outline-text-5" id="text-7-1-7-2">
<p>
Loading a hardware description has several components.  First, we parse the hdl
file, after which we can set the parents in the AST.  We can then load the
parent hardware description.  After we have loaded all parent hardware
descriptions we, make it available to the hardware description library, after
which we can replace the <code>id-stats</code> of the hardware description with the blocks
they are referring to.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">load-hardware-description</span> (name-hwd)
  (aif (get-hardware-description-by-name name-hwd)
       it
       (load-hardware-description-real name-hwd)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">load-hardware-description-real</span> (name-hwd)
  (<span style="color: #a020f0;">let</span> ((filename (format nil <span style="color: #8b2252;">"~a/~a.hdl"</span> (getenv <span style="color: #8b2252;">"HDL_DIR"</span>) name-hwd)))
    (<span style="color: #a020f0;">unless</span> (file-exists-p filename)
      (mcl-error nil <span style="color: #8b2252;">"Unknown hardware-description: ~a"</span> name-hwd))
    (<span style="color: #a020f0;">let</span> ((hwd (parse-hdl-file filename)))
      (awhen (get-parent-hardware-description hwd)
        (load-hardware-description it))
      (save-hardware-description name-hwd hwd)
      (set-parents hwd)
      (replace-id-stats hwd)
      hwd)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org3963fe2" class="outline-4">
<h4 id="org3963fe2"><span class="section-number-4">7.1.8</span> replace identifier statements</h4>
<div class="outline-text-4" id="text-7-1-8">
</div>
<div id="outline-container-org8f4f324" class="outline-5">
<h5 id="org8f4f324"><span class="section-number-5">7.1.8.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-8-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:replace-id-stats</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-hdl</span> <span style="color: #483d8b;">:hardware-descriptions</span> <span style="color: #483d8b;">:set-parents</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:replace-id-stats</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf3ee314" class="outline-5">
<h5 id="orgf3ee314"><span class="section-number-5">7.1.8.2</span> Replacing identifier statements</h5>
<div class="outline-text-5" id="text-7-1-8-2">
<p>
A hardware description contains possibly qualified identifiers that refer to a
block.  This pass ensures that those statements are replaced by their blocks.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-bw</span> (ast))

(<span style="color: #a020f0;">let</span> (the-hwd)
  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">replace-id-stats</span> (hwd)
    <span style="color: #8b2252;">"Replace id-stats in hardware description hwd with the blocks they are</span>
<span style="color: #8b2252;">referring to."</span>
    (setf the-hwd hwd)
    (visit-breadth-first the-hwd #'replace-fw #'replace-bw)
    the-hwd)


  (defvisitor replace-fw ast (ast string list symbol number)
    t)

  (defvisitor replace-bw ast (ast string list symbol number)
    nil)

  (defvisitor replace-bw id-stat (id-stat)
    (<span style="color: #a020f0;">let*</span> ((resolved-block (resolve id-stat the-hwd))
           (replacement-block (<span style="color: #a020f0;">if</span> (inherited-id id-stat)
                                  (set-parents (copy-ast resolved-block))
                                  resolved-block)))
      (replace-in-ast id-stat <span style="color: #483d8b;">:with</span> replacement-block)
      (<span style="color: #a020f0;">unless</span> (inherited-id id-stat)
        (remove-from-ast replacement-block))
      (setf (parent replacement-block) (parent id-stat)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org50f91d7" class="outline-5">
<h5 id="org50f91d7"><span class="section-number-5">7.1.8.3</span> Testing replacing identifier statements</h5>
<div class="outline-text-5" id="text-7-1-8-3">
</div>
<ul class="org-ul">
<li><a id="orgb78646b"></a>The package<br />
<div class="outline-text-6" id="text-orgb78646b">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-replace-id-stats</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-hdl</span> <span style="color: #483d8b;">:parse-hdl</span> <span style="color: #483d8b;">:set-parents</span>
        <span style="color: #483d8b;">:replace-id-stats</span> <span style="color: #483d8b;">:hardware-descriptions</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-replace-id-stats</span>))
</pre>
</div>
</div>
</li>

<li><a id="org9db0912"></a>The tests<br />
<div class="outline-text-6" id="text-org9db0912">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite replace-id-stats <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite replace-id-stats)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hwd</span> ()
  (set-parents (parse-hdl <span style="color: #8b2252;">"</span>
<span style="color: #8b2252;">hardware_description perfect;</span>

<span style="color: #8b2252;">device perfect {</span>
<span style="color: #8b2252;">  mem;</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">memory mem {</span>
<span style="color: #8b2252;">  capacity = unlimited B;</span>
<span style="color: #8b2252;">}"</span>)))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*result*</span> (set-parents (parse-hdl <span style="color: #8b2252;">"</span>
<span style="color: #8b2252;">hardware_description perfect;</span>

<span style="color: #8b2252;">device perfect {</span>
<span style="color: #8b2252;">  memory mem {</span>
<span style="color: #8b2252;">    capacity = unlimited B;</span>
<span style="color: #8b2252;">  }</span>
<span style="color: #8b2252;">}"</span>)))


(test simple ()
  (is
    (ast= (replace-id-stats (hwd)) *result*)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">lower-level-hwd</span> ()
  (save-hardware-description <span style="color: #8b2252;">"perfect"</span> (hwd))
  (save-hardware-description <span style="color: #8b2252;">"lower"</span> (set-parents (parse-hdl <span style="color: #8b2252;">"</span>
<span style="color: #8b2252;">hardware_description lower;</span>

<span style="color: #8b2252;">device lower {</span>
<span style="color: #8b2252;">  perfect.mem;</span>
<span style="color: #8b2252;">}"</span>))))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*result-lower-level*</span> (set-parents (parse-hdl <span style="color: #8b2252;">"</span>
<span style="color: #8b2252;">hardware_description lower;</span>

<span style="color: #8b2252;">device lower {</span>
<span style="color: #8b2252;">  memory mem {</span>
<span style="color: #8b2252;">    capacity = unlimited B;</span>
<span style="color: #8b2252;">  }</span>
<span style="color: #8b2252;">}"</span>)))

(test inheritance
  (<span style="color: #a020f0;">let</span> ((hardware-descriptions::*hardware-descriptions*
         (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (is (ast= (replace-id-stats (lower-level-hwd)) *result-lower-level*))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hwd-dependent</span> ()
  (set-parents (parse-hdl <span style="color: #8b2252;">"</span>
<span style="color: #8b2252;">hardware_description perfect;</span>

<span style="color: #8b2252;">device perfect {</span>
<span style="color: #8b2252;">  mem;</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">memory mem {</span>
<span style="color: #8b2252;">  mem2;</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">memory mem2 {</span>
<span style="color: #8b2252;">  capacity = 1 B;</span>
<span style="color: #8b2252;">}"</span>)))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*result-dependent*</span> (set-parents (parse-hdl <span style="color: #8b2252;">"</span>
<span style="color: #8b2252;">hardware_description perfect;</span>

<span style="color: #8b2252;">device perfect {</span>
<span style="color: #8b2252;">  memory mem {</span>
<span style="color: #8b2252;">    memory mem2 {</span>
<span style="color: #8b2252;">      capacity = 1 B;</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">  }</span>
<span style="color: #8b2252;">}"</span>)))

(test dependent
  (is (ast= (replace-id-stats (hwd-dependent)) *result-dependent*)))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org08d1264" class="outline-4">
<h4 id="org08d1264"><span class="section-number-4">7.1.9</span> set control flow graphs</h4>
<div class="outline-text-4" id="text-7-1-9">
</div>
<div id="outline-container-org9a754e5" class="outline-5">
<h5 id="org9a754e5"><span class="section-number-5">7.1.9.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-9-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:set-cfgraphs</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:controlflow</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:last-elt</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:set-cfgraphs</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2895933" class="outline-5">
<h5 id="org2895933"><span class="section-number-5">7.1.9.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-9-2">
<p>
We can define several different controlflow graphs.  First, we can choose
between the representation of a foreach statement, as a loop or one basic
block.  Second, we can view the controlflow optimistically, that is, a for loop
is always executed at least once.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">let</span> (cfgraph entries exits optimistic2 foreach-summarized2)

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-entry</span> (param)
    (<span style="color: #a020f0;">typecase</span> param
      (bb param)
      (ast (gethash param entries))
      (cons (get-entry (first param)))))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-exits</span> (param)
    (<span style="color: #a020f0;">typecase</span> param
      (bb (list param))
      (ast (gethash param exits))
      (cons (get-exits (last-elt param)))))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">true-bb</span> (form)
    (and (not (null form))
         (not (null (get-entry form)))))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">connect</span> (<span style="color: #228b22;">&amp;rest</span> params)
    (<span style="color: #a020f0;">let</span> ((params-wo-nil (filter #'true-bb params)))
      (<span style="color: #a020f0;">loop</span> for (a b) on params-wo-nil
         while b 
         collect (<span style="color: #a020f0;">unless</span> (null b)
                   (<span style="color: #a020f0;">dolist</span> (i (get-exits a))
                     (add-edge-between-vertexes cfgraph
                                                i (get-entry b)))))))




  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">record-cfgraph-fw</span> (ast))

  (defvisitor record-cfgraph-fw ast (ast string list number symbol)
    t)

  (defvisitor record-cfgraph-fw f (func)
    (setf cfgraph (make-cfgraph))
    (setf entries (make-hash-table))
    (setf exits (make-hash-table))
    t)


  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">record-cfgraph-bw</span> (ast))

  (defvisitor record-cfgraph-bw ast (string list number symbol)
    nil)

  (defvisitor record-cfgraph-bw ast (ast)
    nil)

  (defvisitor record-cfgraph-bw d (decl)
    (<span style="color: #a020f0;">let</span> ((bb-decl (make-bb-decl d)))
      (<span style="color: #a020f0;">if</span> (param-p d)
          (<span style="color: #a020f0;">progn</span>
            (setf (gethash d entries) bb-decl)
            (setf (gethash d exits) (list bb-decl))))))

  (defvisitor record-cfgraph-bw s (stat)
    (<span style="color: #a020f0;">let</span> ((bb-stat (make-bb-stat s)))
      (setf (gethash s entries) bb-stat)
      (setf (gethash s exits) (list bb-stat))))

  (defvisitor record-cfgraph-bw cb (code-block)
    (<span style="color: #a020f0;">let</span> ((stats (stats cb)))
      (apply #'connect stats)
      (<span style="color: #a020f0;">if</span> (not (null stats))
        (<span style="color: #a020f0;">progn</span>
          (setf (gethash cb entries) (gethash (first stats) entries))
          (setf (gethash cb exits) (gethash (last-elt stats) exits))))))

  (defvisitor record-cfgraph-bw f (for-stat)
    (<span style="color: #a020f0;">with-slots</span> (decl cond-expr inc stat) f
      (<span style="color: #a020f0;">let</span> ((bb-for-decl (make-bb-for-decl decl))
            (bb-for-cond (make-bb-for-cond cond-expr))
            (bb-for-inc (make-bb-for-inc inc)))
        (<span style="color: #a020f0;">if</span> optimistic2
            (connect bb-for-decl stat bb-for-inc bb-for-cond stat)
            (connect bb-for-decl bb-for-cond stat bb-for-inc bb-for-cond))
        (setf (gethash f entries) bb-for-decl)
        (setf (gethash f exits) (list bb-for-cond)))))

  (defvisitor record-cfgraph-bw fe (foreach-stat)
    (<span style="color: #a020f0;">if</span> foreach-summarized2
        (record-foreach-summarized fe)
        (record-foreach-regular fe)))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">record-foreach-summarized</span> (fe)
    (<span style="color: #a020f0;">let</span> ((bb (make-bb-foreach fe)))
      (setf (gethash fe entries) bb)
      (setf (gethash fe exits) (list bb))))


  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">record-foreach-regular</span> (fe)
    (<span style="color: #a020f0;">with-slots</span> (decl nr-iters stat) fe
      (<span style="color: #a020f0;">let</span> ((bb-fe-size (make-bb-foreach-size nr-iters))
            (bb-fe-decl (make-bb-foreach-decl decl)))
        (connect bb-fe-size bb-fe-decl stat bb-fe-size)
        (setf (gethash fe entries) bb-fe-size)
        (setf (gethash fe exits) (list bb-fe-size)))))

  (defvisitor record-cfgraph-bw is (if-stat)
    (<span style="color: #a020f0;">with-slots</span> (cond-expr stat elsestat) is
      (<span style="color: #a020f0;">let</span> ((bb-cond (make-bb-if-cond cond-expr)))
        (connect bb-cond stat)
        (setf (gethash is entries) bb-cond)
        (<span style="color: #a020f0;">if</span> elsestat
            (<span style="color: #a020f0;">progn</span> (connect bb-cond elsestat)
                   (setf (gethash is exits) (concatenate 'list (get-exits stat)
                                                         (get-exits elsestat))))
            (setf (gethash is exits) (get-exits stat))))))

  (defvisitor record-cfgraph-bw bs (block-stat)
    (<span style="color: #a020f0;">with-slots</span> (code-block) bs
      (setf (gethash bs entries) (get-entry code-block))
      (setf (gethash bs exits) (get-exits code-block))))


  (defvisitor record-cfgraph-bw f (func)
    (apply #'connect (params f))
    (connect (entry cfgraph) (params f) (code-block f) (exit cfgraph))
    (setf (cfgraph f) (remove-unconnected-blocks cfgraph)))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-cfgraphs</span> (ast <span style="color: #228b22;">&amp;optional</span> (optimistic nil) (foreach-summarized nil))
    (log-micro-pass <span style="color: #8b2252;">"set-cfgraphs"</span> ast)
    (setf optimistic2 optimistic)
    (setf foreach-summarized2 foreach-summarized)
    (visit ast #'record-cfgraph-fw #'record-cfgraph-bw)
    ast))
</pre>
</div>
</div>
</div>




<div id="outline-container-org14197e5" class="outline-5">
<h5 id="org14197e5"><span class="section-number-5">7.1.9.3</span> Testing setting control flow graphs</h5>
<div class="outline-text-5" id="text-7-1-9-3">
</div>
<ul class="org-ul">
<li><a id="org66e39bd"></a>The package<br />
<div class="outline-text-6" id="text-org66e39bd">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-set-cfgraphs</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span>
        <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:build-ast</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-set-cfgraphs</span>))
</pre>
</div>
</div>
</li>

<li><a id="orgcbffaf7"></a>The tests<br />
<div class="outline-text-6" id="text-orgcbffaf7">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite set-cfgraphs <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite set-cfgraphs)

(test minimal
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph)))
    (add-edge-between-vertexes cfgraph (make-bb-entry) (make-bb-exit))
    (is
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f() {</span>
<span style="color: #8b2252;">                              }"</span>) cfgraph))))



(test decl
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
        (bb-decl (build-bb-decl <span style="color: #8b2252;">"a"</span>)))
    (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl)
    (add-edge-between-vertexes cfgraph bb-decl (make-bb-exit))
    (is
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a) {</span>
<span style="color: #8b2252;">                              }"</span>) cfgraph))))



(test decls
  (is
    (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
          (bb-decl-1 (build-bb-decl <span style="color: #8b2252;">"a"</span>))
          (bb-decl-2 (build-bb-decl <span style="color: #8b2252;">"b"</span>)))
      (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl-1)
      (add-edge-between-vertexes cfgraph bb-decl-1 bb-decl-2)
      (add-edge-between-vertexes cfgraph bb-decl-2 (make-bb-exit))
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                              }"</span>) cfgraph))))

(test stat
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
        (bb-decl-1 (build-bb-decl <span style="color: #8b2252;">"a"</span>))
        (bb-decl-2 (build-bb-decl <span style="color: #8b2252;">"b"</span>))
        (bb-stat (make-bb-stat (make-decl-stat (build-decl <span style="color: #8b2252;">"c"</span>) nil))))
    (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl-1)
    (add-edge-between-vertexes cfgraph bb-decl-1 bb-decl-2)
    (add-edge-between-vertexes cfgraph bb-decl-2 bb-stat)
    (add-edge-between-vertexes cfgraph bb-stat (make-bb-exit))
    (is
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                                  int c;</span>
<span style="color: #8b2252;">                              }"</span>) cfgraph))))

(test stats
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
        (bb-decl-1 (build-bb-decl <span style="color: #8b2252;">"a"</span>))
        (bb-decl-2 (build-bb-decl <span style="color: #8b2252;">"b"</span>))
        (bb-stat-1 (make-bb-stat (make-decl-stat (build-decl <span style="color: #8b2252;">"c"</span>) nil)))
        (bb-stat-2 (make-bb-stat (make-decl-stat (build-decl <span style="color: #8b2252;">"d"</span>) nil))))
    (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl-1)
    (add-edge-between-vertexes cfgraph bb-decl-1 bb-decl-2)
    (add-edge-between-vertexes cfgraph bb-decl-2 bb-stat-1)
    (add-edge-between-vertexes cfgraph bb-stat-1 bb-stat-2)
    (add-edge-between-vertexes cfgraph bb-stat-2 (make-bb-exit))
    (is
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                                  int c;</span>
<span style="color: #8b2252;">                                  int d;</span>
<span style="color: #8b2252;">                              }"</span>) cfgraph))))




(test foreach
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
        (bb-decl-1 (build-bb-decl <span style="color: #8b2252;">"a"</span>))
        (bb-decl-2 (build-bb-decl <span style="color: #8b2252;">"b"</span>))
        (bb-fe-size (make-bb-foreach-size
                     (make-var-expr
                      (make-normal-var
                       (make-basic-var (make-id <span style="color: #8b2252;">"a"</span> nil) nil nil) nil) <span style="color: #ff0000; font-weight: bold;">nil)))</span>
        (bb-fe-decl (make-bb-foreach-decl (build-decl <span style="color: #8b2252;">"i"</span>)))
        (bb-stat-1 (make-bb-stat (make-decl-stat (build-decl <span style="color: #8b2252;">"c"</span>) nil)))
        (bb-stat-2 (make-bb-stat (make-decl-stat (build-decl <span style="color: #8b2252;">"d"</span>) nil))))
    (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl-1)
    (add-edge-between-vertexes cfgraph bb-decl-1 bb-decl-2)
    (add-edge-between-vertexes cfgraph bb-decl-2 bb-fe-size)
    (add-edge-between-vertexes cfgraph bb-fe-size bb-fe-decl)
    (add-edge-between-vertexes cfgraph bb-fe-decl bb-stat-1)
    (add-edge-between-vertexes cfgraph bb-stat-1 bb-fe-size)
    (add-edge-between-vertexes cfgraph bb-fe-size bb-stat-2)
    (add-edge-between-vertexes cfgraph bb-stat-2 (make-bb-exit))
    (is 
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                                  foreach (int i in a threads) {</span>
<span style="color: #8b2252;">                                      int c;</span>
<span style="color: #8b2252;">                                  }</span>
<span style="color: #8b2252;">                                  int d;</span>
<span style="color: #8b2252;">                              }"</span>) cfgraph))))



(test for
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
        (bb-decl-1 (build-bb-decl <span style="color: #8b2252;">"a"</span>))
        (bb-decl-2 (build-bb-decl <span style="color: #8b2252;">"b"</span>))
        (bb-for-decl (make-bb-for-decl
                      (make-assign-decl
                       nil
                       (make-basic-decl
                        (make-int nil) (make-id <span style="color: #8b2252;">"i"</span> nil) nil)
                       (make-int-constant 0 nil)
                       nil)))
        (bb-for-cond (make-bb-for-cond
                      (make-lt
                       (build-expr <span style="color: #8b2252;">"i"</span>)
                       (build-expr <span style="color: #8b2252;">"a"</span>) nil)))
        (bb-for-inc (make-bb-for-inc
                     (make-inc (make-normal-var
                                  (make-basic-var
                                   (make-id <span style="color: #8b2252;">"i"</span> nil) nil nil) <span style="color: #ff0000; font-weight: bold;">nil) t nil)))</span>
        (bb-stat-1 (make-bb-stat (make-decl-stat (build-decl <span style="color: #8b2252;">"c"</span>) nil)))
        (bb-stat-2 (make-bb-stat (make-decl-stat (build-decl <span style="color: #8b2252;">"d"</span>) nil))))
    (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl-1)
    (add-edge-between-vertexes cfgraph bb-decl-1 bb-decl-2)
    (add-edge-between-vertexes cfgraph bb-decl-2 bb-for-decl)
    (add-edge-between-vertexes cfgraph bb-for-decl bb-for-cond)
    (add-edge-between-vertexes cfgraph bb-for-cond bb-stat-1)
    (add-edge-between-vertexes cfgraph bb-stat-1 bb-for-inc)
    (add-edge-between-vertexes cfgraph bb-for-inc bb-for-cond)
    (add-edge-between-vertexes cfgraph bb-for-cond bb-stat-2)
    (add-edge-between-vertexes cfgraph bb-stat-2 (make-bb-exit))
    (is 
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                                  for (int i = 0; i &lt; a; i++) {</span>
<span style="color: #8b2252;">                                      int c;</span>
<span style="color: #8b2252;">                                  }</span>
<span style="color: #8b2252;">                                  int d;</span>
<span style="color: #8b2252;">                              }"</span>) cfgraph))))



</pre>
</div>


<p>
The following code iss the summarized controlflow graphs:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(test summarized
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
        (bb-foreach (make-bb-foreach
                     (build-foreach <span style="color: #8b2252;">"i"</span> <span style="color: #8b2252;">"a"</span>
                                    (list (make-decl-stat (build-decl <span style="color: #8b2252;">"c"</span>))))))
        (bb-decl-1 (build-bb-decl <span style="color: #8b2252;">"a"</span>))
        (bb-decl-2 (build-bb-decl <span style="color: #8b2252;">"b"</span>)))
    (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl-1)
    (add-edge-between-vertexes cfgraph bb-decl-1 bb-decl-2)
    (add-edge-between-vertexes cfgraph bb-decl-2 bb-foreach)
    (add-edge-between-vertexes cfgraph bb-foreach (make-bb-exit))
    (is
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                                  foreach (int i in a threads) {</span>
<span style="color: #8b2252;">                                      int c;</span>
<span style="color: #8b2252;">                                  }</span>
<span style="color: #8b2252;">                              }"</span> nil t) cfgraph))))

(test summarized-multiple-statements
  (<span style="color: #a020f0;">let</span> ((cfgraph (make-cfgraph))
        (bb-foreach (make-bb-foreach
                     (build-foreach <span style="color: #8b2252;">"i"</span> <span style="color: #8b2252;">"a"</span>
                                    (list (make-decl-stat (build-decl <span style="color: #8b2252;">"c"</span>))
                                          (make-decl-stat (build-decl <span style="color: #8b2252;">"d"</span>))))))
        (bb-decl-1 (build-bb-decl <span style="color: #8b2252;">"a"</span>))
        (bb-decl-2 (build-bb-decl <span style="color: #8b2252;">"b"</span>)))
    (add-edge-between-vertexes cfgraph (make-bb-entry) bb-decl-1)
    (add-edge-between-vertexes cfgraph bb-decl-1 bb-decl-2)
    (add-edge-between-vertexes cfgraph bb-decl-2 bb-foreach)
    (add-edge-between-vertexes cfgraph bb-foreach (make-bb-exit))
    (is
      (cfgraph= (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                              module a;</span>
<span style="color: #8b2252;">                              perfect void f(int a, int b) {</span>
<span style="color: #8b2252;">                                  foreach (int i in a threads) {</span>
<span style="color: #8b2252;">                                      int c;</span>
<span style="color: #8b2252;">                                      int d;</span>
<span style="color: #8b2252;">                                  }</span>
<span style="color: #8b2252;">                              }"</span> nil t) cfgraph))))


</pre>
</div>



<p>
Helper functions:
</p>



<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-cfgraph</span> (input <span style="color: #228b22;">&amp;optional</span> optimistic foreach-summarized)
  (<span style="color: #a020f0;">let</span> ((module (set-cfgraphs (set-parents (parse-mcpl input))
                              optimistic foreach-summarized)))
    (cfgraph (first (funcs (code module))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-bb-decl</span> (name)
  (make-bb-decl (build-decl name)))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org02839a7" class="outline-4">
<h4 id="org02839a7"><span class="section-number-4">7.1.10</span> set parents</h4>
<div class="outline-text-4" id="text-7-1-10">
</div>
<div id="outline-container-org67b2376" class="outline-5">
<h5 id="org67b2376"><span class="section-number-5">7.1.10.1</span> The package</h5>
<div class="outline-text-5" id="text-7-1-10-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:set-parents</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:set-parents</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcdb8156" class="outline-5">
<h5 id="orgcdb8156"><span class="section-number-5">7.1.10.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-1-10-2">
<p>
In function <code>set-parents</code>, the list of parents is initially set to zero and
then the current AST form is pushed as parent.  In this way, the parent of the
current AST will be maintained.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">let</span> ((parents nil))
  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-parent-fw</span> (ast))
  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-parent-bw</span> (ast))

  (defvisitor set-parent-fw ast (string list number symbol)
    t)

  (defvisitor set-parent-bw ast (string list number symbol)
    nil)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">set-parent-fw</span> ((ast ast))
    (setf (parent ast) (first parents))
    (push ast parents)
    t)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">set-parent-bw</span> ((i ast))
    (pop parents))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-parents</span> (ast)
    <span style="color: #8b2252;">"Sets the parents of an AST form."</span>
    (log-micro-pass <span style="color: #8b2252;">"set-parents"</span> ast)
    (setf parents nil)
    (push (parent ast) parents)
    (visit ast #'set-parent-fw #'set-parent-bw)
    ast))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org5eb12ac" class="outline-3">
<h3 id="org5eb12ac"><span class="section-number-3">7.2</span> Checking</h3>
<div class="outline-text-3" id="text-7-2">
<p>
This section has several micro-passes that do some form of checking.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org4bdff6f">7.2.1. Checking types</a></li>
<li><a href="#org56c04e5">7.2.2. Checking memory spaces</a></li>
<li><a href="#org69bede2">7.2.3. check package</a></li>
<li><a href="#org0f8ed49">7.2.4. check exports</a></li>
</ul>
</div>
</div>


<div id="outline-container-org4bdff6f" class="outline-4">
<h4 id="org4bdff6f"><span class="section-number-4">7.2.1</span> Checking types</h4>
<div class="outline-text-4" id="text-7-2-1">
</div>
<div id="outline-container-orgb078eb0" class="outline-5">
<h5 id="orgb078eb0"><span class="section-number-5">7.2.1.1</span> The package</h5>
<div class="outline-text-5" id="text-7-2-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:check-types</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:errors</span>
        <span style="color: #483d8b;">:flatten-types</span> <span style="color: #483d8b;">:print-pretty</span> <span style="color: #483d8b;">:fold-constants</span> <span style="color: #483d8b;">:simplify-expressions</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:string-case</span> <span style="color: #483d8b;">:string-case</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:def-methods</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:awhen</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:check-types</span> <span style="color: #483d8b;">:get-type</span> <span style="color: #483d8b;">:primitive-p</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf79dd4" class="outline-5">
<h5 id="orgbf79dd4"><span class="section-number-5">7.2.1.2</span> Walking the AST</h5>
<div class="outline-text-5" id="text-7-2-1-2">
<p>
The following code shows the code to walk the AST for checking types.  This is
done in bottom-up fashion to make sure that an expression knows the types of
their sub-expressions.  The following function is the main entry function that
takes as input a module and returns the modified module with a list of messages
with type errors.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun check-types (module)</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">"Check the types of a module."</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(let (messages)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(flet ((add-to-messages (c)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">          (push c messages)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">          (invoke-restart 'add-to-messages)))</span>
<span style="color: #b22222;">;;       </span><span style="color: #b22222;">(handler-bind ((mcpl-type-error #'add-to-messages)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">                  (numeric-type-error #'add-to-messages))</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">     (restart-case (visit module #'check-fw #'check-bw)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">       (add-to-messages nil ()))</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">     (values module (nreverse messages))))))</span>

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-types</span> (ast)
  <span style="color: #8b2252;">"Check the types of the AST form."</span>
  (log-micro-pass <span style="color: #8b2252;">"check-types"</span> ast)
  (visit ast #'check-fw #'check-bw)
  ast)
</pre>
</div>

<p>
The visitor functions are listed below.  Unknown AST forms, strings, lists,
numbers, and symbols are ignored.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-bw</span> (ast))

(defvisitor check-fw ast (ast string list number symbol)
  t)

(defvisitor check-bw ast (ast string list number symbol)
  nil)
</pre>
</div>

<p>
Constant expressions simply get their type.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw ic (int-constant)
  (set-type ic (make-int)))

(defvisitor check-bw fc (float-constant)
  (set-type fc (make-flt)))

(defvisitor check-bw bc (bool-constant)
  (set-type bc (make-bool)))
</pre>
</div>

<p>
Below are the expressions listed with numeric types.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw m (minus)
  (<span style="color: #a020f0;">let</span> ((expr (e m)))
    (check-numeric-type expr)
    (set-type m (eval-type expr))))

(defvisitor check-bw n (neg)
  (<span style="color: #a020f0;">let</span> ((expr (e n)))
    (<span style="color: #a020f0;">with-slots</span> (eval-type) expr
      (expect (location n) (make-bool) eval-type)
      (set-type n eval-type))))

(defvisitor check-bw b (mul add sub div bitand bitor bitshl bitshr)
  (<span style="color: #a020f0;">with-slots</span> (l r) b
    (set-type b (compute-type-numeric-op l r))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((p pow))
  (<span style="color: #a020f0;">with-slots</span> (l r) p
    (check-numeric-type l)
    (check-numeric-type r)
    (<span style="color: #a020f0;">let</span> ((int-type (make-int)))
      (<span style="color: #a020f0;">if</span> (and (ast= (eval-type l) int-type)
               (ast= (eval-type r) int-type))
          (set-type p int-type)
          (set-type p (make-flt))))))

(defvisitor check-bw e (equ lt gt le ge)
  (<span style="color: #a020f0;">with-slots</span> (l r) e
    (check-numeric-type l)
    (check-numeric-type r)
    (set-type e (make-bool))))

(defvisitor check-bw e (log-and log-or)
  (<span style="color: #a020f0;">let</span> ((expected-type (make-bool)))
    (<span style="color: #a020f0;">with-slots</span> (l r) e
      (expect (location l) expected-type (eval-type l))
      (expect (location r) expected-type (eval-type r))
      (set-type e expected-type))))
</pre>
</div>

<p>
Variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw ve (var-expr)
  (set-type ve (get-type (var ve))))
</pre>
</div>

<p>
Assignments:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw as (assign-stat)
  (<span style="color: #a020f0;">with-slots</span> (var expr) as
    (check-assignment var expr (location expr))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw ad (assign-decl)
  (<span style="color: #a020f0;">with-slots</span> (basic-decl expr) ad
    (check-assignment basic-decl expr (location expr))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw ss (swap-stat)
  (<span style="color: #a020f0;">with-slots</span> (var-left var-right) ss
    (check-assignment var-left var-right (location var-right))))
</pre>
</div>

<p>
As forms:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw nd (normal-decl)
  (<span style="color: #a020f0;">with-slots</span> (basic-decls) nd
    (<span style="color: #a020f0;">destructuring-bind</span> (primary <span style="color: #228b22;">&amp;rest</span> direct-as-basic-decls) basic-decls
      (check-equivalence 
       (location primary) (mcl-type primary) direct-as-basic-decls)
      (check-equivalence
       (location primary) (mcl-type primary) (as-basic-decls nd)))))
</pre>
</div>

<p>
Statements:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw ds (decl-stat call-stat block-stat inc-stat)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((is if-stat))
  (<span style="color: #a020f0;">with-slots</span> (cond-expr location) is
    (<span style="color: #a020f0;">with-slots</span> (eval-type) cond-expr
      (<span style="color: #a020f0;">let</span> ((expected-type (make-bool)))
        (expect location expected-type eval-type)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((fe foreach-stat))
  (<span style="color: #a020f0;">let</span> ((expected-type (make-int)))
    (<span style="color: #a020f0;">with-slots</span> (decl nr-iters) fe
      (<span style="color: #a020f0;">with-slots</span> (location eval-type) nr-iters
        (expect (location decl) expected-type (get-type decl))
        (expect location expected-type eval-type)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((fs for-stat))
  (<span style="color: #a020f0;">let</span> ((expected-type (make-bool)))
    (<span style="color: #a020f0;">with-slots</span> (cond-expr) fs
      (<span style="color: #a020f0;">with-slots</span> (location eval-type) cond-expr
        (expect location expected-type eval-type)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((is inc-step))
  (<span style="color: #a020f0;">with-slots</span> (var expr) is
    (check-numeric-type var)
    (check-numeric-type expr)
    (check-assignment var expr (location expr))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((i inc))
  (check-numeric-type (var i)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((as as-stat))
  (<span style="color: #a020f0;">with-slots</span> (var basic-decls location) as
    (check-equivalence location (get-type var) basic-decls)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((bs barrier-stat)))
</pre>
</div>

<p>
Calls:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-bw</span> ((call-expr call-expr))
  (set-type call-expr (get-type (call call-expr))))


(defvisitor check-bw call (call)
  (<span style="color: #a020f0;">if</span> (builtin-func-p call)
      (check-builtin-call call)
      (check-call call)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-builtin-call</span> (call)
  (<span style="color: #a020f0;">with-slots</span> (id params) call
    (<span style="color: #a020f0;">with-slots</span> (name) id
      (string-case (name)
        (<span style="color: #8b2252;">"mcl_builtin_read"</span> nil)
        (<span style="color: #8b2252;">"mcl_builtin_write"</span> nil)
        (<span style="color: #8b2252;">"toFloat"</span> (<span style="color: #a020f0;">let*</span> ((param (first params))
                          (type (eval-type param)))
                     (expect-equivalent (location (first params))
                                        (make-int) type)))
        (<span style="color: #8b2252;">"toDouble"</span> (<span style="color: #a020f0;">let*</span> ((param (first params))
                           (type (eval-type param)))
                      (expect-equivalent (location (first params))
                                        (make-int) type)))
        (<span style="color: #8b2252;">"mcl_builtin_allocate_on_device"</span> nil)
        (<span style="color: #8b2252;">"mcl_builtin_deallocate_on_device"</span> nil)
        (<span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span> nil)
        (<span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span> nil)
        (<span style="color: #8b2252;">"min"</span> (expect-l-r params (make-int)))
        (<span style="color: #8b2252;">"max"</span> (expect-l-r params (make-flt)))
        (<span style="color: #8b2252;">"divide_up"</span> (expect-l-r params (make-int)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">expect-l-r</span> (exprs type)
  (<span style="color: #a020f0;">destructuring-bind</span> (l r) exprs
    (expect (location l) type (eval-type l))
    (expect (location l) type (eval-type r))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-call</span> (call)
  (<span style="color: #a020f0;">with-slots</span> (func id (params-call params)) call
    (<span style="color: #a020f0;">with-slots</span> ((params-func params)) func
      (<span style="color: #a020f0;">with-slots</span> (location name) id
        (<span style="color: #a020f0;">if</span> (not (eql (length params-call) (length params-func)))
            (unequal-nr-params-error
             location
             <span style="color: #8b2252;">"Call ~a does not have the right amount of parameters"</span>
             name)
            (<span style="color: #a020f0;">let</span> ((bindings (make-bindings)))
              (<span style="color: #a020f0;">loop</span> for i from 0 below (length params-call)
                 do (check-parameter (nth i params-call)
                                     (nth i params-func)
                                     bindings))))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-parameter</span> (actual-parameter formal-parameter bindings)
  (add-binding bindings formal-parameter actual-parameter)
  (<span style="color: #a020f0;">with-slots</span> ((type-actual-parameter eval-type) location) actual-parameter
    (<span style="color: #a020f0;">let</span> ((type-formal-parameter (get-type formal-parameter)))

      (<span style="color: #a020f0;">when</span> (not (can-assign-to type-actual-parameter
                                (replace-exprs type-formal-parameter bindings)))
        (error-incompatible-types
         location type-formal-parameter type-actual-parameter)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">replace-exprs</span> (ast bindings)
  (<span style="color: #a020f0;">let</span> ((copy (copy-ast ast)))
    (set-parents:set-parents copy)
    (visit copy
           #'(<span style="color: #a020f0;">lambda</span> (ast)
               (replace-exprs-fw ast bindings))
           #'(<span style="color: #a020f0;">lambda</span> (ast)
               (replace-exprs-bw ast bindings)))
    copy))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-exprs-fw</span> (ast bindings))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-exprs-bw</span> (ast bindings))

(def-methods replace-exprs-fw ((ast (ast string list symbol number))
                                  bindings)
  t)

(def-methods replace-exprs-bw ((ast (ast string list symbol number))
                                  bindings)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">replace-exprs-bw</span> ((ve var-expr) bindings)
  (<span style="color: #a020f0;">when</span> (typep (var ve) 'normal-var)
    (<span style="color: #a020f0;">let</span> ((name-var (name (id (basic-var (var ve))))))
      (awhen (gethash name-var bindings)
        (replace-in-ast ve <span style="color: #483d8b;">:with</span> it)))))

</pre>
</div>

<p>
AST forms that should be checked:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defvisitor check-bw ast (stat expr decl increment)
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"~a should be type-checked"</span> ast))
</pre>
</div>
</div>
</div>

<div id="outline-container-org575cfa5" class="outline-5">
<h5 id="org575cfa5"><span class="section-number-5">7.2.1.3</span> Helper functions</h5>
<div class="outline-text-5" id="text-7-2-1-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">set-type</span> (expr type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">set-type</span> ((expr expr) type)
  (setf (eval-type expr) type))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">expect</span> (location expected-type found-type)
  (<span style="color: #a020f0;">when</span> (not (ast= expected-type found-type))
    (error-incompatible-types location expected-type found-type)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">expect-equivalent</span> (location expected-type found-type)
  (<span style="color: #a020f0;">when</span> (not (can-assign-to found-type expected-type))
    (error-incompatible-types location expected-type found-type)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-bindings</span> ()
  (make-hash-table <span style="color: #483d8b;">:test</span> 'equal))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">add-binding</span> (bindings decl expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-binding</span> (bindings (decl decl) expr)
  (<span style="color: #a020f0;">loop</span> for bd in (get-basic-decls decl)
     do (add-binding bindings bd expr)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-binding</span> (bindings (bd basic-decl) expr)
  (setf (gethash (name (id bd)) bindings) expr))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equals-type</span> (type1 type2 <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">let</span> ((type1 (simplify (fold-constant type1 bindings)))
        (type2 (simplify (fold-constant type2 bindings))))
    (ast= type1 type2)))
</pre>
</div>
</div>
</div>




<div id="outline-container-orgae83fb4" class="outline-5">
<h5 id="orgae83fb4"><span class="section-number-5">7.2.1.4</span> Numeric types</h5>
<div class="outline-text-5" id="text-7-2-1-4">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-numeric-type</span> (type))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*numeric-types*</span> (list (make-int) (make-flt) (make-double)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-numeric-type</span> ((expr expr))
  (<span style="color: #a020f0;">when</span> (not (find (eval-type expr) *numeric-types* <span style="color: #483d8b;">:test</span> #'ast=))
    (<span style="color: #ff0000; font-weight: bold;">error</span> 'numeric-type-error
           <span style="color: #483d8b;">:text</span> (format nil <span style="color: #8b2252;">"Expression ~a does not have a numeric type."</span>
                         (pp expr))
           <span style="color: #483d8b;">:loc</span> (location expr))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-numeric-type</span> ((var var))
  (<span style="color: #a020f0;">when</span> (not (find (get-type var) *numeric-types* <span style="color: #483d8b;">:test</span> #'ast=))
    (<span style="color: #ff0000; font-weight: bold;">error</span> 'numeric-type-error
           <span style="color: #483d8b;">:text</span> (format nil <span style="color: #8b2252;">"Variable ~a does not have a numeric type."</span>
                         (pp var))
           <span style="color: #483d8b;">:loc</span> (location var))))



(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">compute-type-numeric-op</span> (left right))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">compute-type-numeric-op</span> ((l expr) (r expr))
  (<span style="color: #a020f0;">with-slots</span> ((type-l eval-type)) l
    (<span style="color: #a020f0;">with-slots</span> ((type-r eval-type) location) r
      (check-numeric-type l)
      (check-numeric-type r)
      (<span style="color: #a020f0;">cond</span> ((can-assign-to type-r type-l)
             type-l)
            ((can-assign-to type-l type-r)
             type-r)
            (t
             (error-incompatible-types location type-l type-r))))))
</pre>
</div>
</div>
</div>



<div id="outline-container-org5ad2dbe" class="outline-5">
<h5 id="org5ad2dbe"><span class="section-number-5">7.2.1.5</span> Assignment rules</h5>
<div class="outline-text-5" id="text-7-2-1-5">
<p>
The following table shows what can be assigned to what.  For example, the first
rule states that an int can be assigned to float.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*assign-table*</span>
  (list (cons (make-int) (list (make-flt) (make-double)))
        (cons (make-flt) (list (make-double)))
        (cons (make-mcl-byte) (list (make-flt) (make-int)))))
</pre>
</div>

<p>
The following code shows how an assignment is checked:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-assignment</span> (var-type-lhs var-type-expr-rhs location))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-assignment</span> ((lhs mcl-type) (rhs mcl-type) location)
  (<span style="color: #a020f0;">when</span> (not (can-assign-to rhs lhs))
    (error-incompatible-types location lhs rhs)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-assignment</span> ((lhs var) (rhs expr) location)
  (check-assignment (get-type lhs) (eval-type rhs) location))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-assignment</span> ((lhs var) (rhs var) location)
  (check-assignment (get-type lhs) (get-type lhs) location))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-assignment</span> ((lhs basic-decl) (rhs expr) location)
  (check-assignment (mcl-type lhs) (eval-type rhs) location))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">can-assign-to</span> (rhs lhs <span style="color: #228b22;">&amp;optional</span> bindings)
  (or (equals-type lhs rhs bindings)
      (find lhs (assoc rhs *assign-table* <span style="color: #483d8b;">:test</span> #'ast=) <span style="color: #483d8b;">:test</span> #'ast=)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org191a9df" class="outline-5">
<h5 id="org191a9df"><span class="section-number-5">7.2.1.6</span> Type equivalence</h5>
<div class="outline-text-5" id="text-7-2-1-6">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-equivalence</span> (loc type basic-decls)
  (<span style="color: #a020f0;">let</span> ((type-flattened (flatten-type (fold-constant type))))
    (<span style="color: #a020f0;">dolist</span> (bd basic-decls)
      (<span style="color: #a020f0;">when</span> (not (ast= type-flattened (flatten-type (fold-constant (mcl-type bd)))))
        (error-inequivalent-types loc type (mcl-type bd))))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org93f8751" class="outline-5">
<h5 id="org93f8751"><span class="section-number-5">7.2.1.7</span> Computing types</h5>
<div class="outline-text-5" id="text-7-2-1-7">
<p>
The function <code>get-type</code> is not in the package <code>:ast-mcpl</code> since it is not just
an accessor function, but it needs computing types which can result in errors.
Therefore, it fits better in the <code>:micro-passes</code> package.  Instead in
<code>:ast-mcpl</code> there is the function <code>get-type-decl</code> that retrieves the type of a
(basic-)decl.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-type</span> (ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type</span> ((v normal-var))
  (get-type (basic-var v)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type</span> ((bv basic-var))
  (compute-type (id bv) (array-exprs bv) (mcl-type (get-basic-decl bv))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type</span> ((dv dot-var))
  (<span style="color: #a020f0;">if</span> (query-hdl-mcpl:hardware-description-var-p dv)
      (make-int)
      (<span style="color: #a020f0;">with-slots</span> (basic-var var) dv
        (<span style="color: #a020f0;">if</span> (typep (get-type basic-var) 'custom-type)
            (get-type var)
            (undefined-type-error
             (location basic-var)
             <span style="color: #8b2252;">"~a does not have a custom type"</span> (name (id basic-var)))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type</span> ((c call))
  (<span style="color: #a020f0;">if</span> (builtin-func-p c)
      (get-type-builtin-func (name (id c)))
      (mcl-type (func c))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type</span> ((d decl))
  (get-type-decl d))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-type</span> ((bd basic-decl))
  (get-type-decl bd))
</pre>
</div>

<p>
Computing types is done recursively and deals with several cases:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-type</span> (id array-exprs type)
  (<span style="color: #a020f0;">cond</span> ((null array-exprs)
         type)
        ((not (typep type 'array-type))
         (error-too-many-array-exprs id))
        ((not (eql (length (sizes type)) (length (first array-exprs))))
         (error-unequal-nr-array-exprs id))
        ((eql (length array-exprs) 1)
         (compute-type-fine (first array-exprs)
                            (make-array-type (base-type type) (sizes type))))
        (t
         (compute-type id (rest array-exprs) (base-type type)))))
</pre>
</div>

<p>
Computing types for the one-dimensional case is done recursively as well.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-type-fine</span> (array-exprs type)
  (<span style="color: #a020f0;">if</span> (null array-exprs)
      (base-type type)
      (<span style="color: #a020f0;">progn</span>
        (setf (sizes type) (rest (sizes type)))
        (compute-type-fine (rest array-exprs) type))))
</pre>
</div>

<p>
Whether ast-forms are primitve:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">primitive-p</span> (ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">primitive-p</span> ((d decl))
  (primitive-decl-p d))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">primitive-p</span> ((type mcl-type))
  (primitive-type-p type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">primitive-p</span> ((v var))
  (primitive-p (get-type v)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6c56c6b" class="outline-5">
<h5 id="org6c56c6b"><span class="section-number-5">7.2.1.8</span> Type errors</h5>
<div class="outline-text-5" id="text-7-2-1-8">
<p>
Several convenience function for type errors:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">error-incompatible-types</span> (loc expected-type received-type)
  (incompatible-type-error loc <span style="color: #8b2252;">"Expected type ~a, but got ~a."</span>
                           (pp expected-type) (pp received-type)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">error-inequivalent-types</span> (loc expected-type received-type)
  (inequivalent-type-error loc <span style="color: #8b2252;">"Type ~a is not equivalent with type ~a."</span>
                      (pp expected-type) (pp received-type)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">error-too-many-array-exprs</span> (id)
  (too-many-array-exprs-error
   (location id)
   <span style="color: #8b2252;">"Variable ~a has too many-array-expressions."</span> (name id)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">error-unequal-nr-array-exprs</span> (id)
  (unequal-nr-array-exprs-error
   (location id)
   <span style="color: #8b2252;">"Variable ~a does not have a matching number of array expressions."</span>
   (name id)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgabd8041" class="outline-5">
<h5 id="orgabd8041"><span class="section-number-5">7.2.1.9</span> Testing</h5>
<div class="outline-text-5" id="text-7-2-1-9">
</div>
<ul class="org-ul">
<li><a id="org8730534"></a>The package<br />
<div class="outline-text-6" id="text-org8730534">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-check-types</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span>
        <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:set-vars-written</span>        <span style="color: #483d8b;">:check-types</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-check-types</span>))
</pre>
</div>
</div>
</li>

<li><a id="org046e85f"></a>Testing the type checker<br />
<div class="outline-text-6" id="text-org046e85f">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite check-types <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite check-types)

(test check-simple-types
  (is-typed (make-int) (make-int-constant 2))
  (is-typed (make-int) (make-minus (make-int-constant 2)))
  (is-type-error (make-minus (make-bool-constant t)) numeric-type-error)
  (is-module-typed (build-module '(<span style="color: #8b2252;">"float a = 2.0 / 2;"</span>)))
  (is-module-typed (build-module '(<span style="color: #8b2252;">"int a;"</span> <span style="color: #8b2252;">"int b = a;"</span>)))
  (is-module-typed (build-module '(<span style="color: #8b2252;">"int[2] a;"</span> <span style="color: #8b2252;">"int b = a[0];"</span>)))
  (module-has-type-error (build-module '(<span style="color: #8b2252;">"float a;"</span> <span style="color: #8b2252;">"int b = a;"</span>))))

(test check-arrays
  (is-module-typed (build-module-for-calls '(<span style="color: #8b2252;">"int n"</span> <span style="color: #8b2252;">"float[n] a"</span>)
                                           '(<span style="color: #8b2252;">"int h;"</span> 
                                             <span style="color: #8b2252;">"int w;"</span>
                                             <span style="color: #8b2252;">"int n = h * w;"</span>
                                             <span style="color: #8b2252;">"float[h * w] a;"</span>
                                             <span style="color: #8b2252;">"g(n, a);"</span>)))
  (is-module-typed (build-module-for-calls '(<span style="color: #8b2252;">"int n"</span> <span style="color: #8b2252;">"float[n] a"</span>)
                                           '(<span style="color: #8b2252;">"int h;"</span> 
                                             <span style="color: #8b2252;">"int w;"</span>
                                             <span style="color: #8b2252;">"int n = w * h;"</span>
                                             <span style="color: #8b2252;">"float[h * w] a;"</span>
                                             <span style="color: #8b2252;">"g(n, a);"</span>))))


(test check-simple-calls
  (is-module-typed (build-module-for-calls (list <span style="color: #8b2252;">"int a"</span>) 
                                           (list <span style="color: #8b2252;">"g(2);"</span>)))
  (is-module-typed (build-module-for-calls (list <span style="color: #8b2252;">"int a"</span>) 
                                           (list <span style="color: #8b2252;">"int a = 2;"</span> <span style="color: #8b2252;">"g(a);"</span>)))
  (is-module-typed (build-module-for-calls (list <span style="color: #8b2252;">"int a"</span>) 
                                           (list <span style="color: #8b2252;">"int b = 2;"</span> <span style="color: #8b2252;">"g(b);"</span>))))

(test check-array-calls
  (is-module-typed
   (build-module-for-calls (list <span style="color: #8b2252;">"int[2] a"</span>) (list <span style="color: #8b2252;">"int[2] b;"</span> <span style="color: #8b2252;">"g(b);"</span>)))
  (is-module-typed
   (build-module-for-calls (list <span style="color: #8b2252;">"int[2*2] a"</span>) (list <span style="color: #8b2252;">"int[4] b;"</span> <span style="color: #8b2252;">"g(b);"</span>)))
  (is-module-typed
   (build-module-for-calls (list <span style="color: #8b2252;">"int n"</span> <span style="color: #8b2252;">"int[n] a"</span>)
                           (list <span style="color: #8b2252;">"int n = 2;"</span> <span style="color: #8b2252;">"int[n] b;"</span> <span style="color: #8b2252;">"g(n, b);"</span>)))
  (is-module-typed
   (build-module-for-calls (list <span style="color: #8b2252;">"int n"</span> <span style="color: #8b2252;">"int[n] a"</span>)
                           (list <span style="color: #8b2252;">"int m = 2;"</span> <span style="color: #8b2252;">"int[m] b;"</span> <span style="color: #8b2252;">"g(m, b);"</span>)))
  (is-module-typed
   (build-module-for-calls '(<span style="color: #8b2252;">"int h"</span> <span style="color: #8b2252;">"int w"</span> <span style="color: #8b2252;">"float[h][w] a"</span>)
                           '(<span style="color: #8b2252;">"int w;"</span>
                             <span style="color: #8b2252;">"int h;"</span>
                             <span style="color: #8b2252;">"float[w][h] a;"</span>
                             <span style="color: #8b2252;">"g(w, h, a);"</span>))))

</pre>
</div>
</div>
</li>

<li><a id="orgac6cbb0"></a>Helper macros<br />
<div class="outline-text-6" id="text-orgac6cbb0">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">is-type-error</span> (ast error-symbol)
  `(signals ,error-symbol (check-types ,ast)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">is-typed</span> (type ast)
  `(is (ast= ,type (eval-type (check-types ,ast)))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">is-module-typed</span> (module)
  `(is (check-types ,module)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">module-has-type-error</span> (module)
  `(signals mcpl-type-error (check-types ,module)))
</pre>
</div>
</div>
</li>

<li><a id="org09efc5e"></a>Helper functions<br />
<div class="outline-text-6" id="text-org09efc5e">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-module</span> (stats)
  (resolve-vars 
   (parse-mcpl 
    (format 
     nil
     <span style="color: #8b2252;">"package m; module a;~%perfect void f() {~%~{~a~^~}~%}"</span> stats))
   nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-module-for-calls</span> (params stats-f)
  (<span style="color: #a020f0;">let*</span> ((string (format
                  nil
                  <span style="color: #8b2252;">"package p; module m;</span>
<span style="color: #8b2252;">type Complex {</span>
<span style="color: #8b2252;">   float k;</span>
<span style="color: #8b2252;">   float l;</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;">perfect void g(~{~a~^, ~}) {</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void f() {</span>
<span style="color: #8b2252;">  ~{~a~^~%~}</span>
<span style="color: #8b2252;">}"</span> params stats-f))
         (module (parse-mcpl string)))
    (set-parents module)
    (resolve-calls module nil)
    (resolve-vars module nil)
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(let ((callgraph (set-callgraph (funcs (code module)))))</span>
    <span style="color: #b22222;">;;   </span><span style="color: #b22222;">(set-vars-written callgraph)</span>
    <span style="color: #b22222;">;;   </span><span style="color: #b22222;">module)</span>
    module))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org56c04e5" class="outline-4">
<h4 id="org56c04e5"><span class="section-number-4">7.2.2</span> Checking memory spaces</h4>
<div class="outline-text-4" id="text-7-2-2">
</div>
<div id="outline-container-org8fa6e7c" class="outline-5">
<h5 id="org8fa6e7c"><span class="section-number-5">7.2.2.1</span> The package</h5>
<div class="outline-text-5" id="text-7-2-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:check-memory-spaces</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:string-case</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:errors</span>
        <span style="color: #483d8b;">:query-hdl-mcpl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:check-memory-spaces</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge9c63c7" class="outline-5">
<h5 id="orge9c63c7"><span class="section-number-5">7.2.2.2</span> Checking the memory spaces</h5>
<div class="outline-text-5" id="text-7-2-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-memory-spaces</span> (callgraph)
  <span style="color: #8b2252;">"Check the memory-spaces of functions/calls."</span>
  (log-micro-pass <span style="color: #8b2252;">"check-memory-spaces"</span> callgraph)
  (<span style="color: #a020f0;">let</span> ((funcs (funcs-ordered callgraph)))
    (<span style="color: #a020f0;">loop</span> for f in funcs do (check-memory-spaces-func f))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-memory-spaces-func</span> (func)
  (<span style="color: #a020f0;">let</span> ((calls (called-by func)))
    (<span style="color: #a020f0;">loop</span> for call in calls
       do (check-memory-spaces-func-call func call))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-memory-spaces-func-call</span> (func call)
  (<span style="color: #a020f0;">let</span> ((params-func (params func))
        (params-call (params call)))
    (<span style="color: #a020f0;">loop</span>
       for pf in params-func
       for pc in params-call
       do (check-equivalence-memory-space pf pc pc))))

</pre>
</div>

<p>
If the memory-space of a function is disallowed, then it doesn't matter what
the call has as memory-space.  If it is a variable with a memory-space, it will
be transformed to just a constant.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-equivalence-memory-space</span> (param-func param-call
    original-param-call))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-equivalence-memory-space</span> ((d decl) (e expr) (original expr))
  (<span style="color: #a020f0;">let</span> ((ms-disallowed-func (memory-space-disallowed d))
        (ms-disallowed-call (memory-space-disallowed e)))
    (<span style="color: #a020f0;">cond</span> (ms-disallowed-func
           t)
          ((and (not ms-disallowed-func) (not ms-disallowed-call))
           (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep e 'var-expr))
           (check-equivalence-memory-space d (var e) original))
          (t
           (mcpl-memory-space-error
            (location original)
            <span style="color: #8b2252;">"Variable ~a does not match in whether a memory-space is needed"</span>
            original)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-equivalence-memory-space</span> ((d decl) (v var) (e expr))
  (check-equivalence-memory-space d (get-decl-var v) e))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-equivalence-memory-space</span> ((d-func decl) (d-call decl) (e expr))
  (<span style="color: #a020f0;">let</span> ((mss-d-func (get-memory-spaces d-func))
        (mss-d-call (get-memory-spaces d-call)))
    (<span style="color: #a020f0;">if</span> (intersection mss-d-func mss-d-call <span style="color: #483d8b;">:test</span> #'string=)
        t
        (mcpl-memory-space-error
         (location e)
         <span style="color: #8b2252;">"Memory-space of variable ~a does not match with the function definition:</span>
<span style="color: #8b2252;">function definition memory-space(s): ~{~a~^, ~}</span>
<span style="color: #8b2252;">variable memory-space(s): ~{~a~^, ~}"</span>
         (print-pretty:pp e) mss-d-func mss-d-call))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org78f7a55" class="outline-5">
<h5 id="org78f7a55"><span class="section-number-5">7.2.2.3</span> Testing</h5>
<div class="outline-text-5" id="text-7-2-2-3">
</div>
<ul class="org-ul">
<li><a id="org564ec69"></a>The package<br />
<div class="outline-text-6" id="text-org564ec69">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-check-memory-spaces</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span>
        <span style="color: #483d8b;">:errors</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:set-vars-written</span> <span style="color: #483d8b;">:check-memory-spaces</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-check-memory-spaces</span>))
</pre>
</div>
</div>
</li>

<li><a id="org3a06ee2"></a>Testing checking of memory-spaces<br />
<div class="outline-text-6" id="text-org3a06ee2">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite check-memory-spaces <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite check-memory-spaces)

(test check-memory-spaces
  (is (memory-spaces-ok <span style="color: #8b2252;">"perfect void g(int l, float[l] a)"</span>
                        <span style="color: #8b2252;">"perfect void f() {</span>
<span style="color: #8b2252;">                           float[2] a;</span>
<span style="color: #8b2252;">                           g(2, a);</span>
<span style="color: #8b2252;">                         }"</span>))
  (is (memory-spaces-ok <span style="color: #8b2252;">"perfect void g(int l, float[l] a)"</span>
                        <span style="color: #8b2252;">"perfect void f() {</span>
<span style="color: #8b2252;">                            foreach (int i in 2 threads) {</span>
<span style="color: #8b2252;">                              float[2] a;</span>
<span style="color: #8b2252;">                              g(2, a);</span>
<span style="color: #8b2252;">                            }</span>
<span style="color: #8b2252;">                          }"</span>)))
</pre>
</div>
</div>


<ul class="org-ul">
<li><a id="org2b4fd95"></a>Helper functions<br />
<div class="outline-text-7" id="text-org2b4fd95">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">memory-spaces-ok</span> (function-header-called calling-function)
  (analyze function-header-called calling-function t))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">memory-spaces-error</span> (function-header-called calling-function)
  (analyze function-header-called calling-function nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze</span> (function-header-called calling-function result-ok)
  (<span style="color: #a020f0;">handler-case</span> (<span style="color: #a020f0;">progn</span>
                  (analyze2 function-header-called calling-function)
                  result-ok)
    (mcpl-memory-space-error nil (not result-ok))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze2</span> (function-header-called calling-function)
  (<span style="color: #a020f0;">let</span> ((module (create-module function-header-called calling-function))
        (exports (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (set-parents module)
    (resolve-calls module exports)
    (resolve-vars module exports)
    (load-hardware-descriptions:load-hardware-description <span style="color: #8b2252;">"perfect"</span>)
    (<span style="color: #a020f0;">let</span> ((callgraph (set-callgraph (funcs (code module)))))
      (set-cfgraphs module)
      (set-vars-written callgraph)
      (check-memory-spaces callgraph))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tostring</span> (<span style="color: #228b22;">&amp;rest</span> lines)
  (format nil <span style="color: #8b2252;">"~{~a~^~%~}"</span> lines))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*module-template*</span>
  (tostring
   <span style="color: #8b2252;">"package a;"</span>
   <span style="color: #8b2252;">"module a;"</span>
   <span style="color: #8b2252;">"import perfect;"</span>
   <span style="color: #8b2252;">""</span>
   <span style="color: #8b2252;">"~a {"</span>
   <span style="color: #8b2252;">" a[0] = 1.0;"</span>
   <span style="color: #8b2252;">"}"</span>
   <span style="color: #8b2252;">""</span>
   <span style="color: #8b2252;">"~a"</span>
   <span style="color: #8b2252;">""</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-module</span> (function-header-called calling-function)
  (parse-mcpl (build-module function-header-called calling-function)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-module</span> (function-header-called calling-function)
  (format nil *module-template* function-header-called calling-function))
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>



<div id="outline-container-org69bede2" class="outline-4">
<h4 id="org69bede2"><span class="section-number-4">7.2.3</span> check package</h4>
<div class="outline-text-4" id="text-7-2-3">
</div>
<div id="outline-container-orgacc6194" class="outline-5">
<h5 id="orgacc6194"><span class="section-number-5">7.2.3.1</span> The package</h5>
<div class="outline-text-5" id="text-7-2-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:check-package</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:errors</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:check-package</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga822bdb" class="outline-5">
<h5 id="orga822bdb"><span class="section-number-5">7.2.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-2-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-package</span> (module name-mcpl-file)
  <span style="color: #8b2252;">"Checks whether a module is in the right directory.  It returns the root</span>
<span style="color: #8b2252;">directory from where the module can be found."</span>
  (<span style="color: #a020f0;">let</span> ((pathname (pathname name-mcpl-file)))
    (make-pathname
     <span style="color: #483d8b;">:directory</span> (reverse
                 (check-directory
                  module
                  (reverse (pathname-directory pathname))
                  (pkg module)))
     <span style="color: #483d8b;">:name</span> nil
     <span style="color: #483d8b;">:type</span> nil)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">check-directory</span> (module directory-list package))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-directory</span> (module directory-list (pkg-id id))
  (<span style="color: #a020f0;">with-slots</span> (name location) pkg-id
    (check-directory-with-loc module directory-list name location)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-directory-with-loc</span> (module directory-list pkg-name location)
  (<span style="color: #a020f0;">let</span> ((directory (first directory-list)))
    (<span style="color: #a020f0;">if</span> (not (string= directory pkg-name))
        (pkg-error
         location 
         (format nil <span style="color: #8b2252;">"~a~a"</span>
                 <span style="color: #8b2252;">"Expecting module ~a to be in directory ~a, "</span>
                 <span style="color: #8b2252;">"but was found in directory ~a"</span>)
         (name (id module))
         pkg-name
         directory)
        (rest directory-list))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check-directory</span> (module directory-list (compound-id compound-id))
  (<span style="color: #a020f0;">with-slots</span> (name compound location) compound-id
    (<span style="color: #a020f0;">let</span> ((rest-directory-list (check-directory module directory-list compound)))
      (check-directory-with-loc module rest-directory-list name location))))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org0f8ed49" class="outline-4">
<h4 id="org0f8ed49"><span class="section-number-4">7.2.4</span> check exports</h4>
<div class="outline-text-4" id="text-7-2-4">
</div>
<div id="outline-container-org45b76de" class="outline-5">
<h5 id="org45b76de"><span class="section-number-5">7.2.4.1</span> The package</h5>
<div class="outline-text-5" id="text-7-2-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:check-exports</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:errors</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:check-exports</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf87cb97" class="outline-5">
<h5 id="orgf87cb97"><span class="section-number-5">7.2.4.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-2-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-exports</span> (module)
  <span style="color: #8b2252;">"Checks whether the exports are existing functions, types, and constants.</span>
<span style="color: #8b2252;">Returns a mapping between these identifiers and what they refer to."</span>
  (log-micro-pass <span style="color: #8b2252;">"check-exports"</span> module)
  (<span style="color: #a020f0;">let</span> ((export-mapping (make-relation <span style="color: #483d8b;">:test</span> #'ast=)))
    (<span style="color: #a020f0;">dolist</span> (e (exports module))
      (add-to-rel e (check-export e module) export-mapping))
    export-mapping))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-export</span> (export module)
  (<span style="color: #a020f0;">cond</span> ((func-id-p export) (check-func export module))
        ((type-id-p export) (check-typedef export module))
        ((const-id-p export) (check-const export module))
        (t (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"unknown identifier"</span>))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-func</span> (export module)
  (<span style="color: #a020f0;">dolist</span> (f (funcs (code module)))
    (<span style="color: #a020f0;">when</span> (ast= export (id f))
      (<span style="color: #a020f0;">return-from</span> check-func f)))
  (undefined-func-error (location export) <span style="color: #8b2252;">"Unkown function ~a"</span> (name export)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-typedef</span> (export module)
  (do-check export module 'typedef <span style="color: #8b2252;">"type"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-const</span> (export module)
  (do-check export module 'const-decl <span style="color: #8b2252;">"constant"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-check</span> (export module type message )
  (<span style="color: #a020f0;">let</span> ((top-decls (filter #'(<span style="color: #a020f0;">lambda</span> (td) (typep td type))
                       (top-decls (code module)))))
    (<span style="color: #a020f0;">dolist</span> (td top-decls)
      (<span style="color: #a020f0;">when</span> (ast= export (get-id td))
        (<span style="color: #a020f0;">return-from</span> do-check td)))
    (define-resolve-error
        (location export) <span style="color: #8b2252;">"Unknown ~a ~a"</span> message (name export))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org3b98d04" class="outline-3">
<h3 id="org3b98d04"><span class="section-number-3">7.3</span> Transformations</h3>
<div class="outline-text-3" id="text-7-3">
<p>
This section shows several micro-passes that transform the AST.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org0c1bd7a">7.3.1. flatten types</a></li>
<li><a href="#orgb95f80f">7.3.2. Flatten variables</a></li>
<li><a href="#org2f5e223">7.3.3. Fold constants</a></li>
<li><a href="#orgd165cc2">7.3.4. Remove hardware variables</a></li>
<li><a href="#org09decf5">7.3.5. Move dimension constants out foreach statements</a></li>
<li><a href="#orgf43f28a">7.3.6. Move foreach to function</a></li>
<li><a href="#orgdc7537d">7.3.7. Move foreach to function for Cashmere</a></li>
<li><a href="#orge503d5c">7.3.8. Move stats to function</a></li>
<li><a href="#org34245b4">7.3.9. Move stats out function</a></li>
<li><a href="#org4d00482">7.3.10. Specialize functions on memory-space</a></li>
<li><a href="#orgf8c63d4">7.3.11. Transform tile expressions</a></li>
<li><a href="#orgaf0812d">7.3.12. simplify expressions</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0c1bd7a" class="outline-4">
<h4 id="org0c1bd7a"><span class="section-number-4">7.3.1</span> flatten types</h4>
<div class="outline-text-4" id="text-7-3-1">
</div>
<div id="outline-container-orge69dec2" class="outline-5">
<h5 id="orge69dec2"><span class="section-number-5">7.3.1.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:flatten-types</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:simplify-expressions</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:mcl-quickutil</span> <span style="color: #483d8b;">:iota</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:flatten-type</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb86c98a" class="outline-5">
<h5 id="orgb86c98a"><span class="section-number-5">7.3.1.2</span> Flattening types</h5>
<div class="outline-text-5" id="text-7-3-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">flatten-type</span> (type)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"flatten type into a one-dimensional type."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">flatten-type</span> ((type mcl-type))
  type)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">flatten-type</span> ((at array-type))
  (<span style="color: #a020f0;">let</span> ((base-type (get-base-type at))
        (size (reduce #'(<span style="color: #a020f0;">lambda</span> (result index)
                          (make-mul result (compute-size at index)))
                      (nreverse (iota (length (sizes at))))
                      <span style="color: #483d8b;">:initial-value</span> (make-int-constant 1))))
    (make-array-type base-type 
                     (list (make-decl-array-size (simplify size) nil)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">compute-size</span> (type dim)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Compute the size for a particular dimension."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">compute-size</span> ((type mcl-type) dim)
  (make-int-constant 1))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">compute-size</span> ((at array-type) dim)
  (<span style="color: #a020f0;">let</span> ((size (compute-size-ignoring-overlap at dim))
        (overlap-size (compute-size-overlap (base-type at) dim)))
    (make-add size overlap-size)))
</pre>
</div>

<p>
The following methods compute the size of a particular dimension ignoring the
overlap that may be defined.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">compute-size-ignoring-overlap</span> (type dim))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">compute-size-ignoring-overlap</span> ((type mcl-type) dim)
  (make-int-constant 1))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">compute-size-ignoring-overlap</span> ((at array-type) dim)
  (make-mul (compute-size-ignoring-overlap (base-type at) dim)
            (get-size-overlap (nth dim (sizes at)))))
</pre>
</div>

<p>
The following methods compute the size of the overlap for a particular
dimension:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">compute-size-overlap</span> (type dimension))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">compute-size-overlap</span> ((type mcl-type) dim)
  (make-int-constant 0))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">compute-size-overlap</span> ((at array-type) dim)
  (<span style="color: #a020f0;">let</span> ((overlap (make-mul
                  (get-overlap-overlap (nth dim (sizes at)))
                  (compute-size-ignoring-overlap (base-type at) dim))))
    (make-add overlap (compute-size-overlap (base-type at) dim))))
</pre>
</div>


<p>
The following methods retrieve the size when overlap is considered:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-size-overlap</span> (array-size))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size-overlap</span> ((array-size array-size))
  (size array-size))
</pre>
</div>

<p>
The following methods retrieve the overlap when overlap is considered:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-overlap-overlap</span> (array-size))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-overlap-overlap</span> ((array-size decl-array-size))
  (make-int-constant 0))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-overlap-overlap</span> ((overlap overlap))
  (make-add (left overlap) (right overlap)))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgccd734b" class="outline-5">
<h5 id="orgccd734b"><span class="section-number-5">7.3.1.3</span> Testing flattening types</h5>
<div class="outline-text-5" id="text-7-3-1-3">
</div>
<ul class="org-ul">
<li><a id="orgb80f5e1"></a>The package<br />
<div class="outline-text-6" id="text-orgb80f5e1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-flatten-types</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:simplify-expressions</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span>
        <span style="color: #483d8b;">:flatten-types</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-flatten-type</span>))
</pre>
</div>
</div>
</li>

<li><a id="org0106311"></a>The tests<br />
<div class="outline-text-6" id="text-org0106311">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite flatten-types <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite flatten-types)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(test flattening
  (is (ast= (make-flt nil) (flatten-type (make-flt nil))))
  (is (ast= (make-array-type (make-flt nil) (list (do-array-size 10)) nil)
            (flatten-type (make-array-type (make-flt) (list (do-array-size 10))))))
  (is (ast= (make-array-type (make-flt) (list (do-mul <span style="color: #8b2252;">"m"</span> <span style="color: #8b2252;">"n"</span>)))
            (flatten-type (make-array-type (make-flt)
                                           (list (do-array-size <span style="color: #8b2252;">"n"</span>)
                                                 (do-array-size <span style="color: #8b2252;">"m"</span>)))))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(test compute-size
  (is (ast= (simplify (flatten-types::compute-size
                       (make-array-type (make-flt) (list (do-array-size <span style="color: #8b2252;">"n"</span>)))
                       0))
            (do-var <span style="color: #8b2252;">"n"</span>))))
</pre>
</div>
</div>
</li>

<li><a id="org4abd790"></a>Helper functions<br />
<div class="outline-text-6" id="text-org4abd790">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">do-array-size</span> (string-expr-or-int))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">do-array-size</span> ((i fixnum))
  (do-array-size (make-int-constant i nil)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">do-array-size</span> ((e expr))
  (make-decl-array-size e nil nil))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">do-array-size</span> ((s string))
  (do-array-size (do-var s)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-var</span> (s)
  (make-var-expr
   (make-normal-var (make-basic-var (make-id s nil) nil nil) nil) nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-mul</span> (s1 s2)
  (do-array-size (make-mul (do-var s1) (do-var s2) nil)))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>



<div id="outline-container-orgb95f80f" class="outline-4">
<h4 id="orgb95f80f"><span class="section-number-4">7.3.2</span> Flatten variables</h4>
<div class="outline-text-4" id="text-7-3-2">
</div>
<div id="outline-container-org778687f" class="outline-5">
<h5 id="org778687f"><span class="section-number-5">7.3.2.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:flatten-var</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:iterate</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:shadow</span> <span style="color: #483d8b;">:flatten</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:collect</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:flatten-var</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org9f70ff3" class="outline-5">
<h5 id="org9f70ff3"><span class="section-number-5">7.3.2.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-2-2">
<p>
To ensure that the child/parent relations for AST nodes is correct, it is
important for transformations that new AST are formed and not old ones
reused (possibly having a wrong parent).  In the flatten, pass, it could be the
case that more than one var reuse AST-forms from the type, which would lead to
inconsistent data.  Therefore, we have to verify that we copy values from the
type and not just reuse them.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">flatten-var</span> (var <span style="color: #228b22;">&amp;optional</span> type)
  (<span style="color: #a020f0;">if</span> type
      (flatten var type)
      (flatten var (get-type-decl (basic-decl (basic-var var))))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">flatten</span> (var type)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Flatten a variable var using type type."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">flatten</span> ((nv normal-var) (type mcl-type))
  (setf (basic-var nv) (flatten (basic-var nv) type))
  nv)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">flatten</span> ((dv dot-var) (type mcl-type))
  (<span style="color: #a020f0;">with-slots</span> (basic-var var) dv
    (setf var (flatten-var var))
    (setf basic-var (flatten basic-var type))
    dv))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">flatten</span> ((bv basic-var) (type mcl-type))
  (<span style="color: #a020f0;">if</span> (null (array-exprs bv))
      bv
      (make-one-dimensional bv type)))
</pre>
</div>

<p>
In the following function we retrieve the sizes of the type, which means that
whenever such a size is used, we need to copy it.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">make-one-dimensional</span> (offsets sizes))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">make-one-dimensional</span> ((bv basic-var) (type mcl-type))
  (setf (array-exprs bv) (list (list (make-one-dimensional (array-exprs bv) (get-sizes type)))))
  bv)
</pre>
</div>

<p>
The following function copies sizes, because <code>offset-size-prod</code> and
<code>offset-dim</code> copy it.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">make-one-dimensional</span> ((offsets list) (sizes list))
  (<span style="color: #a020f0;">let</span> ((last-dimension (1- (length (first offsets)))))
    (iter (for i from 0 below last-dimension)
          (reducing i by #'(<span style="color: #a020f0;">lambda</span> (result dim)
                (make-add result (offset-size-prod offsets sizes dim)))
                    <span style="color: #483d8b;">:initial-value</span> (offset-dim offsets sizes last-dimension)))))
</pre>
</div>

<p>
This function makes multiplications of offsets and sizes.  It multiplies the
offset of a given dimension and layer in the tiles and multiplies this with
sizes for each layer higher up to the highest layer for a given dimension.
Since <code>sizes</code> comes from the type, we have to copy the value.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">offset-size-prod-layer</span> (offsets sizes dim layer)
  (make-mul
   (nth dim (nth layer offsets))
   (iterate (for i from (1+ layer) below (length offsets))
            (reducing i by #'(<span style="color: #a020f0;">lambda</span> (result i)
               (make-mul result
                         (get-size-without-overlap 
                          (copy-ast (nth dim (nth i sizes))))))
                      <span style="color: #483d8b;">:initial-value</span> (make-int-constant 1)))))
</pre>
</div>

<p>
This function multiplies the offset of a given dimension with a multiplication
of sizes of higher dimensions.  It copies the AST-form from sizes because
<code>offset-dim</code> and <code>size-dim</code> do this.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">offset-size-prod</span> (offsets sizes dim)
  (make-mul
   (offset-dim offsets sizes dim)
   (iter (for i from (1+ dim) below (length (first offsets)))
         (reducing i by #'(<span style="color: #a020f0;">lambda</span> (result j)
                            (make-mul result (size-dim sizes j)))
                   <span style="color: #483d8b;">:initial-value</span>  (make-int-constant 1)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-size-without-overlap</span> (size))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size-without-overlap</span> ((das decl-array-size))
  (size das))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size-without-overlap</span> ((e expr))
  e)
</pre>
</div>

<p>
This function copies sizes because <code>size-dim-layer</code> does it.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">size-dim</span> (sizes dim)
  (size-dim-layer sizes (1- (length sizes)) dim))
</pre>
</div>

<p>
Since sizes comes from the type, we have to copy the value to get a fresh
AST-form. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">size-dim-layer</span> (sizes layer dim)
  (<span style="color: #a020f0;">let</span> ((size (copy-ast (nth dim (nth layer sizes)))))
    (<span style="color: #a020f0;">if</span> (eql 0 layer)
        size
        (make-add
         (make-add
          (make-mul
           (get-size-size size)
           (size-dim-layer sizes (1- layer) dim))
          (get-left-size size))
         (get-right-size size)))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-size-size</span> (size)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the size from an array size."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size-size</span> ((das decl-array-size))
  (size das))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size-size</span> ((e expr))
  e)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-left-size</span> (size)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the left size from an array size."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-left-size</span> ((das decl-array-size))
  (make-int 0))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-left-size</span> ((e expr))
  (make-int-constant 0))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-right-size</span> (size)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the right size from an array size."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-right-size</span> ((das decl-array-size))
  (make-int 0))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-right-size</span> ((e expr))
  (make-int-constant 0))
</pre>
</div>

<p>
The following function returns the offsets for a given dimension.  It starts
with the offset for a given dimension in the last layer.  For each layer it
adds this to the product of a size for that layer.  
</p>

<p>
The function copies AST-forms from sizes because <code>offset-size-prod-layer</code>
copies it.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">offset-dim</span> (offsets sizes dim)
  (<span style="color: #a020f0;">let</span> ((last-layer (1- (length offsets))))
    (iter (for layer from 0 below last-layer)
          (reducing layer 
                    by #'(<span style="color: #a020f0;">lambda</span> (result l)
                           (make-add
                            result
                            (offset-size-prod-layer offsets sizes dim l)))
                    <span style="color: #483d8b;">:initial-value</span> (nth dim (nth last-layer offsets))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-sizes</span> (type)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get a 2-dimensional list of size expressions from type."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-sizes</span> ((sizes list))
  (mapcar #'size sizes))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-sizes</span> ((at array-type))
  (<span style="color: #a020f0;">with-slots</span> (base-type sizes) at
    (<span style="color: #a020f0;">let</span> ((size-exprs (get-sizes sizes)))
      (<span style="color: #a020f0;">typecase</span> base-type
        (array-type (append (list size-exprs) (get-sizes base-type)))
        (otherwise (list size-exprs))))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org4538ebe" class="outline-5">
<h5 id="org4538ebe"><span class="section-number-5">7.3.2.3</span> Testing flattening variables</h5>
<div class="outline-text-5" id="text-7-3-2-3">
</div>
<ul class="org-ul">
<li><a id="orgf9f8e16"></a>The package<br />
<div class="outline-text-6" id="text-orgf9f8e16">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-flatten-var</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:flatten-var</span>
        <span style="color: #483d8b;">:simplify-expressions</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-flatten-var</span>))
</pre>
</div>
</div>
</li>

<li><a id="org78a4696"></a>The functionality<br />
<div class="outline-text-6" id="text-org78a4696">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite flatten-var <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite flatten-var)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-array-size</span> (array-expr)
  (make-decl-array-size (make-int-constant array-expr) nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-array-sizes</span> (array-exprs)
  (mapcar #'create-array-size array-exprs))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-array-type</span> (array-exprs)
  (<span style="color: #a020f0;">if</span> (null array-exprs)
      (make-int)
      (make-array-type (create-array-type (rest array-exprs))
                       (create-array-sizes (first array-exprs)))))

(test flatten-var
  (is (ast= (flatten-var
           (var (parse-mcpl-expr <span style="color: #8b2252;">"a[b,c]"</span>))
           (create-array-type '((2 3))))
          (var (parse-mcpl-expr <span style="color: #8b2252;">"a[c + b * (1 * 3)]"</span>))))
  (is (ast= (flatten-var
             (var (parse-mcpl-expr <span style="color: #8b2252;">"a[b][c]"</span>))
             (create-array-type '((2) (3))))
            (var (parse-mcpl-expr <span style="color: #8b2252;">"a[c + b * (1 * 3)]"</span>))))
  (is (ast= (flatten-var
             (var (parse-mcpl-expr <span style="color: #8b2252;">"a[a,b][c,d]"</span>))
             (create-array-type '((2 3) (4 5))))
            (var
             (parse-mcpl-expr
              <span style="color: #8b2252;">"a[d + b * (1 * 5) + (c + a * (1 * 4)) * (1 * (5 * 3 + 0 + 0))]"</span>)))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org2f5e223" class="outline-4">
<h4 id="org2f5e223"><span class="section-number-4">7.3.3</span> Fold constants</h4>
<div class="outline-text-4" id="text-7-3-3">
</div>
<div id="outline-container-org846b807" class="outline-5">
<h5 id="org846b807"><span class="section-number-5">7.3.3.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:fold-constants</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:fold-constant</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc8a52c1" class="outline-5">
<h5 id="orgc8a52c1"><span class="section-number-5">7.3.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">fold-constant</span> (ast <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Fold constants in AST form.</span>
<span style="color: #8b2252;">Optionally, a map of bindings from string to expressions can be given."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((type mcl-type) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">declare</span> (ignore bindings))
  type)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((ct custom-type) <span style="color: #228b22;">&amp;optional</span> bindings)
  (make-custom-type
   (id ct)
   (<span style="color: #a020f0;">loop</span> for p in (params ct) collect (fold-constant p bindings))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((at array-type) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">with-slots</span> (base-type sizes) at
    (make-array-type (fold-constant base-type bindings)
                     (<span style="color: #a020f0;">loop</span> for s in sizes collect (fold-constant s bindings)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((das decl-array-size) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">with-slots</span> (size decl) das
    (make-decl-array-size (fold-constant size bindings)
                          decl)))



(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((expr expr) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">declare</span> (ignore bindings))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to implement fold-constants for ~a"</span> expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((p pow) <span style="color: #228b22;">&amp;optional</span> bindings)
  (do-binary #'expt #'make-pow p bindings))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((m mul) <span style="color: #228b22;">&amp;optional</span> bindings)
  (do-binary #'* #'make-mul m bindings))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((a add) <span style="color: #228b22;">&amp;optional</span> bindings)
  (do-binary #'+ #'make-add a bindings))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((d div) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">with-slots</span> (l r) d
    (<span style="color: #a020f0;">let</span> ((l (fold-constant l bindings))
          (r (fold-constant r bindings)))
      (<span style="color: #a020f0;">if</span> (and (typep l 'int-constant) (typep r 'int-constant))
          (<span style="color: #a020f0;">let</span> ((l-value (int-value l))
                (r-value (int-value r)))
            (<span style="color: #a020f0;">if</span> (eql (mod l-value r-value) 0)
                (make-int-constant (/ l-value r-value))
                (make-div l r)))
          (make-div l r)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((ic int-constant) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">declare</span> (ignore bindings))
  ic)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((ve var-expr) <span style="color: #228b22;">&amp;optional</span> bindings)
  (aif (fold-constant (var ve) bindings)
       (<span style="color: #a020f0;">if</span> (eq it ve)
           ve
           (fold-constant it bindings))
       ve))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((nv normal-var) <span style="color: #228b22;">&amp;optional</span> bindings)
  (fold-constant (basic-var nv) bindings))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((dv dot-var) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">declare</span> (ignore bindings))
  (<span style="color: #a020f0;">if</span> (query-hdl-mcpl:hardware-description-var-p dv)
      (query-hdl-mcpl:resolve-hardware-description-var dv)
      dv))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">fold-constant</span> ((bv basic-var) <span style="color: #228b22;">&amp;optional</span> bindings)
  (<span style="color: #a020f0;">with-slots</span> (id array-exprs) bv
    (<span style="color: #a020f0;">if</span> array-exprs nil (resolve bv bindings))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">resolve</span> (var bindings))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((bv basic-var) bindings)
  (resolve (basic-decl bv) bindings))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((bd basic-decl) bindings)
    (aif (resolve (decl bd) bindings)
         it
         (<span style="color: #a020f0;">if</span> bindings (gethash (name (id bd)) bindings) nil)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((nd normal-decl) bindings)
  (<span style="color: #a020f0;">declare</span> (ignore bindings))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">resolve</span> ((ad assign-decl) bindings)
  (fold-constant (expr ad) bindings))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-binary</span> (fold-func remake-func binary-expr bindings)
  (<span style="color: #a020f0;">with-slots</span> (l r) binary-expr
    (<span style="color: #a020f0;">let</span> ((l (fold-constant l bindings))
          (r (fold-constant r bindings)))
      (<span style="color: #a020f0;">if</span> (and (typep l 'int-constant) (typep r 'int-constant))
          (make-int-constant (funcall fold-func (int-value l) (int-value r)))
          (funcall remake-func l r)))))
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-orgd165cc2" class="outline-4">
<h4 id="orgd165cc2"><span class="section-number-4">7.3.4</span> Remove hardware variables</h4>
<div class="outline-text-4" id="text-7-3-4">
</div>
<div id="outline-container-org079bb24" class="outline-5">
<h5 id="org079bb24"><span class="section-number-5">7.3.4.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:remove-hardware-vars</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:query-hdl-mcpl</span> <span style="color: #483d8b;">:set-parents</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:remove-hardware-vars</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd369cd" class="outline-5">
<h5 id="orgbd369cd"><span class="section-number-5">7.3.4.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-hardware-vars</span> (module)
  (log-micro-pass <span style="color: #8b2252;">"remove-hardware-vars"</span> module)
  (<span style="color: #a020f0;">let</span> ((hardware-variables
         (collect-all module #'(<span style="color: #a020f0;">lambda</span> (ast)
                                 (and (typep ast 'dot-var)
                                      (hardware-description-var-p ast))))))
    (<span style="color: #a020f0;">dolist</span> (hv hardware-variables)
      (<span style="color: #a020f0;">let</span> ((expr (parent hv)))
        (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep expr 'expr))
        (replace-in-ast expr <span style="color: #483d8b;">:with</span> (resolve-hardware-description-var hv))))
    (set-parents module)
    module))
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org09decf5" class="outline-4">
<h4 id="org09decf5"><span class="section-number-4">7.3.5</span> Move dimension constants out foreach statements</h4>
<div class="outline-text-4" id="text-7-3-5">
</div>
<div id="outline-container-orgbdef37c" class="outline-5">
<h5 id="orgbdef37c"><span class="section-number-5">7.3.5.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-5-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:move-dimension-constants</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:set-parents</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:appendf</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span> <span style="color: #483d8b;">:fixed-point</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:move-dimension-constants</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org59fb0a5" class="outline-5">
<h5 id="org59fb0a5"><span class="section-number-5">7.3.5.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-5-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-dimension-constants</span> (module)
  (log-micro-pass <span style="color: #8b2252;">"move-dimension-constants"</span> module)
  (<span style="color: #a020f0;">dolist</span> (fe (collect-all module #'top-level-foreach-p))
    (move-dimension-constants-foreach fe)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-dimension-constants-foreach</span> (foreach)
  (<span style="color: #a020f0;">let</span> ((dimension-constants nil)
        (foreachs (collect-all foreach #'(<span style="color: #a020f0;">lambda</span> (x)
                                            (and (typep x 'foreach-stat)
                                                 (not (inner-foreach-p x)))))))
    (<span style="color: #a020f0;">loop</span> for fe in foreachs
         do (appendf dimension-constants (remove-dimension-stats fe)))
    (<span style="color: #a020f0;">loop</span> for dc in dimension-constants
         do (insert-before-ast foreach dc))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-dimension-stats</span> (not-inner-foreach)
  (<span style="color: #a020f0;">let</span> ((dimension-stats (filter #'dimension-stat-p
                                 (stats (code-block (stat not-inner-foreach))))))
    (<span style="color: #a020f0;">loop</span> for stat in dimension-stats
       collect (copy-ast stat)
       do (remove-from-ast stat))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dimension-stat-p</span> (stat)  (and (typep stat 'decl-stat)
       (typep (decl stat) 'assign-decl)
       (typep (get-type-decl (decl stat)) 'int)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf43f28a" class="outline-4">
<h4 id="orgf43f28a"><span class="section-number-4">7.3.6</span> Move foreach to function</h4>
<div class="outline-text-4" id="text-7-3-6">
</div>
<div id="outline-container-orga9b2186" class="outline-5">
<h5 id="orga9b2186"><span class="section-number-5">7.3.6.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-6-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:move-foreach-to-func</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:move-stats-to-func</span>
        <span style="color: #483d8b;">:set-parents</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:move-foreach-to-func</span> <span style="color: #483d8b;">:kernel-func-p</span> <span style="color: #483d8b;">:get-many-core-funcs-ordered</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc332b7c" class="outline-5">
<h5 id="orgc332b7c"><span class="section-number-5">7.3.6.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-6-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-foreach-to-func</span> (module)
  (log-micro-pass <span style="color: #8b2252;">"move-foreach-to-func"</span> module)
  (<span style="color: #a020f0;">dolist</span> (fe (collect-all module #'top-level-foreach-p))
    (move-stats-to-func (list fe) <span style="color: #8b2252;">"Kernel"</span>)))
</pre>
</div>

<p>
After this pass, we define the term kernel function, which is a function that
does nothing but running a kernel.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">kernel-func-p</span> (ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">kernel-func-p</span> ((f func))
  (<span style="color: #a020f0;">loop</span> for stat in (stats (code-block f))
     thereis (typep stat 'foreach-stat)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">kernel-func-p</span> ((c call))
  (and (not (builtin-func-p c)) (kernel-func-p (func c))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">kernel-func-p</span> ((cs call-stat))
  (kernel-func-p (call cs)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">kernel-func-p</span> ((ast ast))
  nil)
</pre>
</div>

<p>
We can then also decide which functions are many-core functions and run on a
many-core device.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-many-core-funcs-ordered</span> (callgraph)
  (<span style="color: #a020f0;">let</span> ((kernel-funcs (filter #'kernel-func-p (funcs-ordered callgraph))))
    (get-funcs-subgraph-ordered callgraph kernel-funcs)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgdc7537d" class="outline-4">
<h4 id="orgdc7537d"><span class="section-number-4">7.3.7</span> Move foreach to function for Cashmere</h4>
<div class="outline-text-4" id="text-7-3-7">
</div>
<div id="outline-container-orgf4b91fe" class="outline-5">
<h5 id="orgf4b91fe"><span class="section-number-5">7.3.7.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-7-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:move-foreach-to-func-cashmere</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:move-stats-to-func</span>
        <span style="color: #483d8b;">:set-parents</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:move-foreach-to-func-cashmere</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org26caca4" class="outline-5">
<h5 id="org26caca4"><span class="section-number-5">7.3.7.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-7-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-foreach-to-func-cashmere</span> (module)
  (log-micro-pass <span style="color: #8b2252;">"move-foreach-to-func-cashmere"</span> module)
  (<span style="color: #a020f0;">dolist</span> (fe (collect-all module #'top-level-foreach-p))
    (move-stats-to-func (append (find-dimension-stats fe) (list fe)) <span style="color: #8b2252;">"Kernel"</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-dimension-stats</span> (foreach)
  (sort (collect (parent foreach) #'dimension-stat-p) #'ast&lt;))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dimension-stat-p</span> (stat)
  (and (typep stat 'decl-stat)
       (<span style="color: #a020f0;">let</span> ((decl (decl stat)))
         (and (constant-p decl)
              (ast= (get-type-decl decl) (make-int))))))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orge503d5c" class="outline-4">
<h4 id="orge503d5c"><span class="section-number-4">7.3.8</span> Move stats to function</h4>
<div class="outline-text-4" id="text-7-3-8">
</div>
<div id="outline-container-org7fd6c11" class="outline-5">
<h5 id="org7fd6c11"><span class="section-number-5">7.3.8.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-8-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:move-stats-to-func</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:dependencies</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span> <span style="color: #483d8b;">:fixed-point</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:move-stats-to-func</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf760064" class="outline-5">
<h5 id="orgf760064"><span class="section-number-5">7.3.8.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-8-2">
<p>
The following function is the top-level function that moves a list of
statements to a new function.  It first retrieves all declarations from the
statements.  Since declarations may have their own dependencies as well, for
example from the types, we need to retrieve dependencies from these
declarations as well.
</p>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-stats-to-func</span> (stats suffix)
  (<span style="color: #a020f0;">let*</span> ((decls (get-dependent-decls (get-decls-from-stats stats)))
         (original-func (get-func (first stats)))
         (name (get-name original-func suffix)))
    (create-called decls stats original-func name)
    (create-caller decls stats name)
    (<span style="color: #a020f0;">dolist</span> (s stats) (remove-from-ast s))))
</pre>
</div>

<p>
Retrieving the declarations from statements:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-decls-from-stats</span> (stats)
  (<span style="color: #a020f0;">let</span> ((set (make-set)))
    (<span style="color: #a020f0;">loop</span> for stat in stats
       do (add-all-to-set (get-decls-from-stat stat) set))
    (filter #'(<span style="color: #a020f0;">lambda</span> (x)
                     (not-defined-in-stats x stats))
                 (elements set))))
</pre>
</div>

<p>
Getting the declarations from one stat:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-decls-from-stat</span> (stat)
  (<span style="color: #a020f0;">let</span> ((defs-before-uses (get-direct-defs-before-uses-ast stat))
        (uses-after-defs (get-uses-after-defs-ast stat))
        (defs-before-defs (get-defs-before-defs-ast stat))
        (defs-after-defs (get-defs-after-defs-ast stat)))
    (mapcar #'decl (concatenate
                    'list defs-before-uses uses-after-defs defs-before-defs
                    defs-after-defs))))
</pre>
</div>

<p>
Retrieving the dependent declarations from a list of declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-dependent-decls</span> (decls)
  (<span style="color: #a020f0;">let</span> ((set (make-set <span style="color: #483d8b;">:elements</span> decls)))
    (<span style="color: #a020f0;">loop</span> for d in decls
         do (add-all-to-set (get-dependent-decls-decl d) set))
    (mapcar #'transform-assign-decl
            (sort (elements set) #'ast&lt;))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-dependent-decls-decl</span> (decl)
  (mapcar #'decl (get-direct-defs-before-uses-ast decl)))
</pre>
</div>

<p>
Transforming an assignment declaration into a normal declaration:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-assign-decl</span> (decl)
  (<span style="color: #a020f0;">if</span> (typep decl 'assign-decl)
      (<span style="color: #a020f0;">with-slots</span> (modifiers basic-decl) decl
        (make-normal-decl modifiers (list basic-decl)))
      decl))
</pre>
</div>

<p>
Whether an ast is defined in stats.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">not-defined-in-stats</span> (ast stats)
  (not (parent-in-asts-p ast stats)))
</pre>
</div>

<p>
The following function determines the name and solves problems if a
function-name already exists.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-name</span> (original-func suffix)
  (<span style="color: #a020f0;">let</span> ((new-name (concatenate 'string (name (id original-func)) suffix)))
    (<span style="color: #a020f0;">if</span> (func-exists-p new-name original-func)
        (get-name original-func (concatenate 'string suffix <span style="color: #8b2252;">"0"</span>))
        new-name)))
</pre>
</div>

<p>
Create the called function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-called</span> (decls stats original-func name)
  (insert-before-ast
   original-func
   (make-func (make-id (name (hw-desc original-func)))
              (make-void)
              (make-id name)
              (mapcar #'copy-ast decls)
              (make-code-block (copy-ast stats)))))
</pre>
</div>

<p>
Create the call that calls this function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-caller</span> (decls stats name)
  (insert-before-ast
   (first stats)
   (make-call-stat (make-call
                    (make-id name)
                    (mapcar #'create-expr decls)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-expr</span> (decl)
  (make-var-expr (make-normal-var (make-basic-var 
                                   (make-id (name (get-id decl))) nil))))
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org34245b4" class="outline-4">
<h4 id="org34245b4"><span class="section-number-4">7.3.9</span> Move stats out function</h4>
<div class="outline-text-4" id="text-7-3-9">
</div>
<div id="outline-container-org8886f25" class="outline-5">
<h5 id="org8886f25"><span class="section-number-5">7.3.9.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-9-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:move-stats-out-func</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dependencies</span>
        <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:set-cfgraphs</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:def-methods</span> <span style="color: #483d8b;">:fixed-point</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:move-stats-out-func</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgac780e4" class="outline-5">
<h5 id="orgac780e4"><span class="section-number-5">7.3.9.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-9-2">
<p>
Moving statements out of the function cannot happen in one go.  Whether a
statement can move out of a function depends on whether it is used before or
afterwards.  Suppose we have statements A and B in that order.  Both use
variable V.  Since A uses variable V, only B can be moved out of the function.
However, now that B has moved there is no other statement A depends on, so it
can move out of the function as well.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-stats-out-func</span> (stats)
  (<span style="color: #a020f0;">let</span> ((stats-to-move (copy-list stats)))
    (fixed-point stats-to-move #'copy-list #'equals-list
<span style="color: #b22222;">;;      </span><span style="color: #b22222;">(format t "iteration:~%~{~a~%~}~%~%" stats-to-move)</span>
      (<span style="color: #a020f0;">unless</span> (null stats-to-move)
        (setf stats-to-move (move-stats-out-func-iteration stats-to-move))))))
</pre>
</div>

<p>
In an iteration, we find the statements that are eligible for moving them
before the call, and the statements for after the call.  After the statements
have been moved, we remove the old statements from the function.  This means
that we have to reset the funtion as discussed below.  Finally, the difference
between <code>stats</code> and the moved stats is returned for another iteration.  A
statement is eligible if it only depends on the parameters of the enclosing
function of the statement.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-stats-out-func-iteration</span> (stats)
  (<span style="color: #a020f0;">let</span> ((stats-before (filter #'eligible-for-move-before-call-p stats))
        (stats-after (filter #'eligible-for-move-after-call-p stats))
        (func (get-func (first stats)))
        (moved-stats nil))
    (<span style="color: #a020f0;">dolist</span> (called-by (called-by func))
      (move-stats-to-call called-by func stats-before #'insert-before-ast)
      (move-stats-to-call called-by func stats-after #'insert-after-ast)
      (<span style="color: #a020f0;">dolist</span> (s (union stats-before stats-after)) (pushnew s moved-stats)))
    (<span style="color: #a020f0;">let</span> ((stats-to-do (set-difference stats moved-stats)))
      (<span style="color: #a020f0;">dolist</span> (s moved-stats) (remove-from-ast s))
      (reset-func func)
      stats-to-do)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-stats-to-call</span> (call func stats insert-func)
  (<span style="color: #a020f0;">dolist</span> (stat stats)
    (move-stat-to-call call func stat insert-func)))
</pre>
</div>

<p>
The function <code>move-stat-to-call</code> inserts a new version of <code>stat</code> before or
after the call <code>call</code>, depending on <code>insert-func</code>.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">move-stat-to-call</span> (call func stat insert-func)
  (funcall insert-func (get-stat call) (create-new-stat stat func call)))
</pre>
</div>

<p>
Creating a new statement means that the expressions in the statement have to be
replaced by new expressions that match the scope of the call.  Since we
require that the variables in the statement to move completely depend on the
parameters of the function, we can easily replace the variable expressions with
the expressions from the call.  <b>Note:</b> this pass does only simple substitution
without type checking/conversion.
</p>

<p>
Since the expressions and declarations come from parameters, existing code, we
need to create fresh values for the AST.  This means that <code>replace-exprs</code> has
to copy them at some point.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-stat</span> (stat func call)
  (<span style="color: #a020f0;">let</span> ((decls-func (params func))
        (exprs-call (params call)))
    (replace-exprs stat decls-func exprs-call)))
</pre>
</div>

<p>
The function <code>replace-exprs</code> performs a mirrored visit (a visit on the old AST
and a parallel visit on the copy of the AST) and replaces each variable
expression with an expression from the call.
</p>

<p>
The functions <code>replace-expres-fw/bw</code> have to copy <code>decls</code> and <code>exprs</code> at some
point.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">replace-exprs</span> (ast decls exprs)
  (<span style="color: #a020f0;">let</span> ((copy (set-parents (copy-ast ast))))
    (mirrored-visit 
     ast copy
     #'(<span style="color: #a020f0;">lambda</span> (ro-x mod-x) (replace-exprs-fw ro-x mod-x decls exprs))
     #'(<span style="color: #a020f0;">lambda</span> (ro-x mod-x) (replace-exprs-bw ro-x mod-x decls exprs)))
    copy))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-exprs-fw</span> (ro-ast mod-x decls exprs))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-exprs-bw</span> (ro-ast mod-x decls exprs))

(def-methods replace-exprs-fw ((ro-ast (ast string list number symbol))
                                  mod-ast decls exprs)
  t)

(def-methods replace-exprs-bw ((ro-ast (ast string list number symbol))
                                  mod-ast decl exprs)
  nil)

</pre>
</div>

<p>
Since the new replacement is based on <code>exprs</code>, we have to create a copy to
obtain a fresh AST-form.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">replace-exprs-bw</span> ((ro-var-expr var-expr) (mod-var-expr var-expr) 
                             decls exprs)
  (<span style="color: #a020f0;">let</span> ((ro-var (var ro-var-expr)))
    (replace-in-ast mod-var-expr <span style="color: #483d8b;">:with</span>
                    (copy-ast (nth (get-index ro-var decls) exprs)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-index</span> (var decls)
  (<span style="color: #a020f0;">let</span> ((result (position (decl (basic-decl (basic-var var))) decls)))
    (<span style="color: #ff0000; font-weight: bold;">assert</span> (not (null result)))
    result))
</pre>
</div>

<p>
After statements within a function have been moved, the function needs to be
reset.  This means that we have to set the parents again, set whether a
variable is written, and we have to reset the controlflow graphs.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reset-func</span> (func)
  (set-parents func)
  (set-cfgraphs func))
</pre>
</div>









<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">only-depends-on-param-p</span> (def-decl)
  (<span style="color: #a020f0;">with-slots</span> (bb decl) def-decl
    (and (typep bb  'bb-decl)
         (param-p decl))))
</pre>
</div>

<p>
Only depends on a parameter and has no other uses before.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">only-depends-on-params</span> (stat)
  (<span style="color: #a020f0;">loop</span> for d in (get-defs-before-uses-ast stat)
     always (only-depends-on-param-p d)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">no-uses-before</span> (stat)
  (null (get-uses-before-uses-ast stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">eligible-for-move-before-call-p</span> (stat)
  (and (only-depends-on-params stat)
       (no-uses-before stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">no-uses-after-uses</span> (stat)
  (null (get-uses-after-uses-ast stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">no-defs-after-uses</span> (stat)
  (null (get-defs-after-uses-ast stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">no-defs-after-defs</span> (stat)
  (null (get-defs-after-defs-ast stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">no-uses-after-defs</span> (stat)
  (null (get-uses-after-defs-ast stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">eligible-for-move-after-call-p</span> (stat)
  (and (no-uses-after-uses stat)
       (no-defs-after-uses stat)
       (no-uses-after-defs stat)
       (no-defs-after-defs stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">equals-list</span> (l1 l2)
  (null (set-exclusive-or l1 l2)))



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-stat</span> (call)
  (parent call))

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org4d00482" class="outline-4">
<h4 id="org4d00482"><span class="section-number-4">7.3.10</span> Specialize functions on memory-space</h4>
<div class="outline-text-4" id="text-7-3-10">
</div>
<div id="outline-container-orgc7e272e" class="outline-5">
<h5 id="orgc7e272e"><span class="section-number-5">7.3.10.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-10-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:specialize-funcs-on-memory-space</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:set-parents</span>
        <span style="color: #483d8b;">:resolve-types</span> <span style="color: #483d8b;">:resolve-vars</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:appendf</span> <span style="color: #483d8b;">:removef</span> <span style="color: #483d8b;">:compose</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span> <span style="color: #483d8b;">:cartesian-product</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:specialize-funcs-on-memory-space</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org87c1fa5" class="outline-5">
<h5 id="org87c1fa5"><span class="section-number-5">7.3.10.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-10-2">
<p>
Specializing functions based on memory-spaces takes place in several steps.
First we determine the specifications of a function based on the memory-spaces,
which is the cartesian product of all the combinations of memory-spaces for
each parameter of the function.  We then create new functions and insert them
into the AST.  
</p>

<p>
Unfortunately, the calls in the functions have not changed yet.  This poses
several challenges:
</p>
<ul class="org-ul">
<li>to change the call, we need to know the memory spaces of the expressions in
the parameter list.</li>
<li>Therefore, we need to perform a resolution of the variables in the newly
created functions.</li>
<li>To do this, we need to resolve the types in the modules.  This needs an
overview of all the exports in the modules.</li>
</ul>

<p>
With this information resolved, we can modify all the calls.  After that, we
can remove the old functions and we can update the exports of the modules.
Based on the function-specifications, we can change the <code>export</code>
statement in each module and replace the old function with the new ones.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">specialize-funcs-on-memory-space</span> (modules callgraph exports)
  (<span style="color: #a020f0;">let*</span> ((funcs (funcs-ordered callgraph))
         (func-specifications (get-func-specifications funcs)))
    (<span style="color: #a020f0;">let</span> ((new-funcs (create-new-funcs func-specifications))
          (non-transformed-funcs
           (set-difference funcs (mapcar #'first func-specifications))))
      (prepare-for-changing-calls modules exports)
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(p "funcs" funcs)</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(p "new-funcs" new-funcs)</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(p "non-transformed-funcs" non-transformed-funcs)</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(p "wanted" (union new-funcs non-transformed-funcs))</span>
      (modify-calls func-specifications
                    (union new-funcs non-transformed-funcs))
      (remove-funcs func-specifications)
      (modify-exports func-specifications))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">prepare-for-changing-calls</span> (modules exports)
  (resolve-all modules exports #'resolve-types)
  (resolve-all modules exports #'resolve-vars))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">resolve-all</span> (modules exports func)
  (<span style="color: #a020f0;">loop</span> for m in modules
     do (funcall func m exports)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">p</span> (type funcs)
  (format t <span style="color: #8b2252;">"~a:~%~{~a~%~}~%~%"</span> type funcs))
</pre>
</div>


<p>
The following functions deal with inserting new functions based on the
specifications. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-funcs</span> (func-specifications)
  (<span style="color: #a020f0;">loop</span> for fs in func-specifications append (create-new-funcs-from-func fs)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-funcs-from-func</span> (func-specification)
  (<span style="color: #a020f0;">destructuring-bind</span> (func . modifiers-spec) func-specification
    (<span style="color: #a020f0;">loop</span> for spec in modifiers-spec collect (create-new-func func spec))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-func</span> (func spec)
  (<span style="color: #a020f0;">let</span> ((new-func (copy-ast func)))
    (set-parents new-func)
    (<span style="color: #a020f0;">with-slots</span> (id params) new-func
      (<span style="color: #a020f0;">let</span> ((new-id (make-new-id id spec)))
        (replace-in-ast id <span style="color: #483d8b;">:with</span> new-id))
      (<span style="color: #a020f0;">loop</span>
         for param in params
         for mod-spec in spec
         unless (spec= mod-spec (get-modifiers-decl param))
         do (remove-modifiers-from-param param mod-spec)))
    (insert-before-ast func new-func)
    new-func))
</pre>
</div>

<p>
The following functions change the export clauses in the modules.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">modify-exports</span> (func-specifications)
  (<span style="color: #a020f0;">loop</span> for fs in func-specifications do (modify-exports-from-func fs)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">modify-exports-from-func</span> (func-specification)
  (<span style="color: #a020f0;">destructuring-bind</span> (func . modifiers-spec) func-specification
    (<span style="color: #a020f0;">let</span> ((module (get-module func))
          (id (id func)))
      (<span style="color: #a020f0;">when</span> (member id (exports module) <span style="color: #483d8b;">:test</span> #'ast=)
        (replace-export id modifiers-spec module)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">replace-export</span> (id modifiers-spec module)
  (removef (exports module) id <span style="color: #483d8b;">:test</span> #'ast=)
  (appendf (exports module) (mapcar #'(<span style="color: #a020f0;">lambda</span> (spec)
                                        (make-new-id id spec))
                                    modifiers-spec)))
</pre>
</div>

<p>
The following functions modify the calls conforming to the newly created
functions. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">modify-calls</span> (func-specifications funcs)
  (<span style="color: #a020f0;">let</span> ((calls (collect-all funcs #'(<span style="color: #a020f0;">lambda</span> (x) (typep x 'call)))))
    (<span style="color: #a020f0;">loop</span> for call in calls
       do (modify-call call func-specifications))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">modify-call</span> (call func-specifications)
<span style="color: #b22222;">;;  </span><span style="color: #b22222;">(format t "~%analyzing call ~a in func: ~a~%" call (get-func call))</span>
  (<span style="color: #a020f0;">loop</span> for fs in func-specifications do (modify-call-for-func call fs)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">modify-call-for-func</span> (call func-spec)
  (<span style="color: #a020f0;">destructuring-bind</span> (func . modifiers-spec) func-spec
    (<span style="color: #a020f0;">when</span> (or (eq (func call) func)
              (and (null (func call)) (ast= (id func) (id call))))
<span style="color: #b22222;">;;      </span><span style="color: #b22222;">(format t "  calls a function that we transformed~%")</span>
      (modify-call-to-specs call modifiers-spec))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">modify-call-to-specs</span> (call modifiers-spec)
  (<span style="color: #a020f0;">loop</span> for spec in modifiers-spec
     do (modify-call-to-spec call spec)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">modify-call-to-spec</span> (call spec)
  (<span style="color: #a020f0;">when</span> (satisfies-spec call spec)
    (<span style="color: #a020f0;">with-slots</span> (id) call
      (<span style="color: #a020f0;">let</span> ((new-id (make-new-id id spec)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">      (format t "  replacing it with ~a~%" new-id)</span>
        (replace-in-ast id <span style="color: #483d8b;">:with</span> new-id)))))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun modify-calls-from-func (func-specification)</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(destructuring-bind (func . modifiers-spec) func-specification</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(loop for spec in modifiers-spec do (modify-calls-func func spec))))</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun modify-calls-func (func spec)</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(loop for call in (called-by func)</span>
<span style="color: #b22222;">;;      </span><span style="color: #b22222;">do (format t "  checking call ~a in func: ~a~%" call (get-func call))</span>
<span style="color: #b22222;">;;        </span><span style="color: #b22222;">(when (satisfies-spec call spec)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">      )))</span>
</pre>
</div>

<p>
The following functions remove the transformed functions.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-funcs</span> (func-specifications)
  (<span style="color: #a020f0;">loop</span> for fs in func-specifications do (remove-funcs-from-func fs)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-funcs-from-func</span> (func-specification)
  (<span style="color: #a020f0;">destructuring-bind</span> (func . spec) func-specification
    (<span style="color: #a020f0;">declare</span> (ignore spec))
    (remove-from-ast func)))
</pre>
</div>

<p>
The following functions are helper functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*excluded-funcs*</span> '(<span style="color: #8b2252;">"sincos"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-func-specifications</span> (funcs)
  (filter #'multiple-specs-p
          (<span style="color: #a020f0;">loop</span> for f in funcs
             unless (excluded f)
             collect (cons f (get-cartesian-product (get-modifiers-func f))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">excluded</span> (func)
  (member (name (id func)) *excluded-funcs* <span style="color: #483d8b;">:test</span> #'string=))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">multiple-specs-p</span> (func-specification)
  (<span style="color: #a020f0;">destructuring-bind</span> (func . modifiers-spec) func-specification
    (<span style="color: #a020f0;">declare</span> (ignore func))
    (&gt;  (length modifiers-spec) 1)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-new-id</span> (id spec)
  (make-id (format nil <span style="color: #8b2252;">"~a~a"</span> (name id) (get-suffix-spec spec))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">satisfies-spec</span> (call spec)
  (spec= spec (get-modifiers-call call)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-modifiers-from-param</span> (param spec)
  (<span style="color: #a020f0;">loop</span> for modifier in (modifiers param)
     unless (typep modifier 'const)
     do (<span style="color: #a020f0;">when</span> (not (member modifier spec <span style="color: #483d8b;">:test</span> #'ast=))
          (remove-from-ast modifier))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">spec=</span> (spec1 spec2)
  (and (eql (length spec1) (length spec2))
       (<span style="color: #a020f0;">loop</span> for s1 in spec1 for s2 in spec2 always (spec-item= s1 s2))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">spec-item=</span> (spec1 spec2)
  (<span style="color: #a020f0;">if</span> (or (eq spec1 'no-mod) (eq spec2 'no-mod))
      (eq spec1 spec2)
      (ast= spec1 spec2)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-modifiers-func</span> (func)
  (mapcar #'get-modifiers-decl (params func)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-modifiers-decl</span> (decl)
  (<span style="color: #a020f0;">if</span> (memory-space-disallowed decl)
      (list 'no-mod)
      (aif (get-modifiers-decl2 decl)
           it
           (list 'no-mod))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-modifiers-decl2</span> (decl)
  (aif  (filter #'(<span style="color: #a020f0;">lambda</span> (m)
                    (typep m 'user-defined))
                (modifiers decl))
        it
        (mapcar (compose #'make-user-defined #'make-id)
                (query-hdl-mcpl:get-memory-spaces decl))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-modifiers-call</span> (call)
  (mapcar #'get-modifiers-expr (params call)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-modifiers-expr</span> (expr)
  (<span style="color: #a020f0;">if</span> (memory-space-disallowed expr)
      (list 'no-mod)
      (<span style="color: #a020f0;">progn</span>
        (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep expr 'var-expr))
        (get-modifiers-decl (get-decl-var (var expr))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-cartesian-product</span> (modifiers-spec)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (x) (mapcar #'list x)) (cartesian-product modifiers-spec)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-suffix-spec</span> (modifiers-spec)
  (format nil <span style="color: #8b2252;">"~{~a~}"</span> (mapcar (compose #'get-suffix-part #'first)
                               modifiers-spec)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-suffix-part</span> (mod-spec)
  (<span style="color: #a020f0;">if</span> (eq mod-spec 'no-mod)
      <span style="color: #8b2252;">""</span>
      (string-upcase (name (modifier mod-spec)) <span style="color: #483d8b;">:end</span> 1)))
</pre>
</div>
</div>
</div>




<div id="outline-container-org6c78df0" class="outline-5">
<h5 id="org6c78df0"><span class="section-number-5">7.3.10.3</span> Testing specializing functions on memory space</h5>
<div class="outline-text-5" id="text-7-3-10-3">
</div>
<ul class="org-ul">
<li><a id="org2ebb80d"></a>The package<br />
<div class="outline-text-6" id="text-org2ebb80d">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-specialize-funcs-on-memory-space</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:mcl-util</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span>
        <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:resolve-vars</span> <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:set-vars-written</span>
        <span style="color: #483d8b;">:specialize-funcs-on-memory-space</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-specialize-funcs-on-memory-space</span>))
</pre>
</div>
</div>
</li>


<li><a id="org821088e"></a>The tests for the specialization<br />
<div class="outline-text-6" id="text-org821088e">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite specialize-funcs-on-memory-space <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite specialize-funcs-on-memory-space)

(test specialize-funcs-on-memory-space
  (is
    (specialize-ok
     <span style="color: #483d8b;">:input</span> '((<span style="color: #8b2252;">"f"</span>)
              (<span style="color: #8b2252;">"perfect void f(int l, reg main float[l] a)"</span>)
              (<span style="color: #8b2252;">"f(l, a)"</span>
               <span style="color: #8b2252;">"f(l, b)"</span>))
     <span style="color: #483d8b;">:output</span> '((<span style="color: #8b2252;">"fReg"</span> <span style="color: #8b2252;">"fMain"</span>)
               (<span style="color: #8b2252;">"perfect void fReg(const int l, const reg float[l] a)"</span>
                <span style="color: #8b2252;">"perfect void fMain(const int l, const main float[l] a)"</span>)
               (<span style="color: #8b2252;">"fMain(l, a)"</span>
                <span style="color: #8b2252;">"fReg(l, b)"</span>))))
  (is 
   (specialize-ok
    <span style="color: #483d8b;">:input</span> '((<span style="color: #8b2252;">"f"</span>)
             (<span style="color: #8b2252;">"perfect void f(int l, reg main float[l] a)"</span>)
             (<span style="color: #8b2252;">"f(l, a)"</span>
              <span style="color: #8b2252;">"f(l, a)"</span>))
    <span style="color: #483d8b;">:output</span> '((<span style="color: #8b2252;">"fReg"</span> <span style="color: #8b2252;">"fMain"</span>)
              (<span style="color: #8b2252;">"perfect void fReg(const int l, const reg float[l] a)"</span>
               <span style="color: #8b2252;">"perfect void fMain(const int l, const main float[l] a)"</span>)
              (<span style="color: #8b2252;">"fMain(l, a)"</span>
               <span style="color: #8b2252;">"fMain(l, a)"</span>)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">specialize-ok</span> (<span style="color: #228b22;">&amp;key</span> input output)
  (ast= (specialize (build-module input))
        (build-module output)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">specialize</span> (module)
  (<span style="color: #a020f0;">let</span> ((exports (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (set-parents module)
    (resolve-calls module exports)
    (<span style="color: #a020f0;">let</span> ((callgraph (set-callgraph (funcs (code module)))))
      (resolve-vars module exports)
      (set-cfgraphs:set-cfgraphs module)
      (set-vars-written callgraph)
      (specialize-funcs-on-memory-space (list module) callgraph exports)
      module)))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*module*</span>
  (tostring
   <span style="color: #8b2252;">"package a;"</span>
   <span style="color: #8b2252;">"module a;"</span>
   <span style="color: #8b2252;">"export ~{~a~^, ~};"</span>
   <span style="color: #8b2252;">"import perfect;"</span>
   <span style="color: #8b2252;">""</span>
   <span style="color: #8b2252;">"~{~a~^~%~}"</span>
   <span style="color: #8b2252;">""</span>
   <span style="color: #8b2252;">"perfect void start(const int l, const main float[l] a) {"</span>
   <span style="color: #8b2252;">"  ~a;"</span>
   <span style="color: #8b2252;">"  foreach (const int i in 1 threads) {"</span>
   <span style="color: #8b2252;">"    const float[l] b;"</span>
   <span style="color: #8b2252;">"    ~a;"</span>
   <span style="color: #8b2252;">"  }"</span>
   <span style="color: #8b2252;">"}"</span>
   <span style="color: #8b2252;">""</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-module</span> (funcs)
  (<span style="color: #a020f0;">destructuring-bind</span> (exports func-headers func-calls) funcs
    (parse-mcpl (apply #'format nil
                       *module*
                       exports
                       (mapcar #'build-func func-headers)
                       func-calls))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-func</span> (func-header)
  (format nil <span style="color: #8b2252;">"~a {~%}"</span> func-header))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf8c63d4" class="outline-4">
<h4 id="orgf8c63d4"><span class="section-number-4">7.3.11</span> Transform tile expressions</h4>
<div class="outline-text-4" id="text-7-3-11">
<p>
This pass transforms calls with arrays that are addressed as tiles into calls
where the full pointer and an index is passed instead.  This is required for
generating code with OpenCL since one cannot pass pointers to a place within a
buffer to a kernel function.  
</p>

<p>
This is a challenging problem since the tiles may have been created somewhere
other than at the call.  Additionally, the partial pointers may be passed to
other functions that then also need transformation.
</p>

<p>
Finally, it may be needed to change arrays from different call sites.
</p>
</div>


<div id="outline-container-orgc9f456a" class="outline-5">
<h5 id="orgc9f456a"><span class="section-number-5">7.3.11.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-11-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:transform-tile-expressions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:aliases</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:appendf</span> <span style="color: #483d8b;">:flatten</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:transform-tile-expressions</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8b99058" class="outline-5">
<h5 id="org8b99058"><span class="section-number-5">7.3.11.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-3-11-2">
<p>
The following text is just a note:
</p>

<p>
A sketch of how the algorithm could be:
</p>

<ul class="org-ul">
<li>find the kernels</li>
<li>per kernel, check the calls for tiles, do this recursively up the call tree
and gather the funcs.  Per parameter indicate the parameter number and the
highest dimensionality of the parameters that need to be transformed.</li>
<li>Using this information we are going to change the calls and functions:</li>
</ul>

<p>
Move to the bottom calls, analyze all calls for the bottom function, store the
information about each call and function (which parameters are needed and
added.  Then change the function.  Then move to a higher function and repeat.
Basically, we need the information on the transformed functions for the higher
functions.
</p>


<ul class="org-ul">
<li>Replace the calls that need replacement</li>
<li>Transform the functions themselves as well</li>
<li>Transform all the calls</li>
</ul>

<p>
----------------------&#x2013;&#x2014; End of note -----------------&#x2013;&#x2014;
</p>
</div>


<ul class="org-ul">
<li><a id="orgeefe830"></a>The entry point<br />
<div class="outline-text-6" id="text-orgeefe830">
<p>
We first analyze all kernel functions to determine per function whether it
needs to be transformed and what parameters (in terms of their position) are
triggering the transformation.  Per parameter we keep track of how many
dimensions it needs.  This information is stored in <code>to-be-transformed-funcs</code>.
</p>

<p>
With this information, we transform the kernel functions and their callers.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-tile-expressions</span> (module exports)
  (<span style="color: #a020f0;">let</span> ((to-be-transformed-funcs (make-hash-table))
        (kernel-funcs (collect-all module #'kernel-func-p)))
    <span style="color: #b22222;">;;</span><span style="color: #b22222;">(dolist (func kernel-funcs) (analyze-func func to-be-transformed-funcs))</span>
    (transform-funcs kernel-funcs to-be-transformed-funcs exports)))
</pre>
</div>
</div>
</li>


<li><a id="orgcab8f43"></a>Analyzing functions<br />
<div class="outline-text-6" id="text-orgcab8f43">
<p>
Analyzing a function involves analyzing all calls.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze-func</span> (func to-be-transformed)
  (<span style="color: #a020f0;">dolist</span> (call (called-by func))
    (analyze-call call to-be-transformed)))
</pre>
</div>

<p>
The <code>analyze-call</code> function recursively calls <code>analyze-func</code> on the function
that contains the call to arrive at the top of the callgraph.  This is
necessary because information about whether a function should be transformed
has an effect on the functions lower in the callgraph.  We then retrieve the
tiled parameters of the call and add it to the <code>to-be-transformed</code> map.  
</p>

<p>
If we find tiled-parameters of the call, then we add it to the map with a
special function remembers the maximum of the number of dimensions.  If we do
not find tiled parameters, it could still be possible that the parameters are
actually tiled.  This is the case when the parent function (the function in
which the call is listed), has tiled parameters that are passed on to this
function.  <b>Actually</b>, this is also possible if we do find tiled parameters, so
this function is buggy and should need a <b>test</b>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze-call</span> (call to-be-transformed)
  (<span style="color: #a020f0;">let</span> ((parent-func (get-func call)))
    (analyze-func parent-func to-be-transformed)
    (<span style="color: #a020f0;">let</span> ((tiled-parameters-call (find-tiled-parameters-call call)))
      (<span style="color: #a020f0;">cond</span> (tiled-parameters-call
             (add-to-map (func call) tiled-parameters-call to-be-transformed))
            ((gethash parent-func to-be-transformed)
             (add-parent-tiles call parent-func to-be-transformed))))))
</pre>
</div>

<p>
We find tiled parameters in a call by comparing the type of the variable
expressions.  We collect the position in the parameter list and the number of
dimensions of the expression.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-tiled-parameters-call</span> (call)
  (<span style="color: #a020f0;">with-slots</span> (params) call
    (<span style="color: #a020f0;">let</span> ((result
           (<span style="color: #a020f0;">loop</span>
              for param in params
              for i below (length params)
              when (and (typep param 'var-expr)
                        (not (check-types::equals-type
                              (eval-type param)
                              (check-types::get-type
                               (get-primary-decl param)))))
              collect (cons i (get-nr-dims-decl param)))))
      (sort result #'parameter-spec&lt;))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parameter-spec&lt;</span> (parameter-spec1 parameter-spec2)
  (&lt; (car parameter-spec1) (car parameter-spec2)))
</pre>
</div>

<p>
We retrieve the number of dimensions of expressions or declarations by
retrieving it from the type.  If it is a primitive type or a custom type, then
the number of dimensions is 0.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-nr-dims-expr</span> (param)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep param 'var-expr))
  (get-nr-dims-type (eval-type param)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-nr-dims-decl</span> (param))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-nr-dims-decl</span> ((e expr))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep e 'var-expr))
  (get-nr-dims-decl (get-decl-from-expr e)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-decl-from-expr</span> (e)
  (<span style="color: #a020f0;">if</span> (typep (parent e) 'call)
      (get-primary-decl e)
      (get-decl-param e)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-nr-dims-decl</span> ((d decl))
  (get-nr-dims-type (check-types::get-type d)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-nr-dims-type</span> (type)
  (<span style="color: #a020f0;">cond</span> ((or (primitive-type-p type)
             (typep type 'custom-type))
         0)
        ((typep type 'array-type)
         (1+ (get-nr-dims-type (base-type type))))
        (t
         (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Type is neither a primitive, custom- or array-type"</span>))))
</pre>
</div>

<p>
We add tile information to the map in the following way: If the function is
already available, we have to merge it with the already available information.
Otherwise, we just add it.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-to-map</span> (func tiled-parameters to-be-transformed)
  (aif (gethash func to-be-transformed)
       (setf (gethash func to-be-transformed)
             (merge-tiled-parameters it tiled-parameters))
       (setf (gethash func to-be-transformed)
             tiled-parameters)))
</pre>
</div>

<p>
Merging happens recursively, we take the maximum of the <code>cdr</code> (the number of
dimensions at a position (<code>car</code>).
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">merge-tiled-parameters</span> (tps1 tps2)
  (<span style="color: #a020f0;">cond</span> ((null tps1) tps2)
        ((null tps2) tps1)
        (t (<span style="color: #a020f0;">destructuring-bind</span> (f1 <span style="color: #228b22;">&amp;rest</span> r1) tps1
             (<span style="color: #a020f0;">destructuring-bind</span> (f2 <span style="color: #228b22;">&amp;rest</span> r2) tps2
               (<span style="color: #a020f0;">cond</span> ((parameter-spec&lt; f1 f2)
                      (cons f1 (merge-tiled-parameters r1 tps2)))
                     ((parameter-spec&lt; f2 f1)
                      (cons f2 (merge-tiled-parameters tps1 r2)))
                     (t
                      (cons (cons (car f1) (max (cdr f1) (cdr f2)))
                            (merge-tiled-parameters r1 r2)))))))))
</pre>
</div>

<p>
In the <code>add-parent-tiles</code> function, we create a new <code>tiled-parameters-call</code>
based on the parameters of the parent function.  We have to convert the
position of the parent-func to the position in the call.  It is possible that a
parameter of the function is not passed on to the call.  This is filtered away
with the <code>when</code> statement in the loop.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-parent-tiles</span> (call parent-func to-be-transformed)
  (<span style="color: #a020f0;">let*</span> ((tiled-parameters-parent-func (gethash parent-func to-be-transformed))
         (tiled-parameters-call (<span style="color: #a020f0;">loop</span> for i in tiled-parameters-parent-func
                                   when (convert-position i parent-func call)
                                   collect it)))
    (<span style="color: #a020f0;">when</span> tiled-parameters-call
      (add-to-map (func call) tiled-parameters-call to-be-transformed))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">convert-position</span> (parameter-spec parent-func call)
  (<span style="color: #a020f0;">let*</span> ((position-parameter (car parameter-spec))
         (decl-parent-func (nth position-parameter (params parent-func))))
    (cons
     (position  decl-parent-func (mapcar #'get-decl-param (params call)))
     (cdr parameter-spec))))
</pre>
</div>



<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-tiled-parameters</span> (func)
  (<span style="color: #a020f0;">with-slots</span> (called-by) func
    (<span style="color: #a020f0;">let</span> (tiled-parameters)
      (reduce #'(<span style="color: #a020f0;">lambda</span> (result call)
                  (union result (find-tiled-parameters-call call)))
              called-by
              <span style="color: #483d8b;">:initial-value</span> tiled-parameters))))



(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">has-index</span> (var/expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">has-index</span> ((ve var-expr))
  (has-index (var ve)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">has-index</span> ((nv normal-var))
  (has-index (basic-var nv)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">has-index</span> ((bv basic-var))
  (not (null (array-exprs bv))))
</pre>
</div>
</div>
</li>



<li><a id="orga2c1194"></a><span class="todo TODO">TODO</span> Transforming functions<br />
<div class="outline-text-6" id="text-orga2c1194">
<p>
We transform the functions and append it into a list of functions that have
been transformed as to not transform function multiple times.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-funcs</span> (funcs func-info exports)
  (<span style="color: #a020f0;">loop</span> for func in funcs
     appending (transform-func func func-info funcs-done exports)
     into funcs-done))
</pre>
</div>

<p>
Transforming a function is done recursively again, to make sure we move first
to the top of the callgraph.  We have to append it to the <code>funcs-done</code> list.
We transform a function if it is listed in the map and is not done.  We first
compute the names that we are going to use and with this information we do
several transformations:
</p>
<ul class="org-ul">
<li>adding assignment declarations that index in such a way that all references
are similar to before transformation</li>
<li>transforming the parameters of the function, new names and new types</li>
<li>adding new indices after each transformed parameter</li>
<li>add dimension declarations that ensure that the types are going to be valid</li>
</ul>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-func</span> (func func-info funcs-done exports)
  (appendf funcs-done (<span style="color: #a020f0;">loop</span> for call in (called-by func)
                         when (<span style="color: #a020f0;">let</span> ((parent-func (get-func call)))
                                (transform-func
                                 parent-func func-info funcs-done exports))
                         append it into funcs-done
                         finally (<span style="color: #a020f0;">return</span> funcs-done)))
  (<span style="color: #a020f0;">let</span> ((spec (get-spec func)
         <span style="color: #b22222;">;;</span><span style="color: #b22222;">(gethash func func-info)</span>
          ))
    (<span style="color: #a020f0;">when</span> (and spec (not (member func funcs-done)))
      (<span style="color: #a020f0;">with-slots</span> (params called-by) func
        (<span style="color: #a020f0;">let*</span> ((params-to-transform (get-params-to-transform spec params))
               (names (get-names
                       params-to-transform
                       (compute-nr-dims params-to-transform spec)
                       func)))
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "doing ~a~%" func)</span>
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "  adding assign-decls:~%")</span>
          (add-assign-decls params-to-transform names func)
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "  transform-params:~%")</span>
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "    names: ~a~%" names)</span>
          (transform-params params-to-transform names func spec)
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "  add indices:~%")</span>
          (add-indices params-to-transform names)
          <span style="color: #b22222;">;;</span><span style="color: #b22222;">(format t "~{~a~%~}" (mapcar #'print-pretty:pp called-by))</span>
          <span style="color: #b22222;">;;</span><span style="color: #b22222;">(format t "going to do the dimension-decls now~%")</span>
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "  add dimension-decls:~%")</span>
          (add-dimension-decls func spec)
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "  transform-calls:~%")</span>
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "    spec: ~a~%" spec)</span>
          (set-cfgraphs:set-cfgraphs func)
          (set-parents:set-parents func)
          (transform-calls called-by spec exports)
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "  resolve-vars:~%")</span>
          (resolve-vars:resolve-vars func exports)
          <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "the func:~%~a~%" (print-pretty:pp func))</span>
          (list func))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-nr-dims</span> (params specs)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (param spec)
              (- (cdr spec) (get-nr-dims-decl param)))
          params specs))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-spec</span> (func)
  (<span style="color: #a020f0;">let</span> ((hashtable (make-hash-table)))
    (analyze-func func hashtable)
    (gethash func hashtable)))
</pre>
</div>

<p>
We add the first assignment declaration before the first statement in the
function, all others before the just inserted statement.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-assign-decls</span> (params names func)
  (<span style="color: #a020f0;">loop</span> for param in (reverse params)
       for name in (reverse names)
     for stat = (<span style="color: #a020f0;">let</span> ((first-stat (get-first-stat func)))
                  (add-assign-decl param name first-stat)
                  first-stat)
     then (add-assign-decl param name stat)))
</pre>
</div>

<p>
We create an assignment declaration using the modifiers from the original
declarations.  We create a new expression with the <code>from-caller</code> name and the
<code>index</code>.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-assign-decl</span> (param name stat)
  (<span style="color: #a020f0;">destructuring-bind</span> (from-caller <span style="color: #228b22;">&amp;rest</span> indices) name
    (<span style="color: #a020f0;">with-slots</span> (modifiers basic-decls) param
      (<span style="color: #a020f0;">let</span> ((bd (first basic-decls)))
        (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
          (<span style="color: #a020f0;">let</span> ((ds (make-decl-stat
                     (make-assign-decl
                      modifiers
                      (copy-ast bd)
                      (create-expr from-caller indices)))))
            (insert-before-ast stat ds)
            (setf (parent ds) (parent stat))
            ds))))))
</pre>
</div>

<p>
We add dimension declarations in front of the first parameters.  We first find
all the dimension variables and remove the duplicates using <code>union</code>.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-dimension-decls</span> (func spec)
  (<span style="color: #a020f0;">let</span> ((dim-vars (get-all-dim-vars func spec)))
    (<span style="color: #a020f0;">loop</span> for dv in dim-vars
       do (insert-before-ast (first (params func))
                             (create-dimension-decl dv)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-dimension-decl</span> (dim-var)
  (make-normal-decl (list (make-const))
                    (list (make-basic-decl (make-int)
                                           (make-id dim-var)))))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-all-dim-vars</span> (func spec)
  (reduce #'(<span style="color: #a020f0;">lambda</span> (result s)
              (<span style="color: #a020f0;">destructuring-bind</span> (position . dims-needed) s
                (union result
                       (find-dim-vars
                        position func dims-needed)
                       <span style="color: #483d8b;">:test</span> #'string=)))
          spec
          <span style="color: #483d8b;">:initial-value</span> nil))
</pre>
</div>

<p>
We add the indices after each parameters:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-indices</span> (params-to-transform names)
  (<span style="color: #a020f0;">loop</span>
     for param in params-to-transform
     for (from-caller . indices) in names
     do (insert-indices param indices)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-indices</span> (param indices)
  (<span style="color: #a020f0;">loop</span> for index in (reverse indices)
     do (insert-after-ast param (create-index-decl index))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-index-decl</span> (name)
  (make-normal-decl
   (list (make-const))
   (list (make-basic-decl (make-int) (make-id name)))))
</pre>
</div>

<p>
We transform the parameters themselves by changing the type and changing the
name:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-params</span> (params-to-transform names func spec)
  (<span style="color: #a020f0;">loop</span>
     for (position . dims-needed) in spec
     for param in params-to-transform
     for (from-caller . indices)  in names
     <span style="color: #b22222;">;; </span><span style="color: #b22222;">param and position have to be in congruence of course</span>
     do (<span style="color: #a020f0;">let</span> ((dim-vars (find-dim-vars position func dims-needed)))
          (replace-type param (compute-type param dims-needed dim-vars))
          (change-name-param param from-caller))))
</pre>
</div>

<p>
Replacing the type:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">replace-type</span> (decl type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">replace-type</span> ((d normal-decl) type)
  (replace-type (first (basic-decls d)) type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">replace-type</span> ((bd basic-decl) type)
  (replace-in-ast (mcl-type bd) <span style="color: #483d8b;">:with</span> type))
</pre>
</div>

<p>
Computing the new type:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-type</span> (param dims-needed dim-vars)
  (<span style="color: #a020f0;">let*</span> ((old-type (check-types::get-type param))
         (nr-dims-type (get-nr-dims-decl param))
         (nr-dims-to-add (max 0 (- dims-needed nr-dims-type))))
    (create-type old-type nr-dims-to-add dim-vars)))
</pre>
</div>

<p>
Create a type is done recursively:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-type</span> (type nr-dims-to-add dim-vars)
  (<span style="color: #a020f0;">if</span> (eql nr-dims-to-add 0)
      type
      (create-type
       (create-array-type type (first dim-vars))
       (1- nr-dims-to-add)
       (rest dim-vars))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-array-type</span> (base-type name)
  (make-array-type base-type (list (make-decl-array-size
                                    (make-var-expr
                                     (make-normal-var
                                      (make-basic-var (make-id name) nil)))
                                    nil))))
</pre>
</div>

<p>
Changing the name of a parameter:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">change-name-param</span> (decl name))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">change-name-param</span> ((d normal-decl) name)
  (change-name-param (first (basic-decls d)) name))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">change-name-param</span> ((bd basic-decl) name)
  (change-name-param (id bd) name))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">change-name-param</span> ((id id) name)
  (setf (name id) name))
</pre>
</div>


<p>
We transform calls by first gathering information, we then:
</p>
<ul class="org-ul">
<li>add index expressions to the call,</li>
<li>we transform the expressions in the call, and</li>
<li>add the dimension expressions to the call.</li>
</ul>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-calls</span> (calls specs exports)
  (<span style="color: #a020f0;">dolist</span> (call calls) (transform-call call specs))
  (<span style="color: #a020f0;">let</span> ((parent-funcs (remove-duplicates (mapcar #'get-func calls))))
    (<span style="color: #a020f0;">dolist</span> (func parent-funcs)
      (resolve-vars:resolve-vars func exports)
      (check-types:check-types func))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-call</span> (call specs)
  (<span style="color: #a020f0;">with-slots</span> (params) call
    (<span style="color: #a020f0;">let</span> ((params-to-transform (get-params-to-transform specs params))
          (info (get-transform-info params specs)))
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "transforming call ~a~%" call)</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "    info: ~a~%" info)</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "    add-index-exprs~%")</span>
      (add-index-exprs
       params-to-transform (mapcar #'second info))
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "    transform-param-exprs~%")</span>
      (transform-param-exprs
       params-to-transform
       (mapcar #'first info) (mapcar #'fourth info))
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "    add-dim-exprs~%")</span>
      (add-dim-exprs (first (params call))
                     (compute-dim-exprs (mapcar #'third info)))
      (set-parents:set-parents call))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-dim-exprs</span> (dim-exprs)
  (flatten (remove-duplicates dim-exprs <span style="color: #483d8b;">:test</span> #'ast=)))
</pre>
</div>

<p>
The transform information creates a list (for each parameter to transform one)
of three types of information:
</p>
<ul class="org-ul">
<li>the variable expression without <code>dims</code> index expressions</li>
<li><code>dims</code> index expressions</li>
<li>expressions that are required for the types</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-transform-info</span> (params specs)
  (<span style="color: #a020f0;">loop</span> for (position . dims-type) in specs
     collect (<span style="color: #a020f0;">let*</span> ((param (nth position params))
                    (dims-expr (get-nr-dims-expr param))
                    (dims (- dims-type dims-expr)))
               (<span style="color: #a020f0;">multiple-value-bind</span> (var-expr indices)
                   (split-param param dims)
                 <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "indices: ~a~%" indices)</span>
                 <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "dims: ~a, dims-type: ~a, dims-expr: ~a~%" dims dims-type dims-expr)</span>
                 <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "type-exprs: ~a~%" (find-type-exprs param dims))</span>
                 (<span style="color: #a020f0;">if</span> var-expr
                     (list var-expr indices (find-type-exprs param dims))
                     (list nil
                           (append
                            (<span style="color: #a020f0;">loop</span> for i below (- dims (length indices))
                               collect (list (make-int-constant 0)))
                            indices)
                           (append
                            (subseq (find-type-exprs param dims) (length indices))
                            (<span style="color: #a020f0;">loop</span> for i below (- dims (length indices))
                               collect (make-int-constant 1)))
                           (- dims (length indices))))))))
</pre>
</div>

<p>
The following functions retrieve the expressions that are necessary to fullfill
the types:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-type-exprs</span> (param dims)
  (<span style="color: #a020f0;">let*</span> ((type (check-types::get-type (get-decl-from-expr param)))
         (type-exprs (find-type-exprs-type type)))
    (reverse (mapcar #'size (subseq type-exprs 0 (min (length type-exprs) dims))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-type-exprs-with-nr-dims</span> (param dims wanted-nr-dims)
  (<span style="color: #a020f0;">let*</span> ((type (check-types::get-type (get-decl-from-expr param)))
         (type-exprs (find-type-exprs-type type)))
    (<span style="color: #a020f0;">when</span>  (eql (length type-exprs) wanted-nr-dims)
      (reverse (mapcar #'size (subseq type-exprs 0 dims))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-type-exprs-type</span> (type)
  (<span style="color: #a020f0;">if</span> (or (primitive-type-p type)
          (typep type 'custom-type))
      nil
      (<span style="color: #a020f0;">with-slots</span> (base-type sizes) type
        (<span style="color: #ff0000; font-weight: bold;">assert</span> (eql (length sizes) 1))
        (cons (first sizes) (find-type-exprs-type base-type)))))
</pre>
</div>

<p>
The following function adds an index expression after each parameter that needs
to be transformed.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun add-index-exprs (params indices dims)</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(loop</span>
<span style="color: #b22222;">;;      </span><span style="color: #b22222;">for p in params</span>
<span style="color: #b22222;">;;      </span><span style="color: #b22222;">for i in indices</span>
<span style="color: #b22222;">;;      </span><span style="color: #b22222;">do (let ((indices (if (null i) (create-zero-indices dims) i)))</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">       (insert-index-exprs p indices))))</span>

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-index-exprs</span> (params indices)
  (<span style="color: #a020f0;">loop</span>
     for p in params
     for i in indices
     do (insert-index-exprs p i)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-zero-indices</span> (dims)
  (<span style="color: #a020f0;">loop</span> for i below (length dims) collect (list (make-int-constant 0))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-index-exprs</span> (param indices)
  (<span style="color: #a020f0;">loop</span> for index in (mapcar #'first (reverse indices))
     do
       (insert-after-ast param index)
       (setf (parent index) (parent param))))
</pre>
</div>

<p>
The following function transforms the parameters.  Basically, the parameters
are replaced with parameters with less index expressions.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-param-exprs</span> (params-to-replace replacement-params counts)
  (<span style="color: #a020f0;">loop</span>
     for p-to-replace in params-to-replace
     for replacement-p in replacement-params
     for c in counts
     do (<span style="color: #a020f0;">if</span> replacement-p
            (replace-in-ast p-to-replace <span style="color: #483d8b;">:with</span> replacement-p)
            (create-with-dim-expr p-to-replace c))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-with-dim-expr</span> (param count)
  (<span style="color: #a020f0;">let*</span> ((decl (get-decl-param param))
         (func (get-func param))
         (basic-decl (get-basic-decl-param param))
         (name (create-with-dim-name basic-decl func)))
    (add-new-basic-decl decl basic-decl name count)
    (replace-in-ast param <span style="color: #483d8b;">:with</span> (create-var-expr name nil))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-with-dim-name</span> (basic-decl func)
  (ensure-name (format nil <span style="color: #8b2252;">"~aWithDim"</span> (name (id basic-decl)))
               func 'basic-decl))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">add-new-basic-decl</span> (decl old-basic-decl new-name count))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-new-basic-decl</span> ((decl normal-decl) old-basic-decl new-name count)
  (<span style="color: #a020f0;">with-slots</span> (basic-decls) decl
    (appendf basic-decls
             (list (create-new-basic-decl old-basic-decl new-name count)))
    (remove-duplicates basic-decls <span style="color: #483d8b;">:test</span> #'ast=)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-basic-decl</span> (old-basic-decl new-name count)
  (make-basic-decl (create-new-type old-basic-decl count) (make-id new-name)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-type</span> (old-basic-decl count)
  (<span style="color: #a020f0;">if</span> (eql count 0)
      (copy-ast (mcl-type old-basic-decl))
      (make-array-type
       (create-new-type old-basic-decl (1- count)) 
       (list (make-decl-array-size (make-int-constant 1) nil)))))
</pre>
</div>

<p>
We add dimension expressions at the start.  These dimension expressions are
necessary to express the dimensions of the types.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-dim-exprs</span> (ast dim-exprs)
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">(break)</span>
  (<span style="color: #a020f0;">loop</span>
     for de in dim-exprs
     for param = (<span style="color: #a020f0;">let</span> ((first-ast ast))
                   (insert-before-ast first-ast de)
                   (setf (parent de) (parent first-ast))
                   de)
     then (<span style="color: #a020f0;">progn</span> (insert-before-ast param de)
                 (setf (parent de) (parent param))
                 de)))
</pre>
</div>
</div>
</li>












<li><a id="orgf688854"></a><span class="todo TODO">TODO</span> Helper functions<br />
<div class="outline-text-6" id="text-orgf688854">
<p>
Retrieves the parameters that need to be transformed.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-params-to-transform</span> (spec params)
  (<span style="color: #a020f0;">loop</span> for (position . dims-needed) in spec collect (nth position params)))
</pre>
</div>

<p>
Create a list of new names:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-names</span> (params nr-indices func)
  (<span style="color: #a020f0;">loop</span> for p in params
       for index-count in nr-indices
     collect (cons (get-name-from-caller p func)
                   (get-names-indices p index-count func))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-names-indices</span> (decl nr-indices func)
  (<span style="color: #a020f0;">if</span> (eql nr-indices 1)
      (list (get-name-index decl func <span style="color: #8b2252;">""</span>))
      (<span style="color: #a020f0;">loop</span> for i below nr-indices collect (get-name-index decl func i))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-name-index</span> (decl ast count)
  (get-name decl ast (format nil <span style="color: #8b2252;">"Index~a"</span> count)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-name-from-caller</span> (decl ast)
  (get-name decl ast <span style="color: #8b2252;">"FromCaller"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-name</span> (decl ast suffix)
  (ensure-name
   (format nil <span style="color: #8b2252;">"~a~a"</span> (name (id (get-basic-decl decl))) suffix)
   ast 'basic-decl))
</pre>
</div>

<p>
Create expressions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-expr</span> (from-caller indices)
  (create-var-expr from-caller (mapcar #'(<span style="color: #a020f0;">lambda</span> (index)
                                           (list (create-var-expr index nil)))
                                       indices)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-var-expr</span> (name array-exprs)
  (make-var-expr
   (make-normal-var
    (make-basic-var (make-id name)
                    array-exprs))))
</pre>
</div>

<p>
Get the first stat from a function <b>Can move to a more generic place</b>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-first-stat</span> (func)
  (first (stats (code-block func))))
</pre>
</div>

<p>
Find the dimension variables from a func given a position.  We do this by
looking in the calls and get inspiration from these names.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-dim-vars</span> (position func dims-needed)
  (<span style="color: #a020f0;">with-slots</span> (called-by) func
    (<span style="color: #a020f0;">let</span> ((suggested-dim-vars
           (<span style="color: #a020f0;">loop</span> for call in called-by
              when (suggest-dim-vars position call dims-needed)
              collect it)))
      (first suggested-dim-vars))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">suggest-dim-vars</span> (position call dims-needed)
  (<span style="color: #a020f0;">with-slots</span> (params) call
    (<span style="color: #a020f0;">let*</span> ((param (nth position params))
           (dims-expr (get-nr-dims-expr param))
           (dims (- dims-needed dims-expr))
           (type-exprs (find-type-exprs-with-nr-dims param dims dims-needed)))
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "dims-expr: ~a, dims: ~a, dims-needed: ~a~%"</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">             dims-expr dims dims-needed)</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "type-exprs: ~a~%" type-exprs)</span>
      (<span style="color: #a020f0;">loop</span> for type-expr in type-exprs
           when (typep type-expr 'var-expr)
           collect (name (get-id (get-decl-var (var type-expr))))))))
</pre>
</div>

<p>
The following functions split a parameter and <code>nr-indices</code> of its index
expressions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">split-param</span> (param nr-indices))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">split-param</span> ((e var-expr) nr-indices)
  (<span style="color: #a020f0;">if</span> (eql nr-indices 0)
      (values e nil)
      (<span style="color: #a020f0;">multiple-value-bind</span> (var indices) (split-param (var e) nr-indices)
        (values (<span style="color: #a020f0;">if</span> (null var) nil (make-var-expr var)) indices))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">split-param</span> ((v normal-var) nr-indices)
  (<span style="color: #a020f0;">if</span> (eql nr-indices 0)
      (values v nil)
      (<span style="color: #a020f0;">multiple-value-bind</span> (bv indices) (split-param (basic-var v) nr-indices)
        (values (<span style="color: #a020f0;">if</span> (null bv) nil (make-normal-var bv)) indices))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">split-param</span> ((bv basic-var) nr-indices)
  (<span style="color: #a020f0;">if</span> (eql nr-indices 0)
      (values bv nil)
      (<span style="color: #a020f0;">with-slots</span> (id array-exprs) bv
        (<span style="color: #a020f0;">let*</span> ((nr-array-exprs (length array-exprs))
               (split-position (max (- nr-array-exprs nr-indices) 0))
               (new-array-exprs (subseq array-exprs split-position))
               (new-bv (make-basic-var id
                                       (subseq array-exprs 0 split-position)))
               (nr-new-array-exprs (length new-array-exprs)))
          (<span style="color: #a020f0;">if</span> (not (eql nr-new-array-exprs nr-indices))
              (<span style="color: #a020f0;">multiple-value-bind</span> (bv indices)
                  (get-alias-indices bv (get-decl-var bv)
                                     (- nr-indices nr-new-array-exprs))
                (values bv (append indices new-array-exprs)))
              (values new-bv new-array-exprs))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-alias-indices</span> (ast decl nr-indices)
  (<span style="color: #a020f0;">let</span> ((aliases (get-aliases-ast ast)))
    (<span style="color: #a020f0;">loop</span> for alias in aliases
       when (eq (alias alias) decl)
       do (<span style="color: #a020f0;">multiple-value-bind</span> (expr indices)
              (split-param (get-expr-alias alias) nr-indices)
            (<span style="color: #a020f0;">return</span> (values (basic-var (var expr)) indices))))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-expr-alias</span> (alias-bb-or-ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-alias</span> ((alias alias))
  (get-expr-alias (bb alias)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-alias</span> ((bb bb))
  (get-expr-alias (get-ast-basic-block bb)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-alias</span> ((as assign-stat))
  (expr as))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-alias</span> ((ds decl-stat))
  (get-expr-alias (decl ds)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-alias</span> ((d assign-decl))
  (expr d))
</pre>
</div>

<p>
Whether an AST form is a kernel function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kernel-func-p</span> (ast)
  (and (typep ast 'func)
       (move-foreach-to-func:kernel-func-p ast)))
</pre>
</div>


<p>
<b>The following functions should move to a better place</b>:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">can move to a more generic place.</span>
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">ensure-name</span> (name ast parent-type)
  (<span style="color: #a020f0;">loop</span>
     for attempt = name then (find-name attempt ast parent-type)
     until (string= attempt (find-name attempt ast parent-type))
     finally (<span style="color: #a020f0;">return</span> attempt)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-name</span> (name ast parent-type)
  (aif (collect-all ast #'(<span style="color: #a020f0;">lambda</span> (x) (and (typep x 'id)
                                       (string= (name x) name)
                                       (typep (parent x) parent-type))))
       (change-name (name (first it)))
       name))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">change-name</span> (name)
  (<span style="color: #a020f0;">multiple-value-bind</span> (name increment) (split-name name)
    (<span style="color: #a020f0;">if</span> increment
        (format nil <span style="color: #8b2252;">"~a~a"</span> name (1+ increment))
        (format nil <span style="color: #8b2252;">"~a0"</span> name))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">split-name</span> (name)
  (<span style="color: #a020f0;">multiple-value-bind</span> (start-increment end-increment)
      (cl-ppcre:scan <span style="color: #8b2252;">"[0-9]+"</span> name)
    (<span style="color: #a020f0;">if</span> (and end-increment
             (at-end end-increment name))
        (values (subseq name 0 start-increment)
                (<span style="color: #a020f0;">with-input-from-string</span> (in (subseq name start-increment))
                  (read in)))
        name)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">at-end</span> (index string)
  (eql index (length string)))
</pre>
</div>
</div>
</li>
</ul>
</div>



<div id="outline-container-org34e1251" class="outline-5">
<h5 id="org34e1251"><span class="section-number-5">7.3.11.3</span> Testing</h5>
<div class="outline-text-5" id="text-7-3-11-3">
</div>
<ul class="org-ul">
<li><a id="orgd3e8436"></a>The package<br />
<div class="outline-text-6" id="text-orgd3e8436">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-transform-tile-expressions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span>
        <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:resolve-types</span> <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:set-vars-written</span> <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:check-types</span>
        <span style="color: #483d8b;">:transform-tile-expressions</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-transform-tile-expressions</span>))
</pre>
</div>
</div>
</li>

<li><a id="orgcbaf931"></a>The tests<br />
<div class="outline-text-6" id="text-orgcbaf931">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite transform-tile-expressions <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite transform-tile-expressions)


(test simple
  (is
   (transform-ok (transform
                  <span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output,</span>
<span style="color: #8b2252;">     const float[h][w] input) {</span>
<span style="color: #8b2252;">   g(w, output[2], input[2]);</span>
<span style="color: #8b2252;"> }"</span>)
                 <span style="color: #8b2252;">"perfect void g(const int h, const int n, float[h][n] outputFromCaller, </span>
<span style="color: #8b2252;">     const int outputIndex, const float[h][n] inputFromCaller,</span>
<span style="color: #8b2252;">     const int inputIndex) {</span>
<span style="color: #8b2252;">   const float[n] input = inputFromCaller[inputIndex];</span>
<span style="color: #8b2252;">   float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output, const float[h][w] input) {</span>
<span style="color: #8b2252;">   g(h, w, output, 2, input, 2);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transform-ok (transform
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; n; i++) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output,</span>
<span style="color: #8b2252;">     const float[h][w] input) {</span>
<span style="color: #8b2252;">   g(w, output[2], input[2]);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; n; i++) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output,</span>
<span style="color: #8b2252;">     const float[h][w] input) {</span>
<span style="color: #8b2252;">   g(w, output[2], input[2]);</span>
<span style="color: #8b2252;"> }"</span>)))

(test multiple-dimensions
  (is
    (transform-ok (transform
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int d, const int h, const int w, float[d][h][w] output,</span>
<span style="color: #8b2252;">     const float[d][h][w] input) {</span>
<span style="color: #8b2252;">   g(w, output[2][3], input[2][3]);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void g(const int d, const int h, const int n, float[d][h][n] outputFromCaller, const int outputIndex0, const int outputIndex1, const float[d][h][n] inputFromCaller, const int inputIndex0, const int inputIndex1) {</span>
<span style="color: #8b2252;">    const float[n] input = inputFromCaller[inputIndex0][inputIndex1];</span>
<span style="color: #8b2252;">    float[n] output = outputFromCaller[outputIndex0][outputIndex1];</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input[i];</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void f(const int d, const int h, const int w, float[d][h][w] output, const float[d][h][w] input) {</span>
<span style="color: #8b2252;">    g(d, h, w, output, 2, 3, input, 2, 3);</span>
<span style="color: #8b2252;">}"</span>)))

(test indirect-tiling
  (is
    (transform-ok (transform
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output,</span>
<span style="color: #8b2252;">     const float[h][w] input) {</span>
<span style="color: #8b2252;">   float[w] output1d = output[2];</span>
<span style="color: #8b2252;">   float[w] input1d = input[2];</span>
<span style="color: #8b2252;">   g(w, output1d, input1d);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void g(const int h, const int n, float[h][n] outputFromCaller, </span>
<span style="color: #8b2252;">     const int outputIndex, const float[h][n] inputFromCaller,</span>
<span style="color: #8b2252;">     const int inputIndex) {</span>
<span style="color: #8b2252;">   const float[n] input = inputFromCaller[inputIndex];</span>
<span style="color: #8b2252;">   float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output, const float[h][w] input) {</span>
<span style="color: #8b2252;">   float[w] output1d = output[2];</span>
<span style="color: #8b2252;">   const float[w] input1d = input[2];</span>
<span style="color: #8b2252;">   g(h, w, output, 2, input, 2);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transform-ok (transform
<span style="color: #8b2252;">"perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int h, const int w, float[h][w] output,</span>
<span style="color: #8b2252;">     const float[h][w] input) {</span>
<span style="color: #8b2252;">   float[w] output1d = output[2];</span>
<span style="color: #8b2252;">   float[w] input1d = input[2];</span>
<span style="color: #8b2252;">   h(w, output1d, input1d);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int d, const int h, const int w, float[d][h][w] output,</span>
<span style="color: #8b2252;">     const float[d][h][w] input) {</span>
<span style="color: #8b2252;">   float[h][w] output2d = output[1];</span>
<span style="color: #8b2252;">   float[h][w] input2d = input[1];</span>
<span style="color: #8b2252;">   g(h, w, output2d, input2d);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void h(const int d, const int h, const int n, </span>
<span style="color: #8b2252;">     float[d][h][n] outputFromCaller, const int outputIndex0, </span>
<span style="color: #8b2252;">     const int outputIndex1, const float[d][h][n] inputFromCaller, </span>
<span style="color: #8b2252;">     const int inputIndex0, const int inputIndex1) {</span>
<span style="color: #8b2252;">   const float[n] input = inputFromCaller[inputIndex0][inputIndex1];</span>
<span style="color: #8b2252;">   float[n] output = outputFromCaller[outputIndex0][outputIndex1];</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;">perfect void g(const int d, const int h, const int w, float[d][h][w] outputFromCaller, const int outputIndex, const float[d][h][w] inputFromCaller, const int inputIndex) {</span>
<span style="color: #8b2252;">    const float[h][w] input = inputFromCaller[inputIndex];</span>
<span style="color: #8b2252;">    float[h][w] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">    float[w] output1d = output[2];</span>
<span style="color: #8b2252;">    const float[w] input1d = input[2];</span>
<span style="color: #8b2252;">    h(d, h, w, outputFromCaller, outputIndex, 2, inputFromCaller, inputIndex, 2);</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void f(const int d, const int h, const int w, float[d][h][w] output, const float[d][h][w] input) {</span>
<span style="color: #8b2252;">    float[h][w] output2d = output[1];</span>
<span style="color: #8b2252;">    const float[h][w] input2d = input[1];</span>
<span style="color: #8b2252;">    g(d, h, w, output, 1, input, 1);</span>
<span style="color: #8b2252;">}"</span>)))






(test deep-calls
  (is
    (transform-ok (transform
<span style="color: #8b2252;">"perfect void h(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   foreach (int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   h(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output, float[h][w] input) {</span>
<span style="color: #8b2252;">   g(w, output[2], input[2]);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void h(const int h, const int n, float[h][n] outputFromCaller, </span>
<span style="color: #8b2252;">     const int outputIndex, const float[h][n] inputFromCaller, </span>
<span style="color: #8b2252;">     const int inputIndex) {</span>
<span style="color: #8b2252;">   const float[n] input = inputFromCaller[inputIndex];</span>
<span style="color: #8b2252;">   float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int h, const int n, float[h][n] outputFromCaller,</span>
<span style="color: #8b2252;">     const int outputIndex, const float[h][n] inputFromCaller, </span>
<span style="color: #8b2252;">     const int inputIndex) {</span>
<span style="color: #8b2252;">   const float[n] input = inputFromCaller[inputIndex];</span>
<span style="color: #8b2252;">   float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">   h(h, n, outputFromCaller, outputIndex, inputFromCaller, inputIndex);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output,</span>
<span style="color: #8b2252;">     const float[h][w] input) {</span>
<span style="color: #8b2252;">   g(h, w, output, 2, input, 2);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transform-ok (transform
<span style="color: #8b2252;">"perfect void h(const int n, float[n] output, float[n] input1,</span>
<span style="color: #8b2252;">     float[n] input2) {</span>
<span style="color: #8b2252;">   foreach (int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input1[i] + input2[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input1) {</span>
<span style="color: #8b2252;">   float[n] input2;</span>
<span style="color: #8b2252;">   h(n, output, input2, input1);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output, float[h][w] input) {</span>
<span style="color: #8b2252;">   g(w, output[2], input[2]);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void h(const int h, const int n, float[h][n] outputFromCaller, const int outputIndex, const float[n] input1, const float[h][n] input2FromCaller, const int input2Index) {</span>
<span style="color: #8b2252;">    const float[n] input2 = input2FromCaller[input2Index];</span>
<span style="color: #8b2252;">    float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input1[i] + input2[i];</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void g(const int h, const int n, float[h][n] outputFromCaller, const int outputIndex, const float[h][n] input1FromCaller, const int input1Index) {</span>
<span style="color: #8b2252;">    const float[n] input1 = input1FromCaller[input1Index];</span>
<span style="color: #8b2252;">    float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">    const float[n] input2;</span>
<span style="color: #8b2252;">    h(h, n, outputFromCaller, outputIndex, input2, input1FromCaller, input1Index);</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void f(const int h, const int w, float[h][w] output, const float[h][w] input) {</span>
<span style="color: #8b2252;">    g(h, w, output, 2, input, 2);</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;">"</span>)))

</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(test mixed-simple
  (is
    (transform-ok (transform
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output2d, </span>
<span style="color: #8b2252;">     float[h][w] input2d, float[w] output1d, float[w] input1d) {</span>
<span style="color: #8b2252;">   g(w, output2d[2], input2d[2]);</span>
<span style="color: #8b2252;">   g(w, output1d, input1d);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void g(const int h, const int n, float[h][n] outputFromCaller, </span>
<span style="color: #8b2252;">     const int outputIndex, const float[h][n] inputFromCaller,</span>
<span style="color: #8b2252;">     const int inputIndex) {</span>
<span style="color: #8b2252;">   const float[n] input = inputFromCaller[inputIndex];</span>
<span style="color: #8b2252;">   float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output2d, </span>
<span style="color: #8b2252;">     const float[h][w] input2d, float[w] output1d as float[1][w] output1dWithDim,</span>
<span style="color: #8b2252;">     const float[w] input1d as float[1][w] input1dWithDim) {</span>
<span style="color: #8b2252;">   g(h, w, output2d, 2, input2d, 2);</span>
<span style="color: #8b2252;">   g(1, w, output1dWithDim, 0, input1dWithDim, 0);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transform-ok (transform
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   foreach (int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, const int d, </span>
<span style="color: #8b2252;">     float[d][h][w] output3d, float[d][h][w] input3d,</span>
<span style="color: #8b2252;">     float[w] output1d, float[w] input1d) {</span>
<span style="color: #8b2252;">   g(w, output3d[2][3], input3d[2][3]);</span>
<span style="color: #8b2252;">   g(w, output1d, input1d);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void g(const int d, const int h, const int n, </span>
<span style="color: #8b2252;">     float[d][h][n] outputFromCaller, const int outputIndex0, </span>
<span style="color: #8b2252;">     const int outputIndex1, </span>
<span style="color: #8b2252;">     const float[d][h][n] inputFromCaller, const int inputIndex0, </span>
<span style="color: #8b2252;">     const int inputIndex1) {</span>
<span style="color: #8b2252;">    const float[n] input = inputFromCaller[inputIndex0][inputIndex1];</span>
<span style="color: #8b2252;">    float[n] output = outputFromCaller[outputIndex0][outputIndex1];</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input[i];</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void f(const int h, const int w, const int d, float[d][h][w] output3d,</span>
<span style="color: #8b2252;">     const float[d][h][w] input3d, float[w] output1d as </span>
<span style="color: #8b2252;">     float[1][1][w] output1dWithDim, const float[w] input1d as </span>
<span style="color: #8b2252;">     float[1][1][w] input1dWithDim) {</span>
<span style="color: #8b2252;">    g(d, h, w, output3d, 2, 3, input3d, 2, 3);</span>
<span style="color: #8b2252;">    g(1, 1, w, output1dWithDim, 0, 0, input1dWithDim, 0, 0);</span>
<span style="color: #8b2252;">}"</span>))
  (is (transform-ok (transform
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   foreach (int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, const int d, </span>
<span style="color: #8b2252;">     float[d][h][w] output3d, float[d][h][w] input3d,</span>
<span style="color: #8b2252;">     float[h][w] output2d, float[h][w] input2d) {</span>
<span style="color: #8b2252;">   g(w, output3d[2][3], input3d[2][3]);</span>
<span style="color: #8b2252;">   g(w, output2d[2], input2d[2]);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void g(const int d, const int h, const int n, float[d][h][n] outputFromCaller, const int outputIndex0, const int outputIndex1, const float[d][h][n] inputFromCaller, const int inputIndex0, const int inputIndex1) {</span>
<span style="color: #8b2252;">    const float[n] input = inputFromCaller[inputIndex0][inputIndex1];</span>
<span style="color: #8b2252;">    float[n] output = outputFromCaller[outputIndex0][outputIndex1];</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input[i];</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void f(const int h, const int w, const int d, float[d][h][w] output3d, const float[d][h][w] input3d, float[h][w] output2d as float[1][h][w] output2dWithDim, const float[h][w] input2d as float[1][h][w] input2dWithDim) {</span>
<span style="color: #8b2252;">    g(d, h, w, output3d, 2, 3, input3d, 2, 3);</span>
<span style="color: #8b2252;">    g(1, h, w, output2dWithDim, 0, 2, input2dWithDim, 0, 2);</span>
<span style="color: #8b2252;">}"</span>))
  (is (transform-ok (transform
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   foreach (int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, const int d, </span>
<span style="color: #8b2252;">     float[d][h][w] output3d, float[d][h][w] input3d,</span>
<span style="color: #8b2252;">     float[h][w] output2d, float[h][w] input2d,</span>
<span style="color: #8b2252;">     float[w] output1d, float[w] input1d) {</span>
<span style="color: #8b2252;">   g(w, output3d[2][3], input3d[2][3]);</span>
<span style="color: #8b2252;">   g(w, output2d[2], input2d[2]);</span>
<span style="color: #8b2252;">   g(w, output1d, input1d);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void g(const int h, const int n, float[h][n] outputFromCaller, </span>
<span style="color: #8b2252;">     const int outputIndex, float[h][n] inputFromCaller, const int inputIndex) {</span>
<span style="color: #8b2252;">   float[n] output = outputFromCaller[outputIndex];</span>
<span style="color: #8b2252;">   float[n] input = inputFromCaller[inputIndex];</span>
<span style="color: #8b2252;">   foreach (int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output2d, </span>
<span style="color: #8b2252;">   float[h][w] input2d, float[1][w] output1d, float[1][w] input1d) {</span>
<span style="color: #8b2252;">   g(h, w, output, 2, input, 2);</span>
<span style="color: #8b2252;">   g(1, w, output, 0, input, 0);</span>
<span style="color: #8b2252;"> }"</span>)))


(test mixed-deep
  (is
    (transform-ok (transform
<span style="color: #8b2252;">"perfect void h(const int n, float[n] output, float[n] input1,</span>
<span style="color: #8b2252;">     float[n] input2) {</span>
<span style="color: #8b2252;">   foreach (int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input1[i] + input2[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input1) {</span>
<span style="color: #8b2252;">   float[n] input2;</span>
<span style="color: #8b2252;">   h(n, output, input2, input1);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(const int h, const int w, float[h][w] output2d, </span>
<span style="color: #8b2252;">     float[h][w] input2d) {</span>
<span style="color: #8b2252;">   float[w] output1d;</span>
<span style="color: #8b2252;">   float[w] input1d;</span>
<span style="color: #8b2252;">   g(w, output2d[2], input1d);</span>
<span style="color: #8b2252;">   g(w, output1d, input2d[2]);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void h(const int h, consto int n, float[n] output, const float[n] input1, const float[h][n] input2FromCaller, const int input2Index) {</span>
<span style="color: #8b2252;">    const float[n] input2 = input2FromCaller[input2Index];</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input1[i] + input2[i];</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void g(const int h, const int n, float[n] output, const float[h][n] input1FromCaller, const int input1Index) {</span>
<span style="color: #8b2252;">    const float[n] input1 = input1FromCaller[input1Index];</span>
<span style="color: #8b2252;">    const float[n] input2;</span>
<span style="color: #8b2252;">    h(h, n, output, input2, input1FromCaller, input1Index);</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">perfect void f(const int h, const int w, const float[h][w] output2d, const float[h][w] input2d) {</span>
<span style="color: #8b2252;">    float[w] output1d as float[1][w] output1dWithDim;</span>
<span style="color: #8b2252;">    const float[w] input1d as float[1][w] input1dWithDim;</span>
<span style="color: #8b2252;">    g(h, w, output2d, 2, input1dWithDim, 0);</span>
<span style="color: #8b2252;">    g(1, w, output1dWithDim, 0, input2d, 2);</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="org43ff274"></a>Helper functions<br />
<div class="outline-text-6" id="text-org43ff274">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform</span> (input-string)
  (<span style="color: #a020f0;">let*</span> ((module (string-&gt;ast input-string))
         (exports (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (set-parents module)
    (resolve-calls module exports)
    (<span style="color: #a020f0;">let</span> ((callgraph (set-callgraph (funcs (code module)))))
      (resolve-types module exports)
      (resolve-vars module exports)
      (check-types module)
      (set-cfgraphs module)
      (set-vars-written callgraph)
      (transform-tile-expressions module exports)
      module)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transform-ok</span> (transformed-ast input-string-result-ast)
  (ast= transformed-ast (string-&gt;ast input-string-result-ast)))


(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*module-template*</span>
<span style="color: #8b2252;">"package a;</span>
<span style="color: #8b2252;"> module a;</span>
<span style="color: #8b2252;"> import perfect;</span>

<span style="color: #8b2252;"> ~a</span>
<span style="color: #8b2252;">"</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">string-&gt;ast</span> (input-string)
  (parse-mcpl (format nil *module-template* input-string)))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgaf0812d" class="outline-4">
<h4 id="orgaf0812d"><span class="section-number-4">7.3.12</span> simplify expressions</h4>
<div class="outline-text-4" id="text-7-3-12">
</div>
<div id="outline-container-org5606be2" class="outline-5">
<h5 id="org5606be2"><span class="section-number-5">7.3.12.1</span> The package</h5>
<div class="outline-text-5" id="text-7-3-12-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:simplify-expressions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:print-pretty</span> <span style="color: #483d8b;">:parse-mcpl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:simplify</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d54f42" class="outline-5">
<h5 id="org6d54f42"><span class="section-number-5">7.3.12.2</span> Simplifying expressions</h5>
<div class="outline-text-5" id="text-7-3-12-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">simplify</span> (ast)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Simplify an AST form."</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">maxima-simplify</span> (expr-string)
  (maxima::$printf nil <span style="color: #8b2252;">"~a"</span>
                   (maxima::simplify (maxima::$parse_string expr-string))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">maxima-equal-expr-p</span> (expr-string-1 expr-string-2)
  (<span style="color: #a020f0;">let</span> ((result (maxima::$eval_string
                 (format nil <span style="color: #8b2252;">"is (equal (~a, ~a))"</span> expr-string-1 expr-string-2))))
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">The result can be t, maxima::unknown or nil</span>
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">For example, whether x^2 and 2*x are equal depends on the value of x</span>
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">In case the result is unknown, we consider it to be false</span>
    (<span style="color: #a020f0;">if</span> (eq result t)
        t
        nil)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">simplify</span> ((expr expr))
  (parse-mcpl-expr (format nil <span style="color: #8b2252;">"~a"</span> (maxima-simplify (pp expr)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">simplify</span> ((type mcl-type))
  type)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">simplify</span> ((ct custom-type))
  (<span style="color: #a020f0;">with-slots</span> (id params) ct
    (make-custom-type id (<span style="color: #a020f0;">loop</span> for p in params collect (simplify p)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">simplify</span> ((at array-type))
  (<span style="color: #a020f0;">with-slots</span> (base-type sizes) at
    (make-array-type (simplify base-type) (<span style="color: #a020f0;">loop</span> for s in sizes collect (simplify s)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">simplify</span> ((das decl-array-size))
  (<span style="color: #a020f0;">with-slots</span> (size decl) das
    (make-decl-array-size (simplify size) decl)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf483a31" class="outline-5">
<h5 id="orgf483a31"><span class="section-number-5">7.3.12.3</span> Testing the expressions library</h5>
<div class="outline-text-5" id="text-7-3-12-3">
</div>
<ul class="org-ul">
<li><a id="org3c8e0bb"></a>The package<br />
<div class="outline-text-6" id="text-org3c8e0bb">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-simplify-expressions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:simplify-expressions</span> <span style="color: #483d8b;">:print-pretty</span> <span style="color: #483d8b;">:parse-mcpl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-simplify-expressions</span>))
</pre>
</div>
</div>
</li>

<li><a id="orga167f69"></a>The test functions<br />
<div class="outline-text-6" id="text-orga167f69">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite simplify-expressions <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite simplify-expressions)

(test simplify-expressions
  (is (expr= <span style="color: #8b2252;">"a + 0"</span> <span style="color: #8b2252;">"a"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="org1832e69"></a>Utility functions<br />
<div class="outline-text-6" id="text-org1832e69">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">expr=</span> (expr simplified-expr)
  (string= (pp (simplify (parse-mcpl-expr expr))) simplified-expr))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd9da4f3" class="outline-3">
<h3 id="orgd9da4f3"><span class="section-number-3">7.4</span> Translating between abstraction levels</h3>
<div class="outline-text-3" id="text-7-4">
</div>
<div id="outline-container-org77a47dc" class="outline-4">
<h4 id="org77a47dc"><span class="section-number-4">7.4.1</span> The package</h4>
<div class="outline-text-4" id="text-7-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:translate</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-log</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:ast-mcpl</span>
        <span style="color: #483d8b;">:ast-hdl</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:parse-hdl</span> <span style="color: #483d8b;">:hardware-descriptions</span> <span style="color: #483d8b;">:set-parents</span>
        <span style="color: #483d8b;">:resolve-vars</span> <span style="color: #483d8b;">:set-vars-written</span> <span style="color: #483d8b;">:set-cfgraphs</span>
        <span style="color: #483d8b;">:load-hardware-descriptions</span> <span style="color: #483d8b;">:query-hdl-mcpl</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:ast-hdl</span> <span style="color: #483d8b;">:id</span> <span style="color: #483d8b;">:compound-id</span> <span style="color: #483d8b;">:left</span> <span style="color: #483d8b;">:right</span> <span style="color: #483d8b;">:expr</span> <span style="color: #483d8b;">:make-add</span>
                          <span style="color: #483d8b;">:make-sub</span> <span style="color: #483d8b;">:make-mul</span> <span style="color: #483d8b;">:make-div</span> <span style="color: #483d8b;">:add</span> <span style="color: #483d8b;">:sub</span> <span style="color: #483d8b;">:div</span> <span style="color: #483d8b;">:mul</span>
                          <span style="color: #483d8b;">:make-id</span> <span style="color: #483d8b;">:make-compound-id</span> <span style="color: #483d8b;">:name</span> <span style="color: #483d8b;">:compound</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:last-elt</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:def-standard-class</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:shadow</span> <span style="color: #483d8b;">:get-memory-spaces</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:translate</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org973c4b7" class="outline-4">
<h4 id="org973c4b7"><span class="section-number-4">7.4.2</span> The translation functions</h4>
<div class="outline-text-4" id="text-7-4-2">
</div>

<div id="outline-container-orgd19084b" class="outline-5">
<h5 id="orgd19084b"><span class="section-number-5">7.4.2.1</span> toplevel</h5>
<div class="outline-text-5" id="text-7-4-2-1">
<p>
Translating a module to a target is done by finding a path from hardware
description <code>perfect</code> to the target hardware description and then translating
each function to this target.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate</span> (modules callgraph target exports)
  <span style="color: #8b2252;">"Translate the modules and the functions of the callgraph to </span>
<span style="color: #8b2252;">hardware-description target."</span>
  (log-micro-pass <span style="color: #8b2252;">"translate"</span> callgraph)
  (translate-callgraph callgraph target exports)
  (translate-modules modules target exports))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-callgraph</span> (callgraph target exports)
  (<span style="color: #a020f0;">let</span> ((path (find-path <span style="color: #8b2252;">"perfect"</span> target))
        (fs (reverse (funcs-ordered callgraph))))
    (<span style="color: #a020f0;">dolist</span> (f fs)
      (translate-function-over-path f path exports))))
</pre>
</div>

<p>
When we translate functions, we perform a <code>resolve-vars</code> and ignore unresolved
variable errors.  However, this means that global values will not be resolved
in the final code.  We therefore, need to perform <code>resolve-vars</code> again on the
whole module.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-modules</span> (modules target exports)
  (<span style="color: #a020f0;">dolist</span> (module modules)
    (nconc (imports module)
           (list (make-lib-import (ast-mcpl:make-id target))))
    (set-parents module)
    (resolve-vars module exports)
    (set-cfgraphs module)))
</pre>
</div>

<p>
Finding the path from <code>perfect</code> to a target is done in the following way:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-path</span> (start end)
  (reverse (find-path-2 start end)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-path-2</span> (start end)
  (<span style="color: #a020f0;">if</span> (string= start end)
      (list (load-hardware-description start))
      (cons (load-hardware-description end)
            (find-path-2 start (get-parent-hardware-description end)))))

</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:translate</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-function-over-path</span> (f path exports)
  (<span style="color: #a020f0;">loop</span> for i from 0 below (1- (length path))
     do (<span style="color: #a020f0;">let</span> ((current-hwd (elt path i))
              (next-hwd (elt path (1+ i))))
          (<span style="color: #a020f0;">when</span> (string= (name (id current-hwd)) (ast-mcpl:name (hw-desc f)))
            (translate-function f current-hwd next-hwd exports)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">skip</span> (condition)
  (<span style="color: #a020f0;">declare</span> (ignore condition))
  (invoke-restart 'skip))
</pre>
</div>

<p>
The function <code>translate-function</code> translates all statements.  Afterwards it
performs a <code>resolve-vars</code> on the function to make sure that the next
translations can find all the memory spaces of the variables.  However, since
<code>resolve-vars</code> is performed on the function <code>f</code> instead of the whole module, it
will not be able to find global variables or exported variables.  Therefore,
the <code>underclared-var-error</code> is ignored.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-function</span> (f hwd-from hwd-to exports)
  (log-message <span style="color: #483d8b;">:translate</span> <span style="color: #8b2252;">"translating ~a to ~a"</span> (ast-mcpl:name (ast-mcpl:id f))
               (name (id hwd-to)))
  (<span style="color: #a020f0;">let</span> ((name-hwd-to (name (id hwd-to)))
        (par-group-mapping 
         (find-equivalent-par-groups 
          (create-initial-par-group-mapping hwd-from hwd-to) hwd-from hwd-to)))
    (translate-declarations f par-group-mapping)
    (translate-barriers f par-group-mapping)
    (translate-foreach-stats f par-group-mapping name-hwd-to)
    (setf (ast-mcpl:name (ast-mcpl:hw-desc f)) name-hwd-to)
    (set-parents f)
    (<span style="color: #a020f0;">handler-bind</span> ((errors:undeclared-var-error #'(<span style="color: #a020f0;">lambda</span> (c)
                                                    (<span style="color: #a020f0;">declare</span> (ignore c))
                                                    (invoke-restart 'skip))))
      (resolve-vars f exports))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0cd3c63" class="outline-4">
<h4 id="org0cd3c63"><span class="section-number-4">7.4.3</span> Equivalence</h4>
<div class="outline-text-4" id="text-7-4-3">
<p>
In this section we discuss the equivalence between parallelism groups or
par-groups.  
</p>
</div>

<div id="outline-container-org08cacb9" class="outline-5">
<h5 id="org08cacb9"><span class="section-number-5">7.4.3.1</span> data-types</h5>
<div class="outline-text-5" id="text-7-4-3-1">
<p>
First, we set up several datatypes to properly define the equivalence or the
mapping between par-groups:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-standard-class memory-space () (name read-only-p default-p))
(def-standard-class par-group () (memory-spaces))
(def-standard-class parallelism (par-group) ())
(def-standard-class sub-par-group  (par-group)
  (name par-unit nr-units max-nr-units))
(def-standard-class par-unit () (name memory-spaces))
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">tuple</span> () 
  ((from <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:from</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply from."</span>) <span style="color: #483d8b;">:accessor</span> from)
   (to <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:to</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply to."</span>) <span style="color: #483d8b;">:accessor</span> to)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-tuple</span> (from to)
  (make-instance 'tuple <span style="color: #483d8b;">:from</span> from <span style="color: #483d8b;">:to</span> to))
</pre>
</div>
</div>
</div>

<div id="outline-container-org18d6a36" class="outline-5">
<h5 id="org18d6a36"><span class="section-number-5">7.4.3.2</span> initial par-group-mapping</h5>
<div class="outline-text-5" id="text-7-4-3-2">
<p>
Before we can find the equivalent par-groups, we have to set up an initial
mapping.  In this function we find the executing par-units, and the par-groups
in which they are defined. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-initial-par-group-mapping</span> (hwd-from hwd-to)
  (<span style="color: #a020f0;">let*</span> ((executing-par-unit-from-block
          (retrieve-all hwd-from (block-with-name
                              (get-executing-par-unit hwd-from))))
         (executing-par-unit-to-block
          (retrieve-all hwd-to (block-with-name
                            (get-executing-par-unit hwd-to))))
         (par-group-from-block (parent executing-par-unit-from-block))
         (par-group-to-block (parent executing-par-unit-to-block)))
    (<span style="color: #a020f0;">let*</span> ((par-unit-from
            (create-par-unit executing-par-unit-from-block))
           (par-unit-to
            (create-par-unit executing-par-unit-to-block))
           (par-group-from
            (create-par-group par-unit-from par-group-from-block))
           (par-group-to
            (create-par-group par-unit-to par-group-to-block)))
      (list (make-tuple par-group-from (list par-group-to))))))
</pre>
</div>

<p>
Creating a par-unit is done as follows:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-par-unit</span> (par-unit-block)
  (make-instance 'par-unit
                 <span style="color: #483d8b;">:name</span> (name (id par-unit-block))
                 <span style="color: #483d8b;">:memory-spaces</span> (create-memory-spaces par-unit-block)))
</pre>
</div>

<p>
Creating memory spaces can be done from par-units or par-group blocks:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-memory-spaces</span> (par-block)
  (<span style="color: #a020f0;">let</span> ((memory-spaces
         (collect par-block (block-with-type <span style="color: #8b2252;">"memory_space"</span>))))
    (mapcar #'create-memory-space memory-spaces)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-memory-space</span> (memory-space-block)
  (make-instance 'memory-space
                 <span style="color: #483d8b;">:name</span> (name (id memory-space-block))
                 <span style="color: #483d8b;">:read-only-p</span> (retrieve-all memory-space-block
                                        (property-with-name <span style="color: #8b2252;">"read-only"</span>))
                 <span style="color: #483d8b;">:default-p</span> (retrieve-all memory-space-block
                                      (property-with-name <span style="color: #8b2252;">"default"</span>))))
</pre>
</div>

<p>
Creating a par-group is done as follows:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-par-group</span> (par-unit par-group-block)
  (<span style="color: #a020f0;">let</span> ((type (hdl-block-type par-group-block))
        (memory-spaces (create-memory-spaces par-group-block)))
    (<span style="color: #a020f0;">if</span> (string= <span style="color: #8b2252;">"parallelism"</span> type)
        (make-instance 'parallelism
                       <span style="color: #483d8b;">:memory-spaces</span> memory-spaces)
        (make-instance 'sub-par-group
                       <span style="color: #483d8b;">:name</span> (name (id par-group-block))
                       <span style="color: #483d8b;">:par-unit</span> par-unit
                       <span style="color: #483d8b;">:nr-units</span> (get-nr-units par-group-block)
                       <span style="color: #483d8b;">:max-nr-units</span> (get-nr-units par-group-block <span style="color: #8b2252;">"max"</span>)
                       <span style="color: #483d8b;">:memory-spaces</span> memory-spaces))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org48d11c8" class="outline-5">
<h5 id="org48d11c8"><span class="section-number-5">7.4.3.3</span> Finding equivalence</h5>
<div class="outline-text-5" id="text-7-4-3-3">
<p>
Finding equivalence starts with the initial par-group-mapping with the
par-groups with the executing par-units.  It starts analyzing the first tuple
in the par-group-mapping.  The stop-condition verifies whether both par-groups
are of type <code>parallelism</code>.  Otherwise, we continue with retrieving the parent
par-groups and continue with them.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-equivalent-par-groups</span> (par-group-mapping hwd-from hwd-to)
  (<span style="color: #a020f0;">let</span> ((pg-from (from (first par-group-mapping)))
        (pgs-to (to (first par-group-mapping))))
    (<span style="color: #a020f0;">cond</span> ((and (typep pg-from 'parallelism)
                (typep (first pgs-to) 'parallelism))
           par-group-mapping)
          ((or (typep pg-from 'parallelism)
               (typep (first pgs-to) 'parallelism))
           (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not equivalent ~a, ~a"</span> pg-from (first pgs-to)))
          (t
           (<span style="color: #a020f0;">let</span> ((parent-from (get-parent-par-group pg-from hwd-from))
                 (parent-to (get-parent-par-group (first pgs-to) hwd-to)))
             (add-parents-to-mapping par-group-mapping
                                     parent-from parent-to
                                     hwd-from hwd-to))))))
</pre>
</div>

<p>
If the size of the parallelism groups are equal, we add a tuple with
<code>parent-from</code> and a list of <code>parent-to</code>.  If the size of <code>pg-from</code> is greater,
then there are two cases: If the type of <code>parent-to</code> is <code>parallelism</code>, we are
done and we add a new tuple to the par-group-mapping.  Otherwise, we add
<code>parent-to</code> to the list of par-groups in the <code>to</code> part of the tuple.  We
continue to find equivalent par-groups with this mapping.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-parents-to-mapping</span> (par-group-mapping parent-from parent-to
                               hwd-from hwd-to)
  (<span style="color: #a020f0;">let</span> ((pg-from (from (first par-group-mapping)))
        (pgs-to (to (first par-group-mapping))))
    (<span style="color: #a020f0;">cond</span> ((equals-size pg-from pgs-to)
           (find-equivalent-par-groups
            (cons (make-tuple parent-from (list parent-to)) par-group-mapping)
            hwd-from
            hwd-to))
          ((less-size pg-from pgs-to)
           (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"from less than to"</span>))
          ((greater-size pg-from pgs-to)
           (<span style="color: #a020f0;">if</span> (typep parent-to 'parallelism)
               (push (make-tuple parent-from (list parent-to))
                     par-group-mapping)
               (push parent-to (to (first par-group-mapping))))
           (find-equivalent-par-groups par-group-mapping hwd-from hwd-to)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1963876" class="outline-5">
<h5 id="org1963876"><span class="section-number-5">7.4.3.4</span> Retrieving the parent par-groups</h5>
<div class="outline-text-5" id="text-7-4-3-4">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-parent-par-group</span> (par-group hwd))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-parent-par-group</span> ((par-group sub-par-group) hwd)
  (<span style="color: #a020f0;">let*</span> ((par-group-block (retrieve-all hwd (block-with-name (name par-group))))
         (parent-block (parent par-group-block)))
    (<span style="color: #a020f0;">if</span> (string= (hdl-block-type parent-block) <span style="color: #8b2252;">"parallelism"</span>)
        (make-instance 'parallelism
                       <span style="color: #483d8b;">:memory-spaces</span> (create-memory-spaces parent-block))
        (<span style="color: #a020f0;">let</span> ((parent-par-group-block (parent parent-block))
              (par-unit (create-par-unit parent-block)))
          (create-par-group par-unit parent-par-group-block)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org328a227" class="outline-5">
<h5 id="org328a227"><span class="section-number-5">7.4.3.5</span> Comparing the size of par-groups</h5>
<div class="outline-text-5" id="text-7-4-3-5">
<p>
The following functions compare the size of the par-groups.  Checking for
equality:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">equals-size</span> (par-groups-l par-groups-r))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">equals-size</span> ((l par-group) (r list))
  (equals-size (list l) r))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">equals-size</span> ((l list) (r list))
  (ast= (get-size l) (get-size r)))
</pre>
</div>

<p>
Less than comparison:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">less-size</span> (par-groups-l par-groups-r))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">less-size</span> ((l par-group) (r list))
  (less-size (list l) r))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">less-size</span> ((l list) (r list))
  (<span style="color: #a020f0;">let</span> ((size-l (get-size l))
        (size-r (get-size r)))
    (<span style="color: #a020f0;">cond</span> ((typep size-l 'unlimited-literal)
           nil)
          ((typep size-r 'unlimited-literal)
           t)
          (t
           (&lt; (value size-l) (value size-r))))))
</pre>
</div>

<p>
Greater than comparison:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">greater-size</span> (par-groups-l par-groups-r))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">greater-size</span> ((l par-group) (r list))
  (greater-size (list l) r))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">greater-size</span> ((l list) (r list))
  (<span style="color: #a020f0;">let</span> ((size-l (get-size l))
        (size-r (get-size r)))
    (<span style="color: #a020f0;">cond</span> ((typep size-r 'unlimited-literal)
           nil)
          ((typep size-l 'unlimited-literal)
           t)
          (t
           (&gt; (value size-l) (value size-r))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcde4d13" class="outline-5">
<h5 id="orgcde4d13"><span class="section-number-5">7.4.3.6</span> Computing the size of par-groups</h5>
<div class="outline-text-5" id="text-7-4-3-6">
<p>
Computing the size uses a multiply.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-size</span> (par-groups)
  (reduce #'multiply par-groups <span style="color: #483d8b;">:initial-value</span> (make-int-literal 1)))
</pre>
</div>

<p>
This special multiply is aware of the constant <code>unlimited</code>.  Everything times
unlimited is always unlimited.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">multiply</span> (l r))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">multiply</span> ((l int-literal) (r sub-par-group))
  (multiply l (nr-units r)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">multiply</span> ((l int-literal) (r unit-expr))
  (multiply l (expr r)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">multiply</span> ((l int-literal) (r int-literal))
  (make-int-literal (* (value l) (value r))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">multiply</span> ((l int-literal) (r unlimited-literal))
  r)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org3aeaeab" class="outline-4">
<h4 id="org3aeaeab"><span class="section-number-4">7.4.4</span> Translating memory spaces</h4>
<div class="outline-text-4" id="text-7-4-4">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-barriers</span> (function par-group-mapping)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (b) (translate-barrier b par-group-mapping))
          (collect-all function #'(<span style="color: #a020f0;">lambda</span> (x) (typep x 'barrier-stat)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-barrier</span> (barrier par-group-mapping)
  (<span style="color: #a020f0;">with-slots</span> (mem-space) barrier
    (<span style="color: #a020f0;">let</span> ((ms-to (find-equivalent-memory-space
                  (get-memory-space
                   (ast-mcpl:name mem-space)
                   par-group-mapping)
                  par-group-mapping)))
      (setf (ast-mcpl:name mem-space) (ast-hdl:name ms-to)))))



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-declarations</span> (function par-group-mapping)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (d) (translate-decl d par-group-mapping))
          (collect-all function #'(<span style="color: #a020f0;">lambda</span> (x) (typep x 'decl)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-decl</span> (decl par-group-mapping)
  (<span style="color: #a020f0;">unless</span> (memory-space-disallowed decl)
    (<span style="color: #a020f0;">let*</span> ((mss-from (get-memory-spaces
                      (query-hdl-mcpl:get-memory-spaces decl)
                      par-group-mapping))
           (mss-to (find-equivalent-memory-spaces mss-from par-group-mapping)))
      (set-memory-spaces decl mss-from mss-to))))

</pre>
</div>

<p>
The following 2 functions are technically not completely correct if an
equivalent memory space from the lower level is similar to the one of a higher
level.  To solve this, we should build up a completely new list of modifier. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-memory-spaces</span> (decl mss-from mss-to)
  (<span style="color: #a020f0;">loop</span>
     for ms-from in mss-from
     for ms-to in mss-to
     do (set-memory-space decl ms-from ms-to)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-memory-space</span> (decl ms-from ms-to)
  (<span style="color: #a020f0;">flet</span> ((ms-equal (ms-name modifier)
           (and (typep modifier 'user-defined)
                (string= ms-name
                         (ast-mcpl:name (ast-mcpl:modifier modifier))))))
    (<span style="color: #a020f0;">let</span> ((position (position (name ms-from)
                              (modifiers decl) <span style="color: #483d8b;">:test</span> #'ms-equal)))
      (<span style="color: #a020f0;">if</span> position
          (setf (ast-mcpl:name
                 (ast-mcpl:modifier (nth position (modifiers decl))))
                (name ms-to))
          (<span style="color: #a020f0;">let</span> ((new-modifier (list (make-user-defined
                                     (ast-mcpl:make-id (name ms-to))))))
            (<span style="color: #a020f0;">if</span> (null (modifiers decl))
                (setf (modifiers decl) new-modifier)
                (nconc (modifiers decl) new-modifier)))))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-memory-spaces</span> (names par-group-mapping)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (name) (get-memory-space name par-group-mapping)) names))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-memory-space</span> (name par-group-mapping)
  (<span style="color: #a020f0;">let*</span> ((par-groups
          (<span style="color: #a020f0;">loop</span> for tuple in par-group-mapping collect (from tuple)))
         (memory-spaces
          (<span style="color: #a020f0;">loop</span> for pg in par-groups append (get-all-memory-spaces pg))))
    (find name memory-spaces <span style="color: #483d8b;">:test</span> #'(<span style="color: #a020f0;">lambda</span> (n ms) (string= n (name ms))))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-all-memory-spaces</span> (par-group)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get all memory-spaces in a par-group"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-all-memory-spaces</span> ((par-group par-group))
  (memory-spaces par-group))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-all-memory-spaces</span> ((par-group sub-par-group))
  (append (memory-spaces par-group) (memory-spaces (par-unit par-group))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-equivalent-memory-spaces</span> (mss-from par-group-mapping)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (ms-from)
              (find-equivalent-memory-space ms-from par-group-mapping))
          mss-from))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-equivalent-memory-space</span> (ms-from par-group-mapping)
  (<span style="color: #a020f0;">multiple-value-bind</span> (level in-unit)
      (find-memory-space ms-from par-group-mapping)
    (<span style="color: #a020f0;">let</span> ((pgs (to (nth level par-group-mapping))))
      (<span style="color: #a020f0;">if</span> in-unit
          (<span style="color: #a020f0;">let</span> ((pg (last-elt pgs)))
            (<span style="color: #a020f0;">if</span> (typep pg 'sub-par-group)
                (find-equivalent-memory-space-2
                 ms-from (memory-spaces (par-unit pg)))
                (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Cannot find an equivalent memory-space for ~s"</span>
                       (name ms-from))))
          (find-equivalent-memory-space-2
           ms-from
           (memory-spaces (first pgs)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-equivalent-memory-space-2</span> (ms-from memory-spaces)
  (<span style="color: #a020f0;">dolist</span> (ms-to memory-spaces)
    (<span style="color: #a020f0;">when</span> (or (and (read-only-p ms-to) (read-only-p ms-from))
            (and (not (read-only-p ms-to)) (not (read-only-p ms-from))))
      (<span style="color: #a020f0;">return-from</span> find-equivalent-memory-space-2 ms-to)))
  (<span style="color: #a020f0;">dolist</span> (ms-to memory-spaces)
    (<span style="color: #a020f0;">when</span> (read-only-p ms-from)
      (<span style="color: #a020f0;">return-from</span> find-equivalent-memory-space-2 ms-to)))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Cannot find an equivalent memory-space for ~s"</span> (name ms-from)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-memory-space</span> (ms-from par-group-mapping)
  (<span style="color: #a020f0;">loop</span> for tuple in par-group-mapping
     for i from 0
     do (<span style="color: #a020f0;">let</span> ((pg (from tuple)))
          (<span style="color: #a020f0;">flet</span> ((name-equal (x)
                   (string= (name ms-from) (name x))))
            (<span style="color: #a020f0;">when</span> (filter #'name-equal (memory-spaces pg))
              (<span style="color: #a020f0;">return-from</span> find-memory-space (values i nil)))
            (<span style="color: #a020f0;">when</span> (and (typep pg 'sub-par-group)
                       (filter #'name-equal (memory-spaces (par-unit pg))))
              (<span style="color: #a020f0;">return-from</span> find-memory-space (values i t))))))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Did not find ~s in ~a"</span> ms-from par-group-mapping))
</pre>
</div>
</div>
</div>



<div id="outline-container-orga4a11d5" class="outline-4">
<h4 id="orga4a11d5"><span class="section-number-4">7.4.5</span> Translating foreach statements</h4>
<div class="outline-text-4" id="text-7-4-5">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">translate-foreach-stats</span> (ast par-group-mapping hwd-to))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">translate-foreach-stats</span> ((func func) par-group-mapping hwd-to)
  (<span style="color: #a020f0;">let</span> ((foreach-stat-roots (get-for-each-stat-roots func)))
    (<span style="color: #a020f0;">dolist</span> (fe foreach-stat-roots)
      (translate-foreach-stat fe par-group-mapping hwd-to))
    func))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">translate-foreach-stats</span> ((block-stat block-stat) par-group-mapping 
                                    hwd-to)
  (translate-foreach-stats (code-block block-stat) par-group-mapping hwd-to))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">translate-foreach-stats</span> ((code-block code-block) par-group-mapping
                                    hwd-to)
  (translate-foreach-stats (stats code-block) par-group-mapping hwd-to))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">translate-foreach-stats</span> ((stats list) par-group-mapping hwd-to)
  (<span style="color: #a020f0;">dolist</span> (stat stats)
    (<span style="color: #a020f0;">when</span> (typep stat 'foreach-stat)
      (translate-foreach-stat stat par-group-mapping hwd-to))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-for-each-stat-roots</span> (function)
  (<span style="color: #a020f0;">flet</span> ((foreach-stat (ast)
           (typep ast 'foreach-stat)))
    (<span style="color: #a020f0;">let</span> ((foreach-stats (collect-all function #'foreach-stat)))
      (filter #'(<span style="color: #a020f0;">lambda</span> (ast)
                  (null (collect-all-parent ast #'foreach-stat)))
              foreach-stats))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-foreach-stat</span> (foreach-stat par-group-mapping hwd-to)
  (<span style="color: #a020f0;">let</span> ((current-level (get-level foreach-stat par-group-mapping)))
    (<span style="color: #a020f0;">if</span> (eql (length (to (nth current-level par-group-mapping))) 1)
        (translate-foreach-simple foreach-stat par-group-mapping hwd-to)
        (translate-foreach-advanced foreach-stat par-group-mapping hwd-to))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-level</span> (foreach-stat par-group-mapping)
  (<span style="color: #a020f0;">let</span> ((par-group-name (ast-mcpl:name (par-group foreach-stat))))
    (<span style="color: #a020f0;">loop</span> for tuple in par-group-mapping
       for i from 0
       do (<span style="color: #a020f0;">let</span> ((from (from tuple)))
            (<span style="color: #a020f0;">when</span> (and (typep from 'sub-par-group)
                       (string= (name from) par-group-name))
              (<span style="color: #a020f0;">return-from</span> get-level i))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-foreach-simple</span> (foreach-stat par-group-mapping hwd-to)
  (<span style="color: #a020f0;">let*</span> ((current-level (get-level foreach-stat par-group-mapping))
         (to (first (to (nth current-level par-group-mapping)))))
    (setf (ast-mcpl:name (par-group foreach-stat)) (name to))
    (translate-foreach-stats (stat foreach-stat) par-group-mapping hwd-to)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-foreach-advanced</span> (foreach-stat par-group-mapping hwd-to)
  (<span style="color: #a020f0;">let*</span> ((par-group-name (ast-mcpl:name (par-group foreach-stat)))
         (nr-dimensions (get-nr-dimensions foreach-stat par-group-name))
         (inner-stats (get-stats-dimension (1- nr-dimensions) foreach-stat))
         (current-level (get-level foreach-stat par-group-mapping))
         (pgs-to (to (nth current-level par-group-mapping))))
    (<span style="color: #a020f0;">multiple-value-bind</span> (dimension-stats foreach-stats indexing-stats
                                          guard-conditions)
        (create-all-stats foreach-stat nr-dimensions pgs-to hwd-to)
      (setf inner-stats (append indexing-stats
                                (create-guard guard-conditions inner-stats)))
      (setf inner-stats (set-inner-stats inner-stats foreach-stats))
      (<span style="color: #a020f0;">let</span> ((stats (append dimension-stats inner-stats)))
        (replace-in-ast foreach-stat <span style="color: #483d8b;">:with</span> stats))
      foreach-stat)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-guard</span> (guard-conditions inner-stats)
  (list (make-if-stat (first guard-conditions)
                      (make-block-stat (make-code-block inner-stats))
                      nil)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-inner-stats</span> (inner-stats foreach-stats)
  (<span style="color: #a020f0;">loop</span> for fe in foreach-stats
     do (setf (stats (code-block (stat fe))) inner-stats)
       (setf inner-stats (list fe)))
  inner-stats)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-all-stats</span> (foreach-stat nr-dimensions pgs-to hwd-to)
  (<span style="color: #a020f0;">loop</span> for dim from (1- nr-dimensions) downto 0
     for stat = (get-stat-dimension dim foreach-stat)
     for (ds fes is pgs gcs) =
       (multiple-value-list (create-foreach-stat stat pgs-to hwd-to))
     then
       (multiple-value-list (create-foreach-stat stat pgs hwd-to))
     appending ds into dimension-stats
     appending fes into foreach-stats
     appending is into index-stats
     appending gcs into guard-conditions
     finally (<span style="color: #a020f0;">return</span> (values dimension-stats foreach-stats index-stats
                             guard-conditions))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-nr-dimensions</span> (foreach-stat par-group-name)
  (<span style="color: #a020f0;">if</span> (and (typep foreach-stat 'foreach-stat)
           (string= (ast-mcpl:name (par-group foreach-stat)) par-group-name))
      (+ 1 (<span style="color: #a020f0;">let</span> ((stats (stats (code-block (stat foreach-stat)))))
             (<span style="color: #a020f0;">if</span> (eql (length stats) 1)
                 (get-nr-dimensions (first stats) par-group-name)
                 0)))
      0))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-stats-dimension</span> (dimension foreach-stat)
  (<span style="color: #a020f0;">let</span> ((stats (stats (code-block (stat foreach-stat)))))
    (<span style="color: #a020f0;">if</span> (eql dimension 0)
        stats
        (get-stats-dimension (1- dimension) (first stats)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-stat-dimension</span> (dimension foreach-stat)
  (<span style="color: #a020f0;">if</span> (eql dimension 0)
      foreach-stat
      (get-stat-dimension (1- dimension)
                          (first (stats (code-block (stat foreach-stat)))))))

</pre>
</div>

<p>
The following <code>create-foreach-stat-*</code> functions return:
</p>
<ul class="org-ul">
<li>the dimension statements,</li>
<li>the foreach statements</li>
<li>the new indexing statements</li>
<li>the parallelism groups</li>
<li>the guard conditions</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-foreach-stat</span> (foreach-stat par-groups-to hwd-to)
  (<span style="color: #a020f0;">if</span> (eql (length par-groups-to) 1)
      (values nil
              (list (create-new-foreach-stat foreach-stat
                                             (first par-groups-to)))
              nil
              par-groups-to
              nil)
      (create-foreach-stat-more-par-groups foreach-stat par-groups-to hwd-to)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-foreach-stat-more-par-groups</span> (foreach-stat par-groups-to hwd-to)
  (<span style="color: #a020f0;">let*</span> ((nr-iters (nr-iters foreach-stat))
         (old-index-name (ast-mcpl:name (get-id (decl foreach-stat))))
         (names (get-names-in-scope foreach-stat))
         (guard-condition (make-lt (create-var-expr old-index-name)
                                   (copy-ast nr-iters))))
    (<span style="color: #a020f0;">loop</span> for pg in (reverse par-groups-to)
       for name-pg = (name pg)
       for dim-expr = (create-dim-expr nil nr-iters pg hwd-to) then
         (create-dim-expr dim-names nr-iters pg hwd-to)
       for dim-name = (check-name (create-dim-name nr-iters name-pg) names)
       for index-name =
         (check-name (create-index-name name-pg old-index-name) names)
       for dim-stat = (create-dim-stat dim-name dim-expr)
       for new-foreach = (create-new-foreach-stat2 index-name dim-name name-pg)
       collecting dim-name into dim-names
       collecting index-name into index-names
       collecting dim-stat into dim-stats
       collecting new-foreach into foreach-stats
       finally (<span style="color: #a020f0;">return</span> (values dim-stats
                               foreach-stats
                               (list (create-index-stat old-index-name
                                                        (reverse index-names)
                                                        (reverse dim-names)))
                               (list pg)
                               (list guard-condition))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-names-in-scope</span> (ast)
  (<span style="color: #a020f0;">let</span> ((names (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (<span style="color: #a020f0;">loop</span> for bd in (get-basic-decls-in-scope ast)
         do (setf (gethash (ast-mcpl:name (get-id bd)) names) 0))
    names))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-index-stat</span> (old-index-name index-names dim-names)
  (<span style="color: #a020f0;">let</span> ((dim-names (rest dim-names)))
    (create-decl-stat old-index-name
                      (create-index-expr index-names dim-names))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-index-expr</span> (index-names dim-names)
  (<span style="color: #a020f0;">if</span> (eql (length index-names) 1)
      (create-var-expr (first index-names))
      (<span style="color: #a020f0;">let</span> ((size-exp (create-size-expr dim-names)))
        (<span style="color: #a020f0;">destructuring-bind</span> (index-name <span style="color: #228b22;">&amp;rest</span> rest-index-names) index-names
          (ast-mcpl:make-add
           (ast-mcpl:make-mul (create-var-expr index-name) size-exp)
           (create-index-expr rest-index-names (rest dim-names)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-size-expr</span> (dim-names)
  (reduce #'(<span style="color: #a020f0;">lambda</span> (result dim-name)
              (ast-mcpl:make-mul result (create-var-expr dim-name)))
          dim-names
          <span style="color: #483d8b;">:initial-value</span> (make-int-constant 1)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-foreach-stat2</span> (index-name dim-name name-par-group)
  (make-foreach-stat
   (make-normal-decl (list (make-const))
                     (list (make-basic-decl (make-int)
                                            (ast-mcpl:make-id index-name))))
   (create-var-expr dim-name)
   (ast-mcpl:make-id name-par-group)
   (make-block-stat (make-code-block nil))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-decl-stat</span> (name expr)
  (make-decl-stat
   (make-assign-decl (list (make-const))
                     (make-basic-decl (make-int)
                                      (ast-mcpl:make-id name))
                     expr)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-dim-stat</span> (name expr)
  (create-decl-stat name expr))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-dim-name</span> (nr-iters name-par-group)
  (format nil <span style="color: #8b2252;">"nr~a~a"</span>
          (string-upcase name-par-group <span style="color: #483d8b;">:end</span> 1)
          (string-upcase (get-some-var-name nr-iters) <span style="color: #483d8b;">:end</span> 1)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-index-name</span> (par-group old-index-name)
  (format nil <span style="color: #8b2252;">"~a~a"</span> (subseq par-group 0 1) old-index-name))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-some-var-name</span> (expr))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-some-var-name</span> ((expr var-expr))
  (ast-mcpl:name (ast-mcpl:id (basic-var (var expr)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">check-name</span> (name names)
  (aif (gethash name names)
       (<span style="color: #a020f0;">progn</span>
         (setf (gethash name names) (1+ it))
         (format nil <span style="color: #8b2252;">"~a~a"</span> name it))
       (<span style="color: #a020f0;">progn</span>
         (setf (gethash name names) 0)
         name)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-dim-expr</span> (dim-names nr-iters par-group hwd-to)
  (<span style="color: #a020f0;">let</span> ((max (max-nr-units par-group)))
    (<span style="color: #a020f0;">if</span> (or (null dim-names) (not max))
        (create-min-call (create-hardware-var hwd-to (name par-group) max)
                         (copy-ast nr-iters))
        (create-div-call dim-names (copy-ast nr-iters)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-hardware-var</span> (name-hwd name-block max)
  (<span style="color: #a020f0;">let*</span> ((hwd (get-hardware-description name-hwd))
         (<span style="color: #a020f0;">block</span> (retrieve-all hwd (block-with-name name-block)))
         (bv (create-basic-var (<span style="color: #a020f0;">if</span> max <span style="color: #8b2252;">"max_nr_units"</span> <span style="color: #8b2252;">"nr_units"</span>)))
         (var (make-normal-var bv)))
    (<span style="color: #a020f0;">loop</span> for b = block then (parent b)
       while b
       for v = (make-dot-var (create-basic-var (name (id b))) var)
       then (make-dot-var (create-basic-var (name (id b))) v)
       finally (<span style="color: #a020f0;">return</span> (make-var-expr v)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-min-call</span> (exp1 exp2)
  (make-call-expr (make-call (ast-mcpl:make-id <span style="color: #8b2252;">"min"</span>) (list exp1 exp2))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-basic-var</span> (name)
  (make-basic-var (ast-mcpl:make-id name) nil))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-div-call</span> (names exp)
  (make-call-expr
   (make-call (ast-mcpl:make-id <span style="color: #8b2252;">"divide_up"</span>)
              (list
               exp
               (reduce #'(<span style="color: #a020f0;">lambda</span> (result name)
                           (ast-mcpl:make-mul result (create-var-expr name)))
                       names <span style="color: #483d8b;">:initial-value</span> (make-int-constant 1))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-var-expr</span> (name)
  (make-var-expr  (make-normal-var (create-basic-var name))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-new-foreach-stat</span> (foreach-stat par-group-to)
  (make-foreach-stat (decl foreach-stat)
                     (nr-iters foreach-stat)
                     (ast-mcpl:make-id (name par-group-to))
                     (make-block-stat (make-code-block nil))))
</pre>
</div>
</div>
</div>



<div id="outline-container-orgbe15e07" class="outline-4">
<h4 id="orgbe15e07"><span class="section-number-4">7.4.6</span> Testing translation</h4>
<div class="outline-text-4" id="text-7-4-6">
</div>
<div id="outline-container-orgf8ee2ba" class="outline-5">
<h5 id="orgf8ee2ba"><span class="section-number-5">7.4.6.1</span> The package</h5>
<div class="outline-text-5" id="text-7-4-6-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-translate</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:print-pretty</span> <span style="color: #483d8b;">:translate</span>
        <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:set-vars-written</span>)
  (<span style="color: #483d8b;">:shadow</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-translate</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org706aaed" class="outline-5">
<h5 id="org706aaed"><span class="section-number-5">7.4.6.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-4-6-2">
</div>

<ul class="org-ul">
<li><a id="orgb262a53"></a>The tests<br />
<div class="outline-text-6" id="text-orgb262a53">
<p>
Before we start with the actual tests, we define several inputs/outputs:
</p>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tostring</span> (<span style="color: #228b22;">&amp;rest</span> lines)
  (format nil <span style="color: #8b2252;">"~{~a~^~%~}"</span> lines))


(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*output-gpu*</span> (tostring

<span style="color: #8b2252;">"package matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"module matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"import perfect;"</span>
<span style="color: #8b2252;">"import gpu;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"gpu void matmul(const int n, const int m, const int p, dev float[n, m] c, const dev float[n, p] a, const dev float[p, m] b) {"</span>
<span style="color: #8b2252;">"    const int nrThreadsM = min(gpu.hierarchy.blocks.block.threads.max_nr_units, m);"</span>
<span style="color: #8b2252;">"    const int nrBlocksM = divide_up(m, 1 * nrThreadsM);"</span>
<span style="color: #8b2252;">"    foreach (const int i in n blocks) {"</span>
<span style="color: #8b2252;">"        foreach (const int bj in nrBlocksM blocks) {"</span>
<span style="color: #8b2252;">"            foreach (const int tj in nrThreadsM threads) {"</span>
<span style="color: #8b2252;">"                const int j = bj * (1 * nrThreadsM) + tj;"</span>
<span style="color: #8b2252;">"                if (j &lt; m) {"</span>
<span style="color: #8b2252;">"                    reg float sum = 0.0;"</span>
<span style="color: #8b2252;">"                    for (reg int k = 0; k &lt; p; k++) {"</span>
<span style="color: #8b2252;">"                        sum = sum + a[i, k] * b[k, j];"</span>
<span style="color: #8b2252;">"                    }"</span>
<span style="color: #8b2252;">"                    c[i, j] += sum;"</span>
<span style="color: #8b2252;">"                }"</span>
<span style="color: #8b2252;">"            }"</span>
<span style="color: #8b2252;">"        }"</span>
<span style="color: #8b2252;">"    }"</span>
<span style="color: #8b2252;">"}"</span>
<span style="color: #8b2252;">""</span>))


(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*output-accelerator*</span> (tostring

<span style="color: #8b2252;">"package matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"module matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"import perfect;"</span>
<span style="color: #8b2252;">"import accelerator;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"accelerator void matmul(const int n, const int m, const int p, dev float[n, m] c, const dev float[n, p] a, const dev float[p, m] b) {"</span>
<span style="color: #8b2252;">"    foreach (const int i in n threads) {"</span>
<span style="color: #8b2252;">"        foreach (const int j in m threads) {"</span>
<span style="color: #8b2252;">"            reg float sum = 0.0;"</span>
<span style="color: #8b2252;">"            for (reg int k = 0; k &lt; p; k++) {"</span>
<span style="color: #8b2252;">"                sum = sum + a[i, k] * b[k, j];"</span>
<span style="color: #8b2252;">"            }"</span>
<span style="color: #8b2252;">"            c[i, j] += sum;"</span>
<span style="color: #8b2252;">"        }"</span>
<span style="color: #8b2252;">"    }"</span>
<span style="color: #8b2252;">"}"</span>
<span style="color: #8b2252;">""</span>))



(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*output-fermi*</span> (tostring

<span style="color: #8b2252;">"package matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"module matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"import perfect;"</span>
<span style="color: #8b2252;">"import fermi;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"fermi void matmul(const int n, const int m, const int p, global float[n, m] c, const global float[n, p] a, const global float[p, m] b) {"</span>
<span style="color: #8b2252;">"    const int nrThreadsM = min(gpu.hierarchy.blocks.block.threads.max_nr_units, m);"</span>
<span style="color: #8b2252;">"    const int nrBlocksM = divide_up(m, 1 * nrThreadsM);"</span>
<span style="color: #8b2252;">"    foreach (const int i in n blocks) {"</span>
<span style="color: #8b2252;">"        foreach (const int bj in nrBlocksM blocks) {"</span>
<span style="color: #8b2252;">"            const int nrThreadsNrThreadsM = min(fermi.hierarchy.blocks.block.warps.warp.threads.nr_units, nrThreadsM);"</span>
<span style="color: #8b2252;">"            const int nrWarpsNrThreadsM = divide_up(nrThreadsM, 1 * nrThreadsNrThreadsM);"</span>
<span style="color: #8b2252;">"            foreach (const int wtj in nrWarpsNrThreadsM warps) {"</span>
<span style="color: #8b2252;">"                foreach (const int ttj in nrThreadsNrThreadsM threads) {"</span>
<span style="color: #8b2252;">"                    const int tj = wtj * (1 * nrThreadsNrThreadsM) + ttj;"</span>
<span style="color: #8b2252;">"                    if (tj &lt; nrThreadsM) {"</span>
<span style="color: #8b2252;">"                        const int j = bj * (1 * nrThreadsM) + tj;"</span>
<span style="color: #8b2252;">"                        if (j &lt; m) {"</span>
<span style="color: #8b2252;">"                            reg float sum = 0.0;"</span>
<span style="color: #8b2252;">"                            for (reg int k = 0; k &lt; p; k++) {"</span>
<span style="color: #8b2252;">"                                sum = sum + a[i, k] * b[k, j];"</span>
<span style="color: #8b2252;">"                            }"</span>
<span style="color: #8b2252;">"                            c[i, j] += sum;"</span>
<span style="color: #8b2252;">"                        }"</span>
<span style="color: #8b2252;">"                    }"</span>
<span style="color: #8b2252;">"                }"</span>
<span style="color: #8b2252;">"            }"</span>
<span style="color: #8b2252;">"        }"</span>
<span style="color: #8b2252;">"    }"</span>
<span style="color: #8b2252;">"}"</span>
<span style="color: #8b2252;">""</span>))


(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*input-accelerator-with-double-decl*</span> (tostring

<span style="color: #8b2252;">"package matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"module matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"import perfect;"</span>
<span style="color: #8b2252;">"import accelerator;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"accelerator void matmul(const int n, const int m, const int p, dev float[n, m] c, const dev float[n, p] a, const dev float[p, m] b) {"</span>
<span style="color: #8b2252;">"    int nrThreadsM = 3;"</span>
<span style="color: #8b2252;">"    foreach (const int i in n threads) {"</span>
<span style="color: #8b2252;">"        foreach (const int j in m threads) {"</span>
<span style="color: #8b2252;">"            reg float sum = 0.0;"</span>
<span style="color: #8b2252;">"            for (reg int k = 0; k &lt; p; k++) {"</span>
<span style="color: #8b2252;">"                sum = sum + a[i, k] * b[k, j];"</span>
<span style="color: #8b2252;">"            }"</span>
<span style="color: #8b2252;">"            c[i, j] += sum;"</span>
<span style="color: #8b2252;">"        }"</span>
<span style="color: #8b2252;">"    }"</span>
<span style="color: #8b2252;">"}"</span>
<span style="color: #8b2252;">""</span>))


(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*output-gpu-with-double-decl*</span> (tostring

<span style="color: #8b2252;">"package matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"module matrixmultiplication;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"import perfect;"</span>
<span style="color: #8b2252;">"import accelerator;"</span>
<span style="color: #8b2252;">"import gpu;"</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">""</span>
<span style="color: #8b2252;">"gpu void matmul(const int n, const int m, const int p, dev float[n, m] c, const dev float[n, p] a, const dev float[p, m] b) {"</span>
<span style="color: #8b2252;">"    const int nrThreadsM = 3;"</span>
<span style="color: #8b2252;">"    const int nrThreadsM0 = min(gpu.hierarchy.blocks.block.threads.max_nr_units, m);"</span>
<span style="color: #8b2252;">"    const int nrBlocksM = divide_up(m, 1 * nrThreadsM0);"</span>
<span style="color: #8b2252;">"    foreach (const int i in n blocks) {"</span>
<span style="color: #8b2252;">"        foreach (const int bj in nrBlocksM blocks) {"</span>
<span style="color: #8b2252;">"            foreach (const int tj in nrThreadsM0 threads) {"</span>
<span style="color: #8b2252;">"                const int j = bj * (1 * nrThreadsM0) + tj;"</span>
<span style="color: #8b2252;">"                if (j &lt; m) {"</span>
<span style="color: #8b2252;">"                    reg float sum = 0.0;"</span>
<span style="color: #8b2252;">"                    for (reg int k = 0; k &lt; p; k++) {"</span>
<span style="color: #8b2252;">"                        sum = sum + a[i, k] * b[k, j];"</span>
<span style="color: #8b2252;">"                    }"</span>
<span style="color: #8b2252;">"                    c[i, j] += sum;"</span>
<span style="color: #8b2252;">"                }"</span>
<span style="color: #8b2252;">"            }"</span>
<span style="color: #8b2252;">"        }"</span>
<span style="color: #8b2252;">"    }"</span>
<span style="color: #8b2252;">"}"</span>
<span style="color: #8b2252;">""</span>))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*template-fermi*</span>
<span style="color: #8b2252;">"package a;</span>

<span style="color: #8b2252;">module a;</span>



<span style="color: #8b2252;">import perfect;</span>
<span style="color: #8b2252;">import fermi;</span>



<span style="color: #8b2252;">~a</span>
<span style="color: #8b2252;">"</span>)

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*template-perfect*</span>
<span style="color: #8b2252;">"package a;</span>
<span style="color: #8b2252;"> module a;</span>
<span style="color: #8b2252;"> import perfect;</span>

<span style="color: #8b2252;"> ~a</span>
<span style="color: #8b2252;">"</span>)
</pre>
</div>



<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:test-translate</span>)

(def-suite translate <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite translate)

(test files ()
  (is (string= 
       *output-accelerator* 
       (do-translation-file
           <span style="color: #8b2252;">"input/mcpl/matrixmultiplication/matrixmultiplication.mcl"</span>
         <span style="color: #8b2252;">"accelerator"</span>)))
  (is (string= 
       *output-gpu* 
       (do-translation-file
           <span style="color: #8b2252;">"input/mcpl/matrixmultiplication/matrixmultiplication.mcl"</span>
         <span style="color: #8b2252;">"gpu"</span>)))
  (is (string= 
       *output-fermi* 
       (do-translation-file
           <span style="color: #8b2252;">"input/mcpl/matrixmultiplication/matrixmultiplication.mcl"</span>
         <span style="color: #8b2252;">"fermi"</span>)))
  (is (string=
       *output-gpu-with-double-decl*
       (do-translation-string *input-accelerator-with-double-decl* <span style="color: #8b2252;">"gpu"</span>))))
</pre>
</div>




<p>
Testing multiple calls:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(test multiple-calls
  (is 
    (translate-ok (translate-funcs
<span style="color: #8b2252;">"perfect void h(int n, float[n] a) {</span>
<span style="color: #8b2252;">   a[0] = 0.0;</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(int n, float[n] a) {</span>
<span style="color: #8b2252;">   h(n, a);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f(int n, float[n] a) {</span>
<span style="color: #8b2252;">   g(n, a);</span>
<span style="color: #8b2252;">   h(n, a);</span>
<span style="color: #8b2252;"> }"</span>
<span style="color: #8b2252;">"fermi"</span>)
<span style="color: #8b2252;">"fermi void h(const int n, global float[n] a) {</span>
<span style="color: #8b2252;">    a[0] = 0.0;</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">fermi void g(const int n, global float[n] a) {</span>
<span style="color: #8b2252;">    h(n, a);</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;">fermi void f(const int n, global float[n] a) {</span>
<span style="color: #8b2252;">    g(n, a);</span>
<span style="color: #8b2252;">    h(n, a);</span>
<span style="color: #8b2252;">}"</span>)))
</pre>
</div>
</div>
</li>


<li><a id="org4ab76ff"></a>Helper functions<br />
<div class="outline-text-6" id="text-org4ab76ff">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-translation-file</span> (file-name-input target)
  (do-translation (parse-mcpl-file file-name-input) target))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-translation-string</span> (string target)
  (do-translation (parse-mcpl string) target))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-translation</span> (module target)
  (set-parents module)
  (resolve-calls module nil)
  (<span style="color: #a020f0;">let</span> ((callgraph (set-callgraph (funcs (code module)))))
    (resolve-vars module nil)
    (set-cfgraphs module)
    (set-vars-written callgraph)
    (translate (list module) callgraph target target)
    (pp module)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-ok</span> (translation wanted-funcs)
  (string= translation
           (format nil *template-fermi* wanted-funcs)))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate-funcs</span> (funcs target)
  (do-translation (funcs-&gt;perfect-ast funcs) target))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">funcs-&gt;perfect-ast</span> (input-string)
  (parse-mcpl (format nil *template-perfect* input-string)))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga21d863" class="outline-3">
<h3 id="orga21d863"><span class="section-number-3">7.5</span> Generate Code</h3>
<div class="outline-text-3" id="text-7-5">
</div>
<div id="outline-container-orga5be82d" class="outline-4">
<h4 id="orga5be82d"><span class="section-number-4">7.5.1</span> The package</h4>
<div class="outline-text-4" id="text-7-5-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:generate-code</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:code-emitter</span>
        <span style="color: #483d8b;">:mcl-util</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:check-types</span> <span style="color: #483d8b;">:print-pretty</span>
        <span style="color: #483d8b;">:move-foreach-to-func</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:appendf</span> <span style="color: #483d8b;">:compose</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:aif</span> <span style="color: #483d8b;">:acond</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:string-case</span> <span style="color: #483d8b;">:string-case</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:cl-fad</span> <span style="color: #483d8b;">:pathname-as-directory</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:cartesian-product</span> <span style="color: #483d8b;">:def-methods</span> <span style="color: #483d8b;">:fixed-point</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:generate-code</span> <span style="color: #483d8b;">:cashmere-info</span> <span style="color: #483d8b;">:default-func</span> <span style="color: #483d8b;">:copy-func-header</span>
           <span style="color: #483d8b;">:call-conditions</span> <span style="color: #483d8b;">:set-argument</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9583183" class="outline-4">
<h4 id="org9583183"><span class="section-number-4">7.5.2</span> The generic methods and classes</h4>
<div class="outline-text-4" id="text-7-5-2">
</div>

<div id="outline-container-org74dffc1" class="outline-5">
<h5 id="org74dffc1"><span class="section-number-5">7.5.2.1</span> Defining the class</h5>
<div class="outline-text-5" id="text-7-5-2-1">
<p>
To generate code from AST-forms, we use the generic <code>gen</code> function.  These
functions take as parameter an AST-form and an <code>*-generator</code> object.  These
objects effectively direct what kind of forms are generated.  Below, the
<code>generic-generator</code> class is defined that has a <code>codegen-info</code> object as slot.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">generic-generator</span> ()
  ((codegen-info <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need a codegen-info"</span>)
                 <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:codegen-info</span>
                 <span style="color: #483d8b;">:reader</span> codegen-info)
   (callgraph <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need a callgraph"</span>)
              <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:callgraph</span>
              <span style="color: #483d8b;">:reader</span> callgraph)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org177d6bf" class="outline-5">
<h5 id="org177d6bf"><span class="section-number-5">7.5.2.2</span> The entry-point</h5>
<div class="outline-text-5" id="text-7-5-2-2">
<p>
As of now, the code-generation generates C++ code:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-code</span> (module type-code codegen-info entry-funcs output-dir
                      callgraph)
  (string-case (type-code)
    (<span style="color: #8b2252;">"cpp"</span> (gen
            module
            (create-cpp-generator module codegen-info entry-funcs output-dir
                                  callgraph)))
    (<span style="color: #8b2252;">"cashmere"</span>
     (<span style="color: #a020f0;">let</span> ((entry-funcs (get-kernel-callers callgraph)))
       (<span style="color: #a020f0;">if</span> (&gt; (length entry-funcs) 1)
           (errors:mcl-error nil <span style="color: #8b2252;">"Expect only one entry-function."</span>)
           (gen
            module
            (create-cashmere-generator module codegen-info entry-funcs
                                       output-dir callgraph)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-kernel-callers</span> (callgraph)
  (mapcar (compose #'name #'id)
          (remove-if (complement #'calls-kernel-p) (tops-callgraph callgraph))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">calls-kernel-p</span> (func)
  (<span style="color: #a020f0;">let</span> ((call-stats (remove-if (complement #'call-stat-p) (stats (code-block func)))))
    (<span style="color: #a020f0;">loop</span> for call-stat in call-stats thereis (kernel-func-p call-stat))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org5aca0fd" class="outline-5">
<h5 id="org5aca0fd"><span class="section-number-5">7.5.2.3</span> The gen-* functions</h5>
<div class="outline-text-5" id="text-7-5-2-3">
<p>
The following functions operate on the generic generator and are expected to be
the same for each generator.  The standard solution is to raise an error if a
complex AST form is not implemented for a more specific generator:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen</span> (ast generator))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">not-implemented-error</span> (ast gen)
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"gen(~a ~a) not implemented"</span> (type-of ast) (type-of gen)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> (ast (generator generic-generator))
  (not-implemented-error ast generator))
</pre>
</div>

<p>
If an AST form is very common, we generate a standard form of it:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((code code) (gen generic-generator))
  (<span style="color: #a020f0;">with-slots</span> (top-decls funcs) code
    (emit <span style="color: #8b2252;">"~a"</span> (gen top-decls gen)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a"</span> (gen funcs gen)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">""</span>)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((mcl-type mcl-type) (gen generic-generator))
  (<span style="color: #a020f0;">typecase</span> mcl-type
    ((or void int flt bool double)
     (pp mcl-type))
    (t
     (not-implemented-error mcl-type gen))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((id id) (gen generic-generator))
  (pp id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((e expr) (gen generic-generator))
  (do-pp e gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((cb code-block) (gen generic-generator))
  (do-pp cb gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ds decl-stat) (gen generic-generator))
  (do-pp ds gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((nd normal-decl) (gen generic-generator))
  (do-pp nd gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ad assign-decl) (gen generic-generator))
  (do-pp ad gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((das decl-array-size) (gen generic-generator))
  (do-pp das gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((cs call-stat) (gen generic-generator))
  (do-pp cs gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((c call) (gen generic-generator))
  (do-pp c gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((is if-stat) (gen generic-generator))
  (do-pp is gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((as assign-stat) (gen generic-generator))
  (do-pp as gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((is inc-stat) (gen generic-generator))
  (do-pp is gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((i inc) (gen generic-generator))
  (do-pp i gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((bs block-stat) (gen generic-generator))
  (do-pp bs gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((as as-stat) (gen generic-generator))
  <span style="color: #8b2252;">""</span>)
</pre>
</div>

<p>
There are other generic functions that play a role:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-params</span> (params gen))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-param</span> (param gen))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-param2</span> (basic-decl constant-p gen))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-func-decl</span> (func generator))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-func-decl-2</span> (func generator))
</pre>
</div>



<p>
The function <code>do-pp</code> performs a pretty-print on an AST-form with the function
<code>gen</code> as pretty-printing function.  Since the class directs, which <code>gen</code>
function is called, we need to include that.  Hence, the <code>get-gen</code> function
which returns a function that calls <code>gen</code> with the original generator.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-pp</span> (ast gen)
  (pp ast (get-gen gen)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-gen</span> (gen)
  #'(<span style="color: #a020f0;">lambda</span> (x pp) (<span style="color: #a020f0;">declare</span> (ignore pp)) (gen x gen)))
</pre>
</div>

<p>
For lists, we use a similar construct:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((l list) (gen generic-generator))
  (pp l #'(<span style="color: #a020f0;">lambda</span> (element) (gen element gen))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4d4ccf4" class="outline-4">
<h4 id="org4d4ccf4"><span class="section-number-4">7.5.3</span> Outputfiles</h4>
<div class="outline-text-4" id="text-7-5-3">
<p>
An <code>output-file</code> contains the code and some properties about the file:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">output-file</span> ()
  ((output-dir <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply an output dir"</span>)
               <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:output-dir</span>
               <span style="color: #483d8b;">:reader</span> output-dir)
   (module-dir <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply a module dir"</span>)
               <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:module-dir</span>
               <span style="color: #483d8b;">:reader</span> module-dir)
   (base-filename <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply a base-file-name"</span>)
                  <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:base-filename</span>
                  <span style="color: #483d8b;">:reader</span> base-filename)
   (extension <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply an extension"</span>)
              <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:extension</span>
              <span style="color: #483d8b;">:reader</span> extension)
   (header <span style="color: #483d8b;">:initform</span> (make-string-output-stream) <span style="color: #483d8b;">:accessor</span> header)
   (contents <span style="color: #483d8b;">:initform</span> (make-string-output-stream) <span style="color: #483d8b;">:accessor</span> contents)
   (footer <span style="color: #483d8b;">:initform</span> (make-string-output-stream) <span style="color: #483d8b;">:accessor</span> footer)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-output-file</span> (output-dir module-dir base-filename extension)
  (make-instance 'output-file <span style="color: #483d8b;">:output-dir</span> output-dir <span style="color: #483d8b;">:module-dir</span> module-dir
                 <span style="color: #483d8b;">:base-filename</span> base-filename <span style="color: #483d8b;">:extension</span> extension))
</pre>
</div>

<p>
Some useful functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-dir</span> (module))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-dir</span> ((m module))
  (get-dir (pkg m)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-dir</span> ((id id))
  (name id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-dir</span> ((ci compound-id))
  (<span style="color: #a020f0;">with-slots</span> (name compound) ci
    (format nil <span style="color: #8b2252;">"~a/~a"</span> name (get-dir compound))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">write-output</span> (output-file))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">write-output</span> ((of output-file))
  (<span style="color: #a020f0;">with-slots</span> (output-dir module-dir base-filename extension
                          header contents footer) <span style="color: #ff0000; font-weight: bold;">of</span>
    (<span style="color: #a020f0;">let*</span> ((base-dir (pathname-as-directory output-dir))
           (dir (merge-pathnames
                 (pathname-as-directory module-dir)
                 base-dir))
           (file (merge-pathnames
                  (format nil <span style="color: #8b2252;">"~a~a"</span> base-filename extension)
                  dir)))
      (<span style="color: #a020f0;">with-open-file</span> (out (ensure-directories-exist file) 
                           <span style="color: #483d8b;">:direction</span> <span style="color: #483d8b;">:output</span> <span style="color: #483d8b;">:if-exists</span> <span style="color: #483d8b;">:supersede</span>)
        (format out (get-output-stream-string header))
        (format out (get-output-stream-string contents))
        (format out (get-output-stream-string footer))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2bfe17e" class="outline-4">
<h4 id="org2bfe17e"><span class="section-number-4">7.5.4</span> Library</h4>
<div class="outline-text-4" id="text-7-5-4">
<p>
Below useful code is listed, such as whether something is exported or is a
kernel function.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">exported-p</span> (ast gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">exported-p</span> ((cd const-decl) (gen generic-generator))
  (exported-p (decl cd) gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">exported-p</span> ((ad assign-decl) (gen generic-generator))
  (exported-p (basic-decl ad) gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">exported-p</span> ((bd basic-decl) (gen generic-generator))
  (exported-p (id bd) gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">exported-p</span> ((f func) (gen generic-generator))
  (exported-p (id f) gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">exported-p</span> ((td typedef) (gen generic-generator))
  (exported-p (id td) gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">exported-p</span> ((id id) (gen generic-generator))
  (find id (exports gen) <span style="color: #483d8b;">:test</span> #'ast=))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgce74882" class="outline-4">
<h4 id="orgce74882"><span class="section-number-4">7.5.5</span> Generic generators</h4>
<div class="outline-text-4" id="text-7-5-5">
</div>

<div id="outline-container-org841a516" class="outline-5">
<h5 id="org841a516"><span class="section-number-5">7.5.5.1</span> The generators</h5>
<div class="outline-text-5" id="text-7-5-5-1">
<p>
Using the <code>generic-generator</code> as base, we define three subclasses that provide
functionality.  The <code>c-base-generator</code> provides several <code>gen-*</code> functions that
can be used by C-like languages.  The <code>kernel-generator</code> supplies a file with
kernels, the <code>exports generator</code> needs a list of exports, and the
<code>entry-funcs-generator</code> expects a variable with entry functions that need to be
generated.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">c-base-generator</span> (generic-generator) ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">kernel-generator</span> (generic-generator)
  ((kernels-file <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply a kernels-file"</span>)
                 <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:kernels-file</span>
                 <span style="color: #483d8b;">:accessor</span> kernels-file)))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">exports-generator</span> (generic-generator)
  ((exports <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply exports"</span>)
            <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:exports</span> <span style="color: #483d8b;">:reader</span> exports)))
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">entry-funcs-generator</span> (generic-generator)
  ((entry-funcs <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply entry-funcs"</span>)
                <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:entry-funcs</span> <span style="color: #483d8b;">:reader</span> entry-funcs)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org9a08191" class="outline-5">
<h5 id="org9a08191"><span class="section-number-5">7.5.5.2</span> The gen-* functions</h5>
<div class="outline-text-5" id="text-7-5-5-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-func-decl-2</span> ((f func) (gen c-base-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id params) f
    (emit <span style="color: #8b2252;">"~a ~a(~a);"</span> (gen mcl-type gen)
          (gen id gen)
          (gen-params params gen))))
</pre>
</div>

<p>
Types:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ct custom-type) (gen c-base-generator))
  (<span style="color: #a020f0;">with-slots</span> (id params) ct
    (<span style="color: #a020f0;">if</span> params
        (not-implemented-error ct gen)
        (gen id gen))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((b mcl-byte) (gen c-base-generator))
  (emit <span style="color: #8b2252;">"unsigned char"</span>))
</pre>
</div>


<p>
Declarations:
</p>

<p>
This doesn't work, since it will add a " " because of the list.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ud user-defined) (gen c-base-generator))
  <span style="color: #8b2252;">""</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((c const) (gen c-base-generator))
  <span style="color: #8b2252;">"const"</span>)
</pre>
</div>




<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-builtin</span> (ast generator))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-builtin</span> ((c call) (gen c-base-generator))
  (<span style="color: #a020f0;">with-slots</span> (params id) c
    (string-case ((name id))
      (<span style="color: #8b2252;">"toFloat"</span>
       (emit <span style="color: #8b2252;">"(float) ~a"</span> (gen (first params) gen)))
      (<span style="color: #8b2252;">"toDouble"</span>
       (emit <span style="color: #8b2252;">"(double) ~a"</span> (gen (first params) gen)))
      (<span style="color: #8b2252;">"min"</span>
       (<span style="color: #a020f0;">if</span> (a-param-has-type-p params 'flt)
           (emit <span style="color: #8b2252;">"fmin(~a)"</span> (emit-list params <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
                                       <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen))))
           (emit <span style="color: #8b2252;">"min(~a)"</span> (emit-list params <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
                                      <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen))))))
      (<span style="color: #8b2252;">"max"</span>
       (<span style="color: #a020f0;">if</span> (a-param-has-type-p params 'flt)
           (emit <span style="color: #8b2252;">"fmax(~a)"</span> (emit-list params <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
                                       <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen))))
           (emit <span style="color: #8b2252;">"max(~a)"</span> (emit-list params <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
                                      <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen))))))
      (<span style="color: #8b2252;">"divide_up"</span> (gen-divide-up params gen)))))



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">a-param-has-type-p</span> (params type)
  (<span style="color: #a020f0;">loop</span> for p in params thereis (typep (eval-type p) type)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-divide-up</span> (params gen)
  (<span style="color: #a020f0;">let</span> ((l (first params))
        (r (second params)))
    (emit <span style="color: #8b2252;">"~a ?"</span> (gen (make-equ l r) gen)
          <span style="color: #8b2252;">"    1 :"</span>
          <span style="color: #8b2252;">"    ~a ?"</span> (gen (make-equ (make-modulo l r)
                                    (make-int-constant 0)) <span style="color: #ff0000; font-weight: bold;">gen)</span>
          <span style="color: #8b2252;">"        ~a :"</span> (gen (make-div l r) gen)
          <span style="color: #8b2252;">"        ~a"</span> (gen (make-add (make-div l r)
                                      (make-int-constant 1)) <span style="color: #ff0000; font-weight: bold;">gen))))</span>

</pre>
</div>

<p>
Variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((nv normal-var) (gen c-base-generator))
  (gen-var nv gen))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-var</span> (var gen)
  (<span style="color: #a020f0;">with-slots</span> (basic-var) var
    (<span style="color: #a020f0;">with-slots</span> (array-exprs basic-decl) basic-var
      (<span style="color: #a020f0;">with-slots</span> (decl) basic-decl
        (<span style="color: #a020f0;">let</span> ((array-expr-string
               (<span style="color: #a020f0;">if</span> (null array-exprs)
                   <span style="color: #8b2252;">""</span>
                   (emit <span style="color: #8b2252;">"[~a]"</span> (gen (first array-exprs) gen)))))
          (dereference var decl (get-id decl) array-expr-string gen))))))
</pre>
</div>

<p>
For dereferencing variables, there are basically these possibilities:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>a</code></td>
</tr>

<tr>
<td class="org-left"><code>&amp;a</code></td>
</tr>

<tr>
<td class="org-left"><code>*a</code></td>
</tr>

<tr>
<td class="org-left"><code>a[1]</code></td>
</tr>

<tr>
<td class="org-left"><code>&amp;a[1]</code></td>
</tr>

<tr>
<td class="org-left"><code>a.b</code></td>
</tr>

<tr>
<td class="org-left"><code>a-&gt;b</code></td>
</tr>

<tr>
<td class="org-left"><code>&amp;a.b</code></td>
</tr>

<tr>
<td class="org-left"><code>&amp;a-&gt;b</code></td>
</tr>

<tr>
<td class="org-left"><code>a[1].b</code></td>
</tr>

<tr>
<td class="org-left"><code>&amp;a[1].b</code></td>
</tr>
</tbody>
</table>

<p>
First, it is important to know when a declaration is a pointer.  This is
the case when:
</p>
<ul class="org-ul">
<li>a declaration is a pointer if the type of the declaration is not primitive
and is a parameter of a function</li>
<li>a declaration is a pointer if the type of the declaration is an array type</li>
<li>a declaration is a pointer if the type is primitive, a parameter of a
function, and is written in the function</li>
</ul>

<p>
Subsequently, it is necessary to know whether a variable is a pointer.  This is
the case if 
</p>
<ul class="org-ul">
<li>the type is non-primitive</li>
<li>of if the type is primitive it is part of a call to a function where the
matching declaration is a pointer</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> For normal variables</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">variable form</th>
<th scope="col" class="org-left">cases</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>a</code></td>
<td class="org-left">- decl is no pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is no pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is no pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>*a</code></td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of decl is primitive</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is no pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;a</code></td>
<td class="org-left">- decl is no pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>a[1]</code></td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of decl is array</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- (var is no pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of var is not array)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- (var is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of var is array)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;a[1]</code></td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of decl is array</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of var is not array</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">dereference</span> (var decl id array-expr-string gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">dereference</span> ((nv normal-var) decl id array-expr-string gen)
  (<span style="color: #a020f0;">let*</span> ((type-decl (get-type-decl decl))
         (decl-pointer-p (pointer-p decl))
         (var-pointer-p (pointer-p nv))
         (type-decl-array-p (typep type-decl 'array-type))
         (type-decl-primitive-p (primitive-decl-p decl))
         (type-var-array-p (typep (get-type nv) 'array-type))
         (prefix 
          (<span style="color: #a020f0;">if</span> decl-pointer-p
              (<span style="color: #a020f0;">if</span> var-pointer-p
                  (<span style="color: #a020f0;">if</span> type-decl-array-p
                      (<span style="color: #a020f0;">if</span> type-var-array-p <span style="color: #8b2252;">""</span> <span style="color: #8b2252;">"&amp;"</span>)
                      <span style="color: #8b2252;">""</span>)
                  (<span style="color: #a020f0;">cond</span> (type-decl-primitive-p
                         <span style="color: #8b2252;">"*"</span>)
                        (type-decl-array-p
                         (<span style="color: #a020f0;">if</span> type-var-array-p
                             (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"type-var cannot be array and not pointer"</span>)
                             <span style="color: #8b2252;">""</span>))
                        (t
                         (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"type-decl is pointer, but not an array or</span>
<span style="color: #8b2252;">primitive, so a struct, but the var is not a pointer"</span>))))
              (<span style="color: #a020f0;">if</span> var-pointer-p <span style="color: #8b2252;">"&amp;"</span> <span style="color: #8b2252;">""</span>))))
    (emit <span style="color: #8b2252;">"~a~a~a"</span> prefix (name id) array-expr-string)))

</pre>
</div>

<p>
For dot variables, it is a bit different.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((dv dot-var) (gen c-base-generator))
  (gen-var dv gen))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> For dot variables</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">variable form</th>
<th scope="col" class="org-left">cases</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>a.b</code></td>
<td class="org-left">- decl is no pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is no pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>a-&gt;b</code></td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is no pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;a.b</code></td>
<td class="org-left">- decl is no pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;a-&gt;b</code></td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>a[1].b</code></td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of decl is array</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is no pointer</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>&amp;a[1].b</code></td>
<td class="org-left">- decl is pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- type of decl is array</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- var is pointer</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">dereference</span> ((dv dot-var) decl id array-expr-string gen)
  (<span style="color: #a020f0;">let</span> ((prefix <span style="color: #8b2252;">""</span>)
        (dot <span style="color: #8b2252;">""</span>))
    (<span style="color: #a020f0;">let*</span> ((decl-pointer-p (pointer-p decl))
           (var-pointer-p (pointer-p dv))
           (type-decl-array-p (typep (get-type decl) 'array-type)))
      (<span style="color: #a020f0;">if</span> type-decl-array-p
          (<span style="color: #a020f0;">if</span> (not decl-pointer-p)
              (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"decl not a pointer"</span>)
              (<span style="color: #a020f0;">progn</span>
                (setf dot <span style="color: #8b2252;">"."</span>)
                (<span style="color: #a020f0;">when</span> var-pointer-p (setf prefix <span style="color: #8b2252;">"&amp;"</span>))))
          (<span style="color: #a020f0;">cond</span> ((and (not decl-pointer-p) (not var-pointer-p))
                 (setf dot <span style="color: #8b2252;">"."</span>))
                ((and decl-pointer-p (not var-pointer-p))
                 (setf dot <span style="color: #8b2252;">"-&gt;"</span>))
                ((and (not decl-pointer-p) var-pointer-p)
                 (setf dot <span style="color: #8b2252;">"."</span>)
                 (setf prefix <span style="color: #8b2252;">"&amp;"</span>))
                ((and decl-pointer-p var-pointer-p)
                 (setf dot <span style="color: #8b2252;">"-&gt;"</span>)
                 (setf prefix <span style="color: #8b2252;">"&amp;"</span>))
                (t
                 (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"missed a case"</span>))))
      (emit <span style="color: #8b2252;">"~a~a~a~a~a"</span>
            prefix (name id) array-expr-string dot (pp (var dv))))))
</pre>
</div>

<p>
Helper functions for deciding whether a variable or declaration is a pointer:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">pointer-p</span> (var-or-decl))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pointer-p</span> ((v var))
  (<span style="color: #a020f0;">let</span> ((primitive-var-p (primitive-p v)))
    (or (not primitive-var-p)
        (and primitive-var-p (written-in-call-p v)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pointer-p</span> ((d decl))
  (<span style="color: #a020f0;">let*</span> ((type-decl (get-type d))
         (param-p (param-p d))
         (primitive-p (primitive-p d))
         (written-p (written d))
         (array-type-p (typep type-decl 'array-type)))
    (or array-type-p
        (and (not primitive-p) param-p)
        (and primitive-p param-p written-p))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">written-in-call-p</span> (var)
  (and (param-p var) (param-written-p var)))
</pre>
</div>

<p>
Increments:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((is inc-step) (gen c-base-generator))
  (<span style="color: #a020f0;">with-slots</span> (var option expr) is
    (emit <span style="color: #8b2252;">"~a ~a ~a"</span> (gen var gen) option (gen expr gen))))

</pre>
</div>

<p>
For statements:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((fs for-stat) (gen c-base-generator))
  (<span style="color: #a020f0;">with-slots</span> (decl cond-expr inc stat) fs
    (emit <span style="color: #8b2252;">"for (~a; ~a; ~a) ~a"</span>
          (gen decl gen)
          (gen cond-expr gen)
          (gen inc gen)
          (gen stat gen))))
</pre>
</div>


<p>
Swap statements:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ss swap-stat) (gen c-base-generator))
  (<span style="color: #a020f0;">with-slots</span> (var-left var-right) ss
    (<span style="color: #a020f0;">let</span> ((type (get-type var-left)))
      (emit <span style="color: #8b2252;">"{~a *tmp = ~a; ~a = ~a; ~a = tmp;}"</span>
            (gen-swap-type type gen)
            (gen var-left gen)
            (gen var-left gen)
            (gen var-right gen)
            (gen var-right gen)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-swap-type</span> (type gen)
  (pp-base-type type (get-gen gen)))
</pre>
</div>


<p>
Constant declaration:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((cd const-decl) (gen c-base-generator))
  (<span style="color: #a020f0;">when</span> (not (exported-p cd gen))
    (gen-const-decl cd gen)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-const-decl</span> (cd gen)
  (<span style="color: #a020f0;">with-slots</span> (basic-decl expr) (decl cd)
    (emit <span style="color: #8b2252;">"#define ~a (~a)"</span> (name (id basic-decl)) (gen expr gen))))
</pre>
</div>
</div>
</div>


<div id="outline-container-orge3a0e21" class="outline-5">
<h5 id="orge3a0e21"><span class="section-number-5">7.5.5.3</span> The gen-params-* functions</h5>
<div class="outline-text-5" id="text-7-5-5-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-params</span> (params (gen c-base-generator))
  (emit-list params <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span> <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x)
                                                  (gen-param x gen))))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param</span> ((d decl) (gen c-base-generator))
  (gen-param2 (get-basic-decl d) (constant-p d) gen))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param2</span> ((basic-decl basic-decl) constant-p
                       (gen c-base-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) basic-decl
    (<span style="color: #a020f0;">with-slots</span> (name) id
      (<span style="color: #a020f0;">if</span> (and (primitive-decl-p basic-decl) constant-p)
          (emit <span style="color: #8b2252;">"const ~a ~a"</span> (gen mcl-type gen) name)
          (emit <span style="color: #8b2252;">"~a* ~a"</span> (gen (get-base-type mcl-type) gen) name)))))
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org94be67e" class="outline-4">
<h4 id="org94be67e"><span class="section-number-4">7.5.6</span> Generate C++ code</h4>
<div class="outline-text-4" id="text-7-5-6">
<p>
This section discusses generating C++ code.  
</p>
</div>

<div id="outline-container-org2239eaf" class="outline-5">
<h5 id="org2239eaf"><span class="section-number-5">7.5.6.1</span> Creating the generator</h5>
<div class="outline-text-5" id="text-7-5-6-1">
<p>
The C++ generator, maintains a list of exports, a header file for incorporating
it into other C++ code, the C++ file itself and a file for kernels.  This
generator will switch at some point to the <code>header-generator</code> and the generator
for the kernel.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">cpp-generator</span> (c-base-generator kernel-generator exports-generator
                                          entry-funcs-generator)
  ((header-file <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply a header file"</span>)
                <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:header-file</span>
                <span style="color: #483d8b;">:accessor</span> header-file)
   (cpp-file <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Need to supply a cpp-file"</span>)
             <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:cpp-file</span>
             <span style="color: #483d8b;">:accessor</span> cpp-file)))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-cpp-generator</span> (exports header-file cpp-file kernels-file
                           codegen-info entry-funcs callgraph)
  (make-instance 'cpp-generator <span style="color: #483d8b;">:exports</span> exports <span style="color: #483d8b;">:header-file</span> header-file
                 <span style="color: #483d8b;">:cpp-file</span> cpp-file <span style="color: #483d8b;">:kernels-file</span> kernels-file
                 <span style="color: #483d8b;">:codegen-info</span> codegen-info <span style="color: #483d8b;">:entry-funcs</span> entry-funcs
                 <span style="color: #483d8b;">:callgraph</span> callgraph))
</pre>
</div>

<p>
The following fuction creates a C++ generator based on the module and the
code-generation information.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-cpp-generator</span> (module codegen-info entry-funcs output-dir
                             callgraph)
  (<span style="color: #a020f0;">let</span> ((module-dir (get-dir module))
        (name-module (name (id module))))
    (make-cpp-generator
     (exports module)
     (make-output-file output-dir module-dir name-module <span style="color: #8b2252;">".h"</span>)
     (make-output-file output-dir module-dir name-module <span style="color: #8b2252;">".cpp"</span>)
     (make-output-file output-dir module-dir
                       (format nil <span style="color: #8b2252;">"~a-kernels"</span> name-module) <span style="color: #8b2252;">".cl"</span>)
     codegen-info
     entry-funcs
     callgraph)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a8f727" class="outline-5">
<h5 id="org8a8f727"><span class="section-number-5">7.5.6.2</span> The gen-* functions</h5>
<div class="outline-text-5" id="text-7-5-6-2">
<p>
Generating a module for C++ is done as shown below.  It is necessary that the
OpenCL code is generated first because it modifies the AST to deal with
functions with multiple memory-spaces.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((module module) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (cpp-file header-file kernels-file entry-funcs) gen
    (<span style="color: #a020f0;">with-slots</span> (contents) cpp-file
      (<span style="color: #a020f0;">with-slots</span> (code) module
        (<span style="color: #a020f0;">let</span> ((header-file header-file)
              (cpp-file cpp-file)
              (entry-funcs entry-funcs))
          (generate-opencl module gen)
          (change-class gen 'cpp-generator <span style="color: #483d8b;">:header-file</span> header-file
                        <span style="color: #483d8b;">:cpp-file</span> cpp-file <span style="color: #483d8b;">:entry-funcs</span> entry-funcs)
          (generate-header module gen)
          (add-include module gen)
          (format contents (gen code gen))
          (write-output cpp-file)
          (write-output header-file)
          (<span style="color: #a020f0;">when</span> (funcs-in-module-p entry-funcs module)
            (write-output kernels-file)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-include</span> (module gen)
  (<span style="color: #a020f0;">with-slots</span> (imports) module
    (<span style="color: #a020f0;">with-slots</span> (cpp-file) gen
      (<span style="color: #a020f0;">with-slots</span> (header) cpp-file
        (format header <span style="color: #8b2252;">"#include &lt;iostream&gt;~%"</span>)
        (format header <span style="color: #8b2252;">"#include &lt;exception&gt;~%~%"</span>)
        (format header <span style="color: #8b2252;">"#include \"io_data.h\"~%"</span>)
        (format header <span style="color: #8b2252;">"#include \"OpenCL.h\"~%~%"</span>)
        (format header <span style="color: #8b2252;">"#include &lt;CL/cl.hpp&gt;~%~%"</span>)
        (format header <span style="color: #8b2252;">"~a~%~%"</span> (create-import-includes imports gen))
        (format header <span style="color: #8b2252;">"~%~%#include \"~a.h\"~%~%~%"</span> (create-header module))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-header</span> (module)
  (<span style="color: #a020f0;">with-slots</span> (pkg id) module
    (format nil <span style="color: #8b2252;">"~a/~a"</span> (create-include pkg) (create-include id))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-import-includes</span> (imports gen)
  (<span style="color: #a020f0;">let</span> ((modules (remove-if (complement #'module-import-p) imports)))
    (<span style="color: #a020f0;">if</span> (null modules)
        <span style="color: #8b2252;">""</span>
        (emit-list modules
                   <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">module-import-p</span> (import)
  (not (hardware-descriptions:hardware-description-p import)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((li lib-import) (gen cpp-generator))
  (emit <span style="color: #8b2252;">"#include \"~a.h\""</span> (create-include (id li))))


</pre>
</div>

<p>
The code:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((code code) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (top-decls funcs) code
    (emit <span style="color: #8b2252;">"~a"</span> (pp funcs #'(<span style="color: #a020f0;">lambda</span> (x) (gen-func-decl x gen)))
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a"</span> (gen top-decls gen)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a"</span> (gen funcs gen)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">""</span>)))


</pre>
</div>

<p>
Generate function declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-func-decl</span> ((f func) (gen cpp-generator))
  (<span style="color: #a020f0;">when</span> (not (or (exported-p f gen) (kernel-func-p f)))
    (gen-func-decl-2 f gen)))



</pre>
</div>


<p>
Type declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((td typedef) (gen cpp-generator))
  (<span style="color: #a020f0;">when</span> (not (exported-p td gen))
    (gen-typedef td gen)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-typedef</span> (td gen)
  (<span style="color: #a020f0;">with-slots</span> (id fields) td
    (emit <span style="color: #8b2252;">"typedef struct __attribute__ ((packed)) {"</span>
          <span style="color: #8b2252;">"    ~a"</span> (gen-fields fields gen)
          <span style="color: #8b2252;">"} ~a;"</span> (gen id gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-fields</span> (fields gen)
  (emit-list fields <span style="color: #483d8b;">:nr-lines</span> 1 <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen-field x gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-field</span> (field gen)
  (emit <span style="color: #8b2252;">"~a;"</span> (gen field gen)))
</pre>
</div>

<p>
Declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((nd normal-decl) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (modifiers basic-decls) nd
    (emit <span style="color: #8b2252;">"~a~a"</span> (gen (remove-modifiers-cpp modifiers) gen)
          (gen (first basic-decls) gen))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ad assign-decl) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (modifiers basic-decl expr) ad
    (emit <span style="color: #8b2252;">"~a~a = ~a"</span>
          (gen (remove-modifiers-cpp modifiers) gen)
          (gen basic-decl gen)
          (gen expr gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-modifiers-cpp</span> (modifiers)
  (remove-if (complement #'(<span style="color: #a020f0;">lambda</span> (x) (not (typep x 'user-defined)))) modifiers))
</pre>
</div>

<p>
Basic declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((bd basic-decl) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (<span style="color: #a020f0;">cond</span>
      ((or (primitive-decl-p bd) (typep mcl-type 'custom-type))
       (emit <span style="color: #8b2252;">"~a ~a"</span> (gen mcl-type gen) (gen id gen)))
      ((typep mcl-type 'array-type)
       (generate-dynamic-array bd gen))
      (t
       (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Not a primitive, array-, or custom-type"</span>)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-dynamic-array</span> (bd gen)
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (emit <span style="color: #8b2252;">"~a *~a = aligned_new&lt;~a&gt;(~a, 32)"</span> 
          (pp-base-type mcl-type (get-gen gen))
          (gen id gen)
          (pp-base-type mcl-type (get-gen gen))
          (gen (first (sizes mcl-type)) gen))))
</pre>
</div>


<p>
Expressions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((p pow) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (l r) p
    (<span style="color: #a020f0;">if</span> (ast= r (ast-mcpl:make-int-constant 2))
        (gen (make-mul l l) gen)
        (emit <span style="color: #8b2252;">"pow(~a, ~a)"</span> (gen l gen) (gen r gen)))))
</pre>
</div>

<p>
Functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((f func) (gen cpp-generator))
  (<span style="color: #a020f0;">unless</span> (or (kernel-func-p f) (builtin-func-p f))
    (<span style="color: #a020f0;">with-slots</span> (mcl-type id params code-block) f
      (emit <span style="color: #8b2252;">"~a ~a(~a) ~a"</span> (gen mcl-type gen)
            (gen id gen)
            (gen-params params gen)
            (<span style="color: #a020f0;">if</span> (and (member (name id) (entry-funcs gen) <span style="color: #483d8b;">:test</span> #'string=))
                (gen-entry-code-block code-block gen)
                (gen code-block gen))))))
</pre>
</div>

<p>
The following method tests whether a codeblock has functions that call kernels,
if so, it creates the OpenCL wrapping code.  However, this is not sufficient
for modules with separate functions with kernel calls:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((cb code-block) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (stats) cb
    (<span style="color: #a020f0;">with-slots</span> (kernels-file) gen
      (<span style="color: #a020f0;">if</span> (remove-if (complement #'(<span style="color: #a020f0;">lambda</span> (x)
                                     (and (typep x 'call-stat) (kernel-func-p (call x)))))
                     stats)
          (emit <span style="color: #8b2252;">"{"</span>
                <span style="color: #8b2252;">"    vector&lt;std::string&gt; macros;"</span>
                <span style="color: #8b2252;">"    try {"</span>
                <span style="color: #8b2252;">"        opencl::compile(\"~a/~a\", macros, CL_DEVICE_TYPE_GPU);"</span>
                (module-dir kernels-file) (base-filename kernels-file)
                <span style="color: #8b2252;">""</span>
                <span style="color: #8b2252;">"        ~a"</span> (gen stats gen)
                <span style="color: #8b2252;">"        opencl::sync();"</span>
                <span style="color: #8b2252;">"    }"</span>
                <span style="color: #8b2252;">"    catch (cl::Error &amp;err) {"</span>
                <span style="color: #8b2252;">"        std::cerr &lt;&lt; \"ERROR: \" &lt;&lt; err.what() &lt;&lt; \" (\" &lt;&lt;"</span>
                <span style="color: #8b2252;">"        opencl::resolveErrorCode(err.err()) \&lt;\&lt; \")\" \&lt;\&lt; std::endl;"</span>
                <span style="color: #8b2252;">"        throw std::exception();"</span>
                <span style="color: #8b2252;">"    }"</span>
                <span style="color: #8b2252;">"}"</span>)
          (call-next-method)))))
</pre>
</div>

<p>
The following function places this wrapper code only if the function is the
entry-point:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-entry-code-block</span> (cb gen)
  (<span style="color: #a020f0;">with-slots</span> (stats) cb
    (<span style="color: #a020f0;">with-slots</span> (kernels-file) gen
      (emit <span style="color: #8b2252;">"{"</span>
            <span style="color: #8b2252;">"    vector&lt;std::string&gt; macros;"</span>
            <span style="color: #8b2252;">"    try {"</span>
            <span style="color: #8b2252;">"        opencl::compile(\"~a/~a\", macros, CL_DEVICE_TYPE_GPU);"</span>
            (module-dir kernels-file) (base-filename kernels-file)
            <span style="color: #8b2252;">""</span>
            <span style="color: #8b2252;">"        ~a"</span> (gen stats gen)
            <span style="color: #8b2252;">"        opencl::sync();"</span>
            <span style="color: #8b2252;">"    }"</span>
            <span style="color: #8b2252;">"    catch (cl::Error &amp;err) {"</span>
            <span style="color: #8b2252;">"        std::cerr &lt;&lt; \"ERROR: \" &lt;&lt; err.what() &lt;&lt; \" (\" &lt;&lt;"</span>
            <span style="color: #8b2252;">"        opencl::resolveErrorCode(err.err()) \&lt;\&lt; \")\" \&lt;\&lt; std::endl;"</span>
            <span style="color: #8b2252;">"        throw std::exception();"</span>
            <span style="color: #8b2252;">"    }"</span>
            <span style="color: #8b2252;">"}"</span>))))
</pre>
</div>



<p>
The following code transforms a <code>sincos</code> function into something that is
suitable for C++.  It uses GNU extensions.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((as assign-stat) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (var expr) as
    (<span style="color: #a020f0;">if</span> (and (typep expr 'call-expr)
             (string= (name (id (call expr))) <span style="color: #8b2252;">"sincos"</span>))
        (gen-cpp-sincos as gen)
        (call-next-method))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-cpp-sincos</span> (assign-stat gen)
  (<span style="color: #a020f0;">with-slots</span> (var expr) assign-stat
    (<span style="color: #a020f0;">let</span> ((call (call expr)))
      (<span style="color: #a020f0;">with-slots</span> (id params) call
        (emit <span style="color: #8b2252;">"~a((double) ~a, (double *) &amp;~a, (double *) ~a);"</span>
              (name id)
              (gen (first params) gen)
              (gen var gen)
              (gen (second params) gen))))))
</pre>
</div>








<p>
Calls:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((cs call-stat) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (call) cs
    (<span style="color: #a020f0;">if</span> (kernel-func-p (call cs))
        (gen call gen)
        (call-next-method))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((c call) (gen cpp-generator))
  (<span style="color: #a020f0;">if</span> (kernel-func-p c)
      (gen-opencl-call c gen)
      (<span style="color: #a020f0;">with-slots</span> (codegen-info) gen
        (<span style="color: #a020f0;">with-slots</span> (id params) c
          (acond ((builtin-func-p c)
                  (gen-builtin c gen))
                 ((get-codegen-builtin c codegen-info)
                  (gen-builtin-codegen c it gen))
                 (t
                  (call-next-method)))))))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-builtin</span> ((c call) (gen cpp-generator))
  (<span style="color: #a020f0;">with-slots</span> (params id) c
    (string-case ((name id) <span style="color: #483d8b;">:default</span> (call-next-method))
      (<span style="color: #8b2252;">"mcl_builtin_read"</span> <span style="color: #8b2252;">""</span>)
      (<span style="color: #8b2252;">"mcl_builtin_write"</span> <span style="color: #8b2252;">""</span>)
      (<span style="color: #8b2252;">"mcl_builtin_allocate_on_device"</span> 
       (gen-allocate/transfer params <span style="color: #8b2252;">"allocate"</span> gen))
      (<span style="color: #8b2252;">"mcl_builtin_deallocate_on_device"</span>
       (gen-deallocate params gen))
      (<span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span>
       (gen-allocate/transfer params <span style="color: #8b2252;">"transferToDevice"</span> gen))
      (<span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span>
       (gen-transfer-from-device params gen)))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-builtin-codegen</span> (call name-func gen)
  (emit <span style="color: #8b2252;">"~a(~a)"</span> name-func (gen-params (params call) gen)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-codegen-builtin</span> (ast codegen-info))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-codegen-builtin</span> ((c call) codegen-info)
  (get-codegen-builtin (id c) codegen-info))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-codegen-builtin</span> ((id id) codegen-info)
  (cdr (assoc (name id) (getf codegen-info <span style="color: #483d8b;">:builtin-funcs</span>))))

</pre>
</div>

<p>
Generating an allocate:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-allocate/transfer</span> (params allocate/transfer gen)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (eql (length params) 1))
  (<span style="color: #a020f0;">let</span> ((param (first params)))
    (emit <span style="color: #8b2252;">"opencl::~a(~a, ~a, ~a)"</span>
          allocate/transfer
          (gen param gen)
          (<span style="color: #a020f0;">if</span> (written-in-kernel-p param) <span style="color: #8b2252;">"opencl::READ_WRITE"</span> <span style="color: #8b2252;">"opencl::READ"</span>)
          (gen (get-size param) gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-transfer-from-device</span> (params gen)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (eql (length params) 1))
  (<span style="color: #a020f0;">let</span> ((param (first params)))
    (emit <span style="color: #8b2252;">"opencl::transferFromDevice(~a)"</span>
          (gen param gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-deallocate</span> (params gen)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (eql (length params) 1))
  (<span style="color: #a020f0;">let</span> ((param (first params)))
    (emit <span style="color: #8b2252;">"opencl::deallocate(~a)"</span>
          (gen param gen))))

</pre>
</div>

<p>
Getting the size of variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-size</span> (expr-var-decl-or-type)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"Get the size of an expression, variable or declaration."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size</span> ((e expr))
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep e 'var-expr))
  (get-size (var e)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size</span> ((v var))
  (get-size  (get-decl-var v)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size</span> ((d decl))
  (get-size (get-type d)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size</span> ((type mcl-type))
  (<span style="color: #a020f0;">etypecase</span> type
    (void (make-int-constant 4))
    (int (make-int-constant 4))
    (flt (make-int-constant 4))
    (bool (make-int-constant 1))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size</span> ((type custom-type))
  (get-size (typedef type)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size</span> ((td typedef))
  (reduce #'(<span style="color: #a020f0;">lambda</span> (result field) (make-add result (get-size field)))
          (fields td) <span style="color: #483d8b;">:initial-value</span> (make-int-constant 0)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-size</span> ((at array-type))
  (<span style="color: #a020f0;">with-slots</span> (base-type sizes) at
    (make-mul (get-size base-type) (size (first sizes)))))
</pre>
</div>

<p>
Whether a parameter for an OpenCL kernel will be written in the kernel:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">written-in-kernel-p</span> (expr)
  (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep expr 'var-expr))
  (not (constant-p (get-decl-var (var expr)))))
</pre>
</div>

<p>
Generating an OpenCL call:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-opencl-call</span> (c gen)
  (emit <span style="color: #8b2252;">"~a"</span> (gen-macros c gen)
        <span style="color: #8b2252;">"~a"</span> (gen-opencl-args c gen)
        <span style="color: #8b2252;">"~a"</span> (gen-opencl-launch c gen)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-opencl-args</span> (c gen)
  (<span style="color: #a020f0;">with-slots</span> (id params) c
    (emit-list params <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen-opencl-arg id x gen)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-opencl-arg</span> (id p gen)
  (emit <span style="color: #8b2252;">"opencl::setArg(\"~a\", ~a);"</span> (name id) (gen p gen)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-macros</span> (c gen)
  (<span style="color: #a020f0;">declare</span> (ignore c gen))
  <span style="color: #8b2252;">""</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-opencl-launch</span> (c gen)
  (<span style="color: #a020f0;">let*</span> ((func (func c))
         (foreach (first (stats (code-block func))))
         (local-range-exprs (get-range-exprs foreach <span style="color: #8b2252;">"get_local_id"</span> gen))
         (group-range-exprs (get-group-range-exprs foreach
                                                   local-range-exprs gen)))
    (emit <span style="color: #8b2252;">"std::cerr &lt;&lt; \"launch(~a, \""</span> (name (id c))
          <span style="color: #8b2252;">"          &lt;&lt; \"(\" &lt;&lt; ~a &lt;&lt; \"), \""</span>
          (gen-range-exprs group-range-exprs <span style="color: #8b2252;">" &lt;&lt; \", \" &lt;&lt; "</span> gen)
          <span style="color: #8b2252;">"          &lt;&lt; \"(\" &lt;&lt; ~a &lt;&lt; \"))\""</span>
          (gen-range-exprs local-range-exprs <span style="color: #8b2252;">" &lt;&lt; \", \" &lt;&lt; "</span> gen)
          <span style="color: #8b2252;">"          &lt;&lt; std::endl;"</span>
          <span style="color: #8b2252;">"opencl::launch(\"~a\","</span> (name (id c))
          <span style="color: #8b2252;">"    NDRange(~a),"</span>
          (gen-range-exprs group-range-exprs <span style="color: #8b2252;">", "</span> gen)
          <span style="color: #8b2252;">"    NDRange(~a));"</span>
          (gen-range-exprs local-range-exprs <span style="color: #8b2252;">", "</span> gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-range-exprs</span> (foreach l/g-id gen)
  (<span style="color: #a020f0;">let</span> ((exprs nil)
        (par-groups (getf (codegen-info gen) <span style="color: #483d8b;">:pargroups</span>)))
    (visit foreach
           (constantly t)
           #'(<span style="color: #a020f0;">lambda</span> (x)
               (<span style="color: #a020f0;">when</span> (typep x 'foreach-stat)
                 (<span style="color: #a020f0;">with-slots</span> (nr-iters par-group) x
                   (<span style="color: #a020f0;">let</span> ((l/g-id2 (second (assoc (name par-group) par-groups
                                                 <span style="color: #483d8b;">:test</span> #'string=))))
                     (<span style="color: #a020f0;">when</span> (string= l/g-id l/g-id2)
                       (push nr-iters exprs)))))))
    (subseq (append (reverse exprs)
                    (list (make-int-constant 1)
                          (make-int-constant 1)
                          (make-int-constant 1)))
            0 3)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-group-range-exprs</span> (foreach local-range-exprs gen)
  (<span style="color: #a020f0;">let</span> ((group-range-exprs (get-range-exprs foreach <span style="color: #8b2252;">"get_group_id"</span> gen)))
    (mapcar #'make-mul local-range-exprs group-range-exprs)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-range-exprs</span> (exprs separator gen)
  (emit-list exprs <span style="color: #483d8b;">:separator</span> separator <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen))))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgaba9ee7" class="outline-4">
<h4 id="orgaba9ee7"><span class="section-number-4">7.5.7</span> Generate C++ header</h4>
<div class="outline-text-4" id="text-7-5-7">
</div>

<div id="outline-container-orgc02986f" class="outline-5">
<h5 id="orgc02986f"><span class="section-number-5">7.5.7.1</span> Creating the generator</h5>
<div class="outline-text-5" id="text-7-5-7-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-header</span> (module gen)
  (change-class gen 'header-generator)
  (gen module gen)
  (change-class gen 'cpp-generator))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">header-generator</span> (cpp-generator)
  ())
</pre>
</div>
</div>
</div>

<div id="outline-container-org57de981" class="outline-5">
<h5 id="org57de981"><span class="section-number-5">7.5.7.2</span> The gen-* functions</h5>
<div class="outline-text-5" id="text-7-5-7-2">
<p>
The module:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((module module) (gen header-generator))
  (<span style="color: #a020f0;">with-slots</span> ((outputfile header-file) exports) gen
    (<span style="color: #a020f0;">with-slots</span> (header contents footer) outputfile
      (<span style="color: #a020f0;">with-slots</span> (imports code) module
        (format header (create-ifdefs module))
        (format contents (gen imports gen))
        (format contents (gen code gen))
        (format footer <span style="color: #8b2252;">"#endif~%"</span>)))))
</pre>
</div>

<p>
The code:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((code code) (gen header-generator))
  (<span style="color: #a020f0;">with-slots</span> (top-decls funcs) code
    (emit <span style="color: #8b2252;">"~a"</span> (gen top-decls gen)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a"</span> (gen funcs gen)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">""</span>)))
</pre>
</div>


<p>
Creating ifdefs:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-ifdefs</span> (module)
  (<span style="color: #a020f0;">let</span> ((define (create-define module)))
    (emit <span style="color: #8b2252;">"#ifndef ~a_H"</span> define 
          <span style="color: #8b2252;">"#define ~a_H"</span> define
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">""</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-define</span> (module)
  (<span style="color: #a020f0;">with-slots</span> (pkg id) module
    (emit <span style="color: #8b2252;">"~a_~a"</span> (create-define-pkg pkg) (string-upcase (name id)))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">create-define-pkg</span> (qual-id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">create-define-pkg</span> ((id id))
  (string-upcase (name id)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">create-define-pkg</span> ((ci compound-id))
  (<span style="color: #a020f0;">with-slots</span> (name compound) ci
    (emit <span style="color: #8b2252;">"~a_~a"</span> (string-upcase name) (create-define-pkg compound))))
</pre>
</div>

<p>
Imports:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((import lib-import) (gen header-generator))
  (<span style="color: #a020f0;">declare</span> (ignore gen))
  (<span style="color: #a020f0;">with-slots</span> (id) import
    (<span style="color: #a020f0;">if</span> (hardware-descriptions:hardware-description-p id)
        <span style="color: #8b2252;">""</span>
        (emit <span style="color: #8b2252;">"#include \"~a.h\""</span> (create-include id)))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">create-include</span> (id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">create-include</span> ((id id))
  (name id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">create-include</span> ((ci compound-id))
  (<span style="color: #a020f0;">with-slots</span> (name compound) ci
    (format nil <span style="color: #8b2252;">"~a/~a"</span> name (create-include compound))))
</pre>
</div>

<p>
Constant declaration:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((cd const-decl) (gen header-generator))
  (<span style="color: #a020f0;">when</span> (exported-p cd gen)
    (gen-const-decl cd gen)))
</pre>
</div>

<p>
Type declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((td typedef) (gen header-generator))
  (<span style="color: #a020f0;">when</span> (exported-p td gen)
    (gen-typedef td gen)))
</pre>
</div>

<p>
Functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((f func) (gen header-generator))
  (<span style="color: #a020f0;">when</span> (exported-p f gen)
    (<span style="color: #a020f0;">unless</span> (builtin-func-p f)
      (gen-func-decl-2 f gen))))
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-org37d2854" class="outline-4">
<h4 id="org37d2854"><span class="section-number-4">7.5.8</span> Generate Cashmere code</h4>
<div class="outline-text-4" id="text-7-5-8">
</div>

<div id="outline-container-org1599c1a" class="outline-5">
<h5 id="org1599c1a"><span class="section-number-5">7.5.8.1</span> Creating the generator</h5>
<div class="outline-text-5" id="text-7-5-8-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">cashmere-generator</span> (kernel-generator
                              exports-generator entry-funcs-generator)
  ())

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-cashmere-generator</span> (exports kernels-file codegen-info entry-funcs
                                callgraph)
  (make-instance 'cashmere-generator
                 <span style="color: #483d8b;">:exports</span> exports
                 <span style="color: #483d8b;">:kernels-file</span> kernels-file
                 <span style="color: #483d8b;">:entry-funcs</span> entry-funcs
                 <span style="color: #483d8b;">:codegen-info</span> codegen-info
                 <span style="color: #483d8b;">:callgraph</span> callgraph))

</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-cashmere-generator</span> (module codegen-info entry-funcs output-dir
                                  callgraph )
  (<span style="color: #a020f0;">let</span> ((module-dir <span style="color: #8b2252;">"."</span>)
        (name-module (name (id module))))
    (make-cashmere-generator
     (exports module)
     (make-output-file output-dir module-dir name-module <span style="color: #8b2252;">".cl"</span>)
     codegen-info
     entry-funcs
     callgraph)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0465436" class="outline-5">
<h5 id="org0465436"><span class="section-number-5">7.5.8.2</span> The gen-* methods</h5>
<div class="outline-text-5" id="text-7-5-8-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">cashmere-info</span> ()
  ((module <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:module</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply module"</span>)
           <span style="color: #483d8b;">:reader</span> module)
   (default-func <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:default-func</span>
     <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply default-func"</span>)
     <span style="color: #483d8b;">:reader</span> default-func)
   (copy-func-header <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:copy-func-header</span>
                     <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply copy-func-header"</span>)
                     <span style="color: #483d8b;">:reader</span> copy-func-header)
   (set-argument <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:set-argument</span>
                 <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply set-argument"</span>)
                 <span style="color: #483d8b;">:reader</span> set-argument)
   (call-conditions <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:call-conditions</span>
                    <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Must supply call-conditions"</span>)
                    <span style="color: #483d8b;">:accessor</span> call-conditions)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-cashmere-info</span> (module default-func copy-func-header
                           set-argument call-conditions)
  (make-instance 'cashmere-info
                 <span style="color: #483d8b;">:module</span> module
                 <span style="color: #483d8b;">:default-func</span> default-func
                 <span style="color: #483d8b;">:copy-func-header</span> copy-func-header
                 <span style="color: #483d8b;">:set-argument</span> set-argument
                 <span style="color: #483d8b;">:call-conditions</span> call-conditions))
</pre>
</div>

<p>
This is the entry point for generating OpenCL code and <code>cashmere-info</code> given a
module.  We create several <code>cashmere-info</code>'s to allow kernel calls to be made
with both array-types in Java as with the <code>Buffer</code> and <code>Pointer</code> type.  We
therefore generate several versions of the entry function where we replace the
array-types with Buffer or Pointer types.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((module module) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (kernels-file entry-funcs) gen
    (generate-target-comment gen)
    (generate-opencl module gen)
    (change-class gen 'cashmere-generator)
    (<span style="color: #a020f0;">when</span> (funcs-in-module-p entry-funcs module)
      (write-output kernels-file)
      (get-cashmere-infos module (get-kernel-func module entry-funcs) gen))))
</pre>
</div>

<p>
The following function creates several <code>alternative-entry-funcs</code> from the
<code>entry-func</code> with the parameters having the array-types replaced with <code>Buffer</code>
or <code>Pointer</code> types (all combinations). 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-cashmere-infos</span> (module entry-func gen)
  (<span style="color: #a020f0;">let</span> ((name (name (id module)))
        (arguments (generate-set-arguments (params entry-func)))
        (run-config (list (generate-run-configuration entry-func gen)))
        (alternative-entry-funcs (create-alternative-entry-funcs
                                  entry-func '(<span style="color: #8b2252;">"Buffer"</span> <span style="color: #8b2252;">"Pointer"</span>))))
    (<span style="color: #a020f0;">loop</span> for alternative-entry-func in alternative-entry-funcs collect
         (make-cashmere-info
          name 
          (generate-default-func alternative-entry-func gen)
          (generate-copy-func-header alternative-entry-func gen)
          arguments
          run-config))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">array-type-param-p</span> (param)
  (typep (get-type-decl param) 'array-type))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-alternative-entry-funcs</span> (entry-func alternatives)
  (<span style="color: #a020f0;">loop</span> for type-spec in
       (cartesian-product
        (apply #'mapcar #'list (get-alternative-types entry-func alternatives)))
     collect (create-alternative-entry-func entry-func type-spec)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-alternative-types</span> (entry-func alternatives)
  (<span style="color: #a020f0;">let</span> ((types-for-alternatives (get-types-for-alternatives entry-func)))
    (cons types-for-alternatives
          (<span style="color: #a020f0;">loop</span> for alternative in alternatives
             collect (mapcar (constantly
                              (make-custom-type (make-id alternative) ())) 
                             types-for-alternatives)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-types-for-alternatives</span> (entry-func)
  (<span style="color: #a020f0;">let</span> ((array-type-params
         (remove-if (complement #'type-for-alternative-p) (params entry-func))))
    (mapcar #'get-type-decl array-type-params)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">type-for-alternative-p</span> (param)
  (or (array-type-param-p param)
      (and (primitive-decl-p param) (param-written-p param))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-alternative-entry-func</span> (entry-func type-spec)
  (<span style="color: #a020f0;">let</span> ((copy-entry-func (copy-ast entry-func)))
    (complete-copy copy-entry-func entry-func)
    (<span style="color: #a020f0;">loop</span>
       for type-for-alternative in (get-types-for-alternatives copy-entry-func)
       for new-type in type-spec
       do (replace-in-ast type-for-alternative <span style="color: #483d8b;">:with</span> new-type))
    copy-entry-func))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">complete-copy</span> (copy original)
  (set-parents:set-parents copy)
  (set-decls-basic-decls (params copy))
  (set-params-written (params copy) (params original)))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-decls-basic-decls</span> (params)
  (<span style="color: #a020f0;">loop</span> for param in params do (set-decl-basic-decl param)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-decl-basic-decl</span> (param)
  (<span style="color: #a020f0;">let</span> ((basic-decl (get-basic-decl param)))
    (setf (decl basic-decl) param)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-params-written</span> (params-copy params-original)
  (<span style="color: #a020f0;">loop</span>
     for param-copy in params-copy
     for param-original in params-original
     do (setf (written param-copy) (written param-original))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-run-configuration</span> (func gen)
  (<span style="color: #a020f0;">let*</span> ((foreach (retrieve (code-block func)
                            #'(<span style="color: #a020f0;">lambda</span> (ast) (typep ast 'foreach-stat))))
         (local-range-exprs (get-range-exprs foreach <span style="color: #8b2252;">"get_local_id"</span> gen))
         (group-range-exprs (get-group-range-exprs foreach
                                                   local-range-exprs gen))
         (target (getf (codegen-info gen) <span style="color: #483d8b;">:target</span>)))
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "~a~%" (print-pretty:pp group-range-exprs))</span>
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "~a~%" (print-pretty:pp local-range-exprs))</span>
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "~a~%" (print-pretty:pp func))</span>
    (list (emit <span style="color: #8b2252;">"kl.getDeviceName().equals(\"~a\")"</span> target)
          (mapcar  #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen)) (siblings-before foreach))
          (emit <span style="color: #8b2252;">"kl.launch(~a, ~a)"</span>
                (gen-range-exprs group-range-exprs <span style="color: #8b2252;">", "</span> gen)
                (gen-range-exprs local-range-exprs <span style="color: #8b2252;">", "</span> gen)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ad assign-decl) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (basic-decl expr) ad
    (emit <span style="color: #8b2252;">"~a = ~a"</span>
          (gen basic-decl gen)
          (gen expr gen))))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((nv normal-var) (gen cashmere-generator))
  (gen (basic-var nv) gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((bv basic-var) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (array-exprs basic-decl) bv
    (<span style="color: #a020f0;">with-slots</span> (decl) basic-decl
      (<span style="color: #a020f0;">let</span> ((array-expr-string
             (<span style="color: #a020f0;">if</span> array-exprs (emit <span style="color: #8b2252;">"[~a]"</span> (gen (first array-exprs) gen)) <span style="color: #8b2252;">""</span>)))
        (emit <span style="color: #8b2252;">"~a~a"</span> (gen (get-id decl) gen) array-expr-string)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param</span> ((s string) (gen cashmere-generator))
  s)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param</span> ((nd normal-decl) (gen cashmere-generator))
  (gen-param (first (basic-decls nd)) gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param</span> ((bd basic-decl) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (<span style="color: #a020f0;">with-slots</span> (name) id
      (<span style="color: #a020f0;">if</span> (primitive-decl-p bd)
          (<span style="color: #a020f0;">if</span> (param-written-p bd)
              (emit <span style="color: #8b2252;">"~a[] ~a"</span> (gen mcl-type gen) name)
              (emit <span style="color: #8b2252;">"~a ~a"</span> (gen mcl-type gen) name))
          (emit <span style="color: #8b2252;">"~a ~a"</span> (gen mcl-type gen) name)))))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((const const) (gen cashmere-generator))
  <span style="color: #8b2252;">""</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ud user-defined) (gen cashmere-generator))
  <span style="color: #8b2252;">""</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((b bool) (gen cashmere-generator))
  <span style="color: #8b2252;">"boolean"</span>)



(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((array-type array-type) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (base-type) array-type
    (<span style="color: #a020f0;">if</span> (primitive-type-p base-type)
        (emit <span style="color: #8b2252;">"~a[]"</span> (gen base-type gen))
        (gen base-type gen))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ct custom-type) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (id typedef) ct
    (<span style="color: #a020f0;">with-slots</span> (name) id
      (<span style="color: #a020f0;">if</span> (or (string= name <span style="color: #8b2252;">"Buffer"</span>) (string= name <span style="color: #8b2252;">"Pointer"</span>))
          (emit <span style="color: #8b2252;">"~a"</span> name)
          (<span style="color: #a020f0;">with-slots</span> (fields) typedef
            (<span style="color: #a020f0;">destructuring-bind</span> (f <span style="color: #228b22;">&amp;rest</span> r) fields
              (<span style="color: #a020f0;">let</span> ((type-f (get-type-decl f)))
                (<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">loop</span> for type in (mapcar #'get-type-decl r)
                       always (ast= type-f type))
                    (emit <span style="color: #8b2252;">"~a[]"</span> (gen type-f gen))
                    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Custom type ~a incompatible with Cashmere"</span>
                           name)))))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((b mcl-byte) (gen cashmere-generator))
  (emit <span style="color: #8b2252;">"byte"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((bd basic-decl) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (emit <span style="color: #8b2252;">"~a ~a"</span> (gen mcl-type gen) (gen id gen))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((c call) (gen cashmere-generator))
  (<span style="color: #a020f0;">if</span> (builtin-func-p c)
      (gen-builtin c gen)
      (call-next-method)))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-builtin</span> ((c call) (gen cashmere-generator))
  (<span style="color: #a020f0;">with-slots</span> (params id) c
    (string-case ((name id))
      (<span style="color: #8b2252;">"toFloat"</span>
       (emit <span style="color: #8b2252;">"(float) ~a"</span> (gen (first params) gen)))
      (<span style="color: #8b2252;">"min"</span>
       (emit <span style="color: #8b2252;">"Math.min(~a)"</span> (emit-list params <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
                                  <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen x gen)))))
      (<span style="color: #8b2252;">"divide_up"</span> (gen-divide-up params gen)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-kernel-func</span> (module entry-funcs)
  (retrieve-all module
                #'(<span style="color: #a020f0;">lambda</span> (ast)
                    (and (typep ast 'func)
                         (string= (format nil <span style="color: #8b2252;">"~aKernel"</span> (first entry-funcs))
                                  (name (id ast)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-set-arguments</span> (params)
  (emit-list params <span style="color: #483d8b;">:function</span> #'gen-cashmere-arg))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-cashmere-arg</span> (param)
  (<span style="color: #a020f0;">let</span> ((is-out (not (member (make-const) (modifiers param) <span style="color: #483d8b;">:test</span> #'ast=)))
        (is-in (loaded param))
        (is-primitive (primitive-decl-p param))
        (name (name (get-id param))))
    (<span style="color: #a020f0;">if</span> (and is-primitive (not is-out)) (emit <span style="color: #8b2252;">"kl.setArgument(~a, Argument.Direction.IN);"</span> name)
        (<span style="color: #a020f0;">let</span> ((dir (<span style="color: #a020f0;">if</span> is-out
                       (<span style="color: #a020f0;">if</span> is-in
                           <span style="color: #8b2252;">"Argument.Direction.INOUT"</span>
                           <span style="color: #8b2252;">"Argument.Direction.OUT"</span>)
                       <span style="color: #8b2252;">"Argument.Direction.IN"</span>)))
          (emit <span style="color: #8b2252;">"if (copy~a) {"</span> name
                <span style="color: #8b2252;">"    kl.setArgument(~a, ~a);"</span> name dir
                <span style="color: #8b2252;">"}"</span>
                <span style="color: #8b2252;">"else {"</span>
                <span style="color: #8b2252;">"    kl.setArgumentNoCopy(~a);"</span> name
                <span style="color: #8b2252;">"}"</span>)))))



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-default-func</span> (func gen)
  (<span style="color: #a020f0;">let</span> ((launch-name (gen-launch-name func))
        (params (params func)))
    (emit <span style="color: #8b2252;">"static void ~a(~a) throws MCCashmereNotAvailable {"</span>
          launch-name
          (gen-default-params params gen)
          <span style="color: #8b2252;">"    ~a(kl, ~a);"</span> launch-name (gen-param-exprs (add-copy-params
                                                      params))
          <span style="color: #8b2252;">"}"</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-copy-func-header</span> (func gen)
  (<span style="color: #a020f0;">let</span> ((launch-name (gen-launch-name func))
        (params (params func)))
    (emit <span style="color: #8b2252;">"static void ~a(~a) throws MCCashmereNotAvailable"</span>
          launch-name
          (gen-default-params (add-copy-params params) gen))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-copy-params</span> (params)
  (<span style="color: #a020f0;">let</span> (with-copy-params)
    (<span style="color: #a020f0;">loop</span> for p in params
       do (<span style="color: #a020f0;">if</span> (and (primitive-decl-p p)
                   (not (param-written-p p)))
              (<span style="color: #a020f0;">progn</span>
                (push p with-copy-params))
              (<span style="color: #a020f0;">progn</span>
                (push p with-copy-params)
                (push (make-copy-boolean p) with-copy-params))))
    (nreverse with-copy-params)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-param-exprs</span> (params)
  (emit-list params <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
             <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen-param-expr x))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-param-expr</span> (param)
  (<span style="color: #a020f0;">let</span> ((name (name (get-id param))))
    (<span style="color: #a020f0;">if</span> (and (typep (get-type-decl param) 'bool)
             (string= name <span style="color: #8b2252;">"copy"</span> <span style="color: #483d8b;">:end1</span> (min 4 (length name))))
        <span style="color: #8b2252;">"true"</span>
        name)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-copy-boolean</span> (param)
  (<span style="color: #a020f0;">let*</span> ((name (format nil <span style="color: #8b2252;">"copy~a"</span> (name (get-id param))))
         (bd (make-basic-decl (make-bool) (make-id name)))
         (d (make-normal-decl nil (list bd))))
    (setf (decl bd) d)
    (setf (parent d) (parent param))
    d))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-launch-name</span> (func)
  (format nil <span style="color: #8b2252;">"launch~a"</span> (capitalize (name (id func)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">capitalize</span> (s)
  (string-upcase s <span style="color: #483d8b;">:start</span> 0 <span style="color: #483d8b;">:end</span> 1))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-default-params</span> (params gen)
  (gen-params params gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-params</span> (params (gen cashmere-generator))
  (emit-list (cons <span style="color: #8b2252;">"KernelLaunch kl"</span> params)
             <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
             <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (gen-param x gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-target-comment</span> (gen)
  (<span style="color: #a020f0;">with-slots</span> (codegen-info kernels-file) gen
    (<span style="color: #a020f0;">with-slots</span> (header) kernels-file
      (format header <span style="color: #8b2252;">"// ~a~%"</span> (getf codegen-info <span style="color: #483d8b;">:target</span>)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd5c5994" class="outline-4">
<h4 id="orgd5c5994"><span class="section-number-4">7.5.9</span> Generate OpenCL code</h4>
<div class="outline-text-4" id="text-7-5-9">
</div>

<div id="outline-container-orgbe91b56" class="outline-5">
<h5 id="orgbe91b56"><span class="section-number-5">7.5.9.1</span> Creating the generator</h5>
<div class="outline-text-5" id="text-7-5-9-1">
<p>
The OpenCL generator builds on the C++ generator.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-opencl</span> (module gen)
  (change-class gen 'opencl-generator)
  (gen module gen))



(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">opencl-generator</span> (c-base-generator kernel-generator exports-generator
                                             entry-funcs-generator)
  ((typedefs <span style="color: #483d8b;">:initform</span> nil <span style="color: #483d8b;">:accessor</span> typedefs)
   (global-constants <span style="color: #483d8b;">:initform</span> nil <span style="color: #483d8b;">:accessor</span> global-constants)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org70a5971" class="outline-5">
<h5 id="org70a5971"><span class="section-number-5">7.5.9.2</span> The gen-* functions</h5>
<div class="outline-text-5" id="text-7-5-9-2">
<p>
The module:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((module module) (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (kernels-file typedefs global-constants entry-funcs) gen
    (<span style="color: #a020f0;">when</span> (funcs-in-module-p entry-funcs module)
      (<span style="color: #a020f0;">with-slots</span> (contents header) kernels-file
        (<span style="color: #a020f0;">with-slots</span> (code imports) module
          (format contents (gen code gen))
          (format header (gen typedefs gen))
          (format header (gen (remove-duplicates global-constants) gen)))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">funcs-in-module-p</span> (funcs module)
  (<span style="color: #a020f0;">loop</span> for f in funcs
     always (member f (funcs (code module))
                    <span style="color: #483d8b;">:test</span> #'string=
                    <span style="color: #483d8b;">:key</span> (compose #'name #'id))))
</pre>
</div>

<p>
The code:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((code code) (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (funcs) code
    (<span style="color: #a020f0;">let</span> ((funcs (get-opencl-funcs gen)))
      (emit <span style="color: #8b2252;">"~a"</span> (pp funcs #'(<span style="color: #a020f0;">lambda</span> (x) (gen-func-decl x gen)))
            <span style="color: #8b2252;">""</span>
            <span style="color: #8b2252;">"~a"</span> (gen funcs gen)
            <span style="color: #8b2252;">""</span>
            <span style="color: #8b2252;">""</span>))))
</pre>
</div>

<p>
The following code retrieves all functions that need to be included in the
OpenCL file:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-opencl-funcs</span> (gen)
  (get-many-core-funcs-ordered (callgraph gen)))

</pre>
</div>

<p>
Typedefs:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((td typedef) (gen opencl-generator))
  (gen-typedef td gen))
</pre>
</div>

<p>
When we encounter a custom type, the related typedef has to be generated as
well.  To do this, we put the typedef of a custom-type in the typedefs list of
the OpenCL generator.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ct custom-type) (gen opencl-generator))
  (pushnew (typedef ct) (typedefs gen))
  (call-next-method))
</pre>
</div>

<p>
Functions: 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((f func) (gen opencl-generator))
  (<span style="color: #a020f0;">unless</span> (builtin-func-p f)
    (<span style="color: #a020f0;">with-slots</span> (mcl-type id params code-block) f
      (emit <span style="color: #8b2252;">"~a~a ~a(~a) ~a"</span>
            (<span style="color: #a020f0;">if</span> (kernel-func-p f) <span style="color: #8b2252;">"__kernel "</span> <span style="color: #8b2252;">""</span>)
            (gen mcl-type gen)
            (gen id gen)
            (gen-params params gen)
            (gen-opencl-block code-block gen)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-func-decl</span> ((f func) (gen opencl-generator))
  (<span style="color: #a020f0;">unless</span> (or (builtin-func-p f) (kernel-func-p f))
    (gen-func-decl-2 f gen)))
</pre>
</div>

<p>
Declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((nd normal-decl) (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (modifiers basic-decls) nd
    (<span style="color: #a020f0;">let</span> ((modifiers (get-modifiers modifiers gen)))
      (<span style="color: #a020f0;">if</span> modifiers
          (emit <span style="color: #8b2252;">"~a ~a"</span> (emit-list modifiers <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">" "</span>)
                (<span style="color: #a020f0;">if</span> (find <span style="color: #8b2252;">"__local"</span> modifiers <span style="color: #483d8b;">:test</span> #'string=)
                    (gen-concrete-basic-decl (first basic-decls) gen)
                    (gen (first basic-decls) gen)))
          (emit <span style="color: #8b2252;">"~a"</span> (gen (first basic-decls) gen))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((ad assign-decl) (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (modifiers basic-decl expr) ad
    (<span style="color: #a020f0;">let</span> ((modifiers (get-modifiers modifiers gen)))
      (<span style="color: #a020f0;">if</span> modifiers
          (emit <span style="color: #8b2252;">"~a ~a = ~a"</span>
                (emit-list modifiers <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">" "</span>)
                (gen basic-decl gen)
                (gen expr gen))
          (emit <span style="color: #8b2252;">"~a = ~a"</span> (gen basic-decl gen) (gen expr gen))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-concrete-basic-decl</span> (bd gen)
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (<span style="color: #ff0000; font-weight: bold;">assert</span> (typep mcl-type 'array-type))
    (<span style="color: #a020f0;">with-slots</span> (base-type sizes) mcl-type
      (emit <span style="color: #8b2252;">"~a ~a[~a]"</span>
            (gen base-type gen) (gen id gen)
            (gen (make-concrete-expr (size (first sizes))) gen)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-concrete-expr</span> (expr)
  (<span style="color: #a020f0;">cond</span> ((member (type-of expr) '(int-constant float-constant bool-constant))
         expr)
        ((typep expr 'var-expr)
         (get-expr-var expr))
        ((binary-p expr)
         (<span style="color: #a020f0;">with-slots</span> (l r) expr
           (setf l (make-concrete-expr l))
           (setf r (make-concrete-expr r))
           expr))
        ((unary-p expr)
         (<span style="color: #a020f0;">with-slots</span> (e) expr
           (setf e (make-concrete-expr e))
           expr))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-expr-var</span> (var))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-var</span> ((ve var-expr))
  (aif (get-expr-var (var ve))
       it
       ve))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-var</span> ((nv normal-var))
  (get-expr-var (basic-var nv)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-var</span> ((bv basic-var))
  (get-expr-var (basic-decl bv)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-var</span> ((bd basic-decl))
  (get-expr-var (decl bd)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-var</span> ((nd normal-decl))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-expr-var</span> ((ad assign-decl))
  (expr ad))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((bd basic-decl) (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (<span style="color: #a020f0;">cond</span>
      ((or (primitive-decl-p bd) (typep mcl-type 'custom-type))
       (emit <span style="color: #8b2252;">"~a ~a"</span> (gen mcl-type gen) (gen id gen)))
      ((typep mcl-type 'array-type)
       (<span style="color: #a020f0;">with-slots</span> (base-type sizes) mcl-type
         (emit <span style="color: #8b2252;">"~a ~a[~a]"</span> (gen base-type gen) (gen id gen) (gen sizes gen))))
      (t
       (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Not a primitive, array-, or custom-type"</span>)))))
</pre>
</div>


<p>
For calls we have to take into account the builtin functions.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((c call) (gen opencl-generator))
  (<span style="color: #a020f0;">if</span> (builtin-func-p c)
      (gen-builtin c gen)
      (call-next-method)))
</pre>
</div>


<p>
For assignment statements, we have to prevent the C++ generator to generate its
code:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((as assign-stat) (gen opencl-generator))
  (do-pp as gen))
</pre>
</div>

<p>
A barrier statement depends on what the code generation info tells us:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((bs barrier-stat) (gen opencl-generator))
  (emit <span style="color: #8b2252;">"~a;"</span> (get-barrier-param (name (mem-space bs)) (codegen-info gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-barrier-param</span> (mem-space codegen-info)
  (third (assoc mem-space (getf codegen-info <span style="color: #483d8b;">:memory-spaces</span>) <span style="color: #483d8b;">:test</span> #'string=)))
</pre>
</div>

<p>
Variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen</span> ((nv normal-var) (gen opencl-generator))
  (<span style="color: #a020f0;">when</span> (global-constant-p nv)
    (push (parent (get-decl-var nv)) (global-constants gen)))
  (call-next-method))
</pre>
</div>

<p>
Blocks:
</p>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-opencl-block</span> (code-block gen)
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">(nconc stats (remove-foreach code-block))</span>
  (emit <span style="color: #8b2252;">"{"</span>
        <span style="color: #8b2252;">"    ~a"</span> (gen-iterators code-block gen)
        <span style="color: #8b2252;">""</span>
        <span style="color: #8b2252;">"    ~a"</span> (gen (remove-foreach code-block) gen)
        <span style="color: #8b2252;">"}"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-iterators</span> (code-block gen)
  (<span style="color: #a020f0;">let</span> ((iterators (list nil))
        (dimensions (create-dimensions (codegen-info gen))))
    (visit code-block
           #'(<span style="color: #a020f0;">lambda</span> (x) (find-foreach-fw x iterators dimensions gen))
           #'(<span style="color: #a020f0;">lambda</span> (x) (find-foreach-bw x iterators dimensions gen)))
    (first iterators)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">find-foreach-fw</span> (ast iterators dimension gen))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">find-foreach-bw</span> (ast iterators dimension gen))

(def-methods find-foreach-fw ((ast (ast list symbol string number))
                                 iterators dimension gen)
  t)

(def-methods find-foreach-bw ((ast (ast list symbol string number))
                                 iterators dimension gen)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-foreach-bw</span> ((fe foreach-stat) iterators dimensions gen)
  (<span style="color: #a020f0;">with-slots</span> (par-group decl) fe
    (<span style="color: #a020f0;">let</span> ((expr (create-expression (name par-group) dimensions gen))
          (decl (gen decl gen)))
      (push (emit <span style="color: #8b2252;">"~a = ~a;"</span> decl expr) (first iterators)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-expression</span> (pargroup dimensions gen)
  (<span style="color: #a020f0;">let*</span> ((codegen-info (codegen-info gen))
         (pargroups (getf codegen-info <span style="color: #483d8b;">:pargroups</span>))
         (name (second (assoc pargroup pargroups <span style="color: #483d8b;">:test</span> #'string=)))
         (dimension-info (assoc name (getf codegen-info <span style="color: #483d8b;">:dimensions</span>)
                                <span style="color: #483d8b;">:test</span> #'string=))
         (dim-nr (cdr (assoc name dimensions <span style="color: #483d8b;">:test</span> #'string=)))
         (dim (<span style="color: #a020f0;">if</span> (eq (get-type-dimension dimension-info) <span style="color: #483d8b;">:func</span>)
                  (do-func dim-nr)
                  (do-struct dim-nr))))
    (incf (cdr (assoc name dimensions <span style="color: #483d8b;">:test</span> #'string=)))
    (format nil <span style="color: #8b2252;">"~a~a"</span> name dim)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-func</span> (dim)
  (format nil <span style="color: #8b2252;">"(~a)"</span> dim))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-struct</span> (dim)
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"struct for opencl-code? ~a"</span> dim))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-foreach</span> (code-block)
  (<span style="color: #a020f0;">let</span> ((result (stats code-block)))
    (fixed-point result #'copy-list #'equal
      (setf result (remove-foreach2 result)))
    result))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-foreach2</span> (stats)
  (<span style="color: #a020f0;">let</span> ((result nil))
    (<span style="color: #a020f0;">loop</span> for s in stats
       do (<span style="color: #a020f0;">if</span> (typep s 'foreach-stat)
              (appendf result (stats (code-block (stat s))))
              (appendf result (list s))))
    result))
</pre>
</div>

<p>
The following function creates a mapping from dimension-string to the initial
dimension which is 0.  To do this, we retrieve the dimensions data-structure
from the code-generation information
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-dimensions</span> (codegen-info)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (x) (cons (get-dimension-name x) 0))
          (getf codegen-info <span style="color: #483d8b;">:dimensions</span>)))
</pre>
</div>




<p>
This is for the library dealing with codegeneration information:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-dimension-name</span> (dimension-info)
  (first dimension-info))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-max-number-dimensions</span> (dimension-info)
  (second dimension-info))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-type-dimension</span> (dimension-info)
  (third dimension-info))
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd4ff681" class="outline-5">
<h5 id="orgd4ff681"><span class="section-number-5">7.5.9.3</span> The gen-params-* functions</h5>
<div class="outline-text-5" id="text-7-5-9-3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param</span> ((d decl) (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (modifiers) d
    (<span style="color: #a020f0;">let</span> ((modifiers (get-modifiers modifiers gen))
          (bd (get-basic-decl d)))
      (<span style="color: #a020f0;">if</span> modifiers
          (emit <span style="color: #8b2252;">"~a ~a"</span> (emit-list modifiers <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">" "</span>) (gen-param bd gen))
          (gen-param bd gen)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-modifiers</span> (modifiers gen)
  (remove-if (complement #'(<span style="color: #a020f0;">lambda</span> (x) (not (or (string= x <span style="color: #8b2252;">""</span>) (null x)))))
             (mapcar #'(<span style="color: #a020f0;">lambda</span> (x) (get-modifier x gen)) modifiers)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-modifier</span> (modifier gen))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-modifier</span> ((c const) gen)
  <span style="color: #8b2252;">"const"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-modifier</span> ((ud user-defined) gen)
  (<span style="color: #a020f0;">let*</span> ((codegen-info (codegen-info gen))
         (memory-spaces (getf codegen-info <span style="color: #483d8b;">:memory-spaces</span>)))
    (second (assoc (name (modifier ud)) memory-spaces <span style="color: #483d8b;">:test</span> #'string=))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param</span> ((bd basic-decl) (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (<span style="color: #a020f0;">with-slots</span> (name) id
      (<span style="color: #a020f0;">if</span> (primitive-decl-p bd)
          (<span style="color: #a020f0;">if</span> (param-written-p bd)
              (emit <span style="color: #8b2252;">"~a* ~a"</span> (gen mcl-type gen) name)
              (emit <span style="color: #8b2252;">"~a ~a"</span> (gen mcl-type gen) name))
          (emit <span style="color: #8b2252;">"~a* ~a"</span> (gen (get-base-type mcl-type) gen) name)))))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-param2</span> ((bd basic-decl) constant-p (gen opencl-generator))
  (<span style="color: #a020f0;">with-slots</span> (mcl-type id) bd
    (<span style="color: #a020f0;">with-slots</span> (name) id
      (<span style="color: #a020f0;">if</span> (and (primitive-decl-p bd) constant-p)
          (emit <span style="color: #8b2252;">"const ~a ~a"</span> (gen mcl-type gen) name)
          (<span style="color: #a020f0;">let</span> ((base-type (get-base-type mcl-type)))
            (<span style="color: #a020f0;">if</span> constant-p
                (emit <span style="color: #8b2252;">"const ~a* ~a"</span> (gen base-type gen) name)
                (emit <span style="color: #8b2252;">"~a* ~a"</span> (gen base-type gen) name)))))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcb10b82" class="outline-3">
<h3 id="orgcb10b82"><span class="section-number-3">7.6</span> Dataflow-values</h3>
<div class="outline-text-3" id="text-7-6">
<p>
This section discusses several micro-passes that gather initial dataflow-values
that can be used later in the actual dataflow passes.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org13621ec">7.6.1. Use variables</a></li>
<li><a href="#org2478ad3">7.6.2. Def variables</a></li>
<li><a href="#orgf960594">7.6.3. On-device variables</a></li>
<li><a href="#org3c39660">7.6.4. Definitions</a></li>
<li><a href="#org33c3ac2">7.6.5. Uses</a></li>
<li><a href="#org1429e80">7.6.6. Entry/exit on-device variables</a></li>
</ul>
</div>
</div>


<div id="outline-container-org13621ec" class="outline-4">
<h4 id="org13621ec"><span class="section-number-4">7.6.1</span> Use variables</h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
This pass determines for each basic block in the controlfow graph the variables
that are used in the block.
</p>
</div>

<div id="outline-container-orgab5a4ca" class="outline-5">
<h5 id="orgab5a4ca"><span class="section-number-5">7.6.1.1</span> Package</h5>
<div class="outline-text-5" id="text-7-6-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:use-variables</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:use-variables</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org705008a" class="outline-5">
<h5 id="org705008a"><span class="section-number-5">7.6.1.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-6-1-2">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;;; </span><span style="color: #b22222;">blocks</span>
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-use-vars-from-bb</span> (bb set)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"fill the set with use-var instances from bb."</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-use-vars-from-bb</span> ((bb bb) set)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-use-vars-from-bb</span> ((bb bb-decl-generic) set)
  (get-use-vars-from-ast (decl bb) bb set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-use-vars-from-bb</span> ((bb bb-stat-generic) set)
  (get-use-vars-from-ast (stat bb) bb set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-use-vars-from-bb</span> ((bb bb-expr-generic) set)
  (get-use-vars-from-ast (expr bb) bb set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-use-vars-from-bb</span> ((bb bb-inc-generic) set)
  (get-use-vars-from-ast (inc bb) bb set))

<span style="color: #b22222;">;;; </span><span style="color: #b22222;">ast</span>
(<span style="color: #a020f0;">let</span> (set bb)

  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-use-vars-fw</span> (ast))
  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-use-vars-bw</span> (ast))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-use-vars-from-ast</span> (ast bb2 set2)
    (setf set set2)
    (setf bb bb2)
    (visit ast #'get-use-vars-fw #'get-use-vars-bw))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-use-var</span> (var)
    (add-to-set (make-dataflow-variable (get-decl-var var)) set))

  (defvisitor get-use-vars-fw ast (ast list string symbol number)
    t)

  (defvisitor get-use-vars-bw ast (ast list string symbol number)
    nil)

  (defvisitor get-use-vars-fw v (var)
    (<span style="color: #a020f0;">typecase</span> (parent v)
      (assign-stat nil)
      (as-stat nil)
      (dot-var nil)
      (swap-stat nil)
      (otherwise (add-use-var v)))
    t))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((bbs (mapcar #'element (vertexes cfgraph)))
        (map (make-hash-table)))
    (<span style="color: #a020f0;">dolist</span> (bb bbs)
      (<span style="color: #a020f0;">let</span> ((use-vars (make-set <span style="color: #483d8b;">:test</span> #'dataflow-element=)))
        (get-use-vars-from-bb bb use-vars)
        (setf (gethash bb map) use-vars)))
    map))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org2478ad3" class="outline-4">
<h4 id="org2478ad3"><span class="section-number-4">7.6.2</span> Def variables</h4>
<div class="outline-text-4" id="text-7-6-2">
<p>
This pass determines for each basic block in the controlfow graph the variables
that are defined in the block.
</p>
</div>

<div id="outline-container-orgdb76c42" class="outline-5">
<h5 id="orgdb76c42"><span class="section-number-5">7.6.2.1</span> Package</h5>
<div class="outline-text-5" id="text-7-6-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:def-variables</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:def-variables</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeb2f41a" class="outline-5">
<h5 id="orgeb2f41a"><span class="section-number-5">7.6.2.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-6-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-def-vars-from-bb</span> (bb set)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"fill the set with def-var instances from bb."</span>))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">a bb-decl, a parameter is always a define</span>
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-def-vars-from-bb</span> ((bb bb-decl) set)
  (add-to-set (make-dataflow-variable (decl bb)) set))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">all other blocks are not interesting</span>
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-def-vars-from-bb</span> ((bb bb) set) set)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">all other bb-decl-generic instances need to investigate</span>
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-def-vars-from-bb</span> ((bb bb-decl-generic) set)
  (get-def-vars-from-ast (decl bb) bb set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-def-vars-from-bb</span> ((bb bb-stat-generic) set)
  (get-def-vars-from-ast (stat bb) bb set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-def-vars-from-bb</span> ((bb bb-expr-generic) set)
  (get-def-vars-from-ast (expr bb) bb set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-def-vars-from-bb</span> ((bb bb-inc-generic) set)
  (get-def-vars-from-ast (inc bb) bb set))



<span style="color: #b22222;">;;; </span><span style="color: #b22222;">ast</span>
(<span style="color: #a020f0;">let</span> (set bb)

  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-def-vars-fw</span> (ast))
  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-def-vars-bw</span> (ast))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-def-vars-from-ast</span> (ast bb2 set2)
    (setf set set2)
    (setf bb bb2)
    (visit ast #'get-def-vars-fw #'get-def-vars-bw))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add</span> (var)
    (add-to-set (make-dataflow-variable (get-decl-var var)) set))

  (defvisitor get-def-vars-fw ast (ast list string symbol number)
    t)

  (defvisitor get-def-vars-bw ast (ast list string symbol number)
    nil)

  (defvisitor get-def-vars-bw c (call)
    (<span style="color: #a020f0;">dolist</span> (e (params c))
      (<span style="color: #a020f0;">if</span> (param-written-p e)
          (add (var e)))))

  (defvisitor get-def-vars-bw i (increment assign-stat)
    (add (var i)))

  (defvisitor get-def-vars-bw ss (swap-stat)
    (<span style="color: #a020f0;">with-slots</span> (var-left var-right) ss
      (add var-left)
      (add var-right)))

  (defvisitor get-def-vars-bw d (normal-decl)
    (add-to-set (make-dataflow-variable d) set))
  (defvisitor get-def-vars-bw d (assign-decl)
    (add-to-set (make-dataflow-variable d) set)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((bbs (mapcar #'element (vertexes cfgraph)))
        (map (make-hash-table)))
    (<span style="color: #a020f0;">dolist</span> (bb bbs)
      (<span style="color: #a020f0;">let</span> ((set (make-dataflow-set)))
         (get-def-vars-from-bb bb set)
         (setf (gethash bb map) set)))
    map))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf960594" class="outline-4">
<h4 id="orgf960594"><span class="section-number-4">7.6.3</span> On-device variables</h4>
<div class="outline-text-4" id="text-7-6-3">
<p>
This pass defines per basic block, which variables are defined/used on the
host/device.
</p>
</div>

<div id="outline-container-orga0e6b2f" class="outline-5">
<h5 id="orga0e6b2f"><span class="section-number-5">7.6.3.1</span> Package</h5>
<div class="outline-text-5" id="text-7-6-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:on-device-variables</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:ast-mcpl</span>
        <span style="color: #483d8b;">:use-variables</span> <span style="color: #483d8b;">:def-variables</span> <span style="color: #483d8b;">:print-dataflow</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:def-on-device-variables-in</span> <span style="color: #483d8b;">:def-on-device-variables-out</span>
           <span style="color: #483d8b;">:use-on-device-variables-in</span> <span style="color: #483d8b;">:use-on-device-variables-out</span>
           <span style="color: #483d8b;">:def-on-host-variables-in</span> <span style="color: #483d8b;">:def-on-host-variables-out</span>
           <span style="color: #483d8b;">:use-on-host-variables-in</span> <span style="color: #483d8b;">:use-on-host-variables-out</span>

           <span style="color: #483d8b;">:on-device-variable</span> <span style="color: #483d8b;">:on-host-variable</span>
           <span style="color: #483d8b;">:def-on-device-variable</span> <span style="color: #483d8b;">:use-on-device-variable</span>
           <span style="color: #483d8b;">:def-on-host-variable</span> <span style="color: #483d8b;">:use-on-host-variable</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org68d0de9" class="outline-5">
<h5 id="org68d0de9"><span class="section-number-5">7.6.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-6-3-2">
</div>

<ul class="org-ul">
<li><a id="org27e959b"></a>The exported functions<br />
<div class="outline-text-6" id="text-org27e959b">
<p>
The following functions define the definitions, uses for the IN and OUT set of
a block for both device and host variables.  To find the IN and OUT sets of
calls, we use the slots <code>entry-</code> and <code>exit-on-device-variables</code> in the AST form
<code>func</code>.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def-on-device-variables-in</span> (cfgraph)
  (def-on-device-variables-in/out cfgraph 'entry-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def-on-device-variables-out</span> (cfgraph)
  (def-on-device-variables-in/out cfgraph 'exit-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-on-device-variables-in</span> (cfgraph)
  (use-on-device-variables-in/out cfgraph 'entry-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-on-device-variables-out</span> (cfgraph)
  (use-on-device-variables-in/out cfgraph 'exit-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def-on-host-variables-in</span> (cfgraph)
  (def-on-host-variables-in/out cfgraph 'entry-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def-on-host-variables-out</span> (cfgraph)
  (def-on-host-variables-in/out cfgraph 'exit-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-on-host-variables-in</span> (cfgraph)
  (use-on-host-variables-in/out cfgraph 'entry-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-on-host-variables-out</span> (cfgraph)
  (use-on-host-variables-in/out cfgraph 'exit-on-device-variables))
</pre>
</div>
</div>
</li>

<li><a id="orgca8596d"></a>The exported classes<br />
<div class="outline-text-6" id="text-orgca8596d">
<p>
The following classes distinguish between the various types of
dataflow-variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">on-device-variable</span> (dataflow-variable) ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">on-host-variable</span> (dataflow-variable) ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">def-on-device-variable</span> (on-device-variable) ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">use-on-device-variable</span> (on-device-variable) ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">def-on-host-variable</span> (on-host-variable) ())
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">use-on-host-variable</span> (on-host-variable) ())
</pre>
</div>

<p>
The following definitions define whether the dataflow variables are equal:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">dataflow-unequal</span> (type1 type2)
  `(<span style="color: #a020f0;">progn</span>
     (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">dataflow-element=</span> and ((de1 ,type1) (de2 ,type2))
       nil)
     (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">dataflow-element=</span> and ((de1 ,type2) (de2 ,type1))
       nil)))

(dataflow-unequal on-device-variable on-host-variable)
(dataflow-unequal def-on-device-variable use-on-device-variable)
(dataflow-unequal def-on-host-variable use-on-host-variable)
</pre>
</div>

<p>
The following methods are used for printing the dataflow graph:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dataflow-element</span> ((d def-on-device-variable))
  (format nil <span style="color: #8b2252;">"&lt;def, ~a&gt;"</span> (call-next-method)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dataflow-element</span> ((d use-on-device-variable))
  (format nil <span style="color: #8b2252;">"&lt;use, ~a&gt;"</span> (call-next-method)))
</pre>
</div>
</div>
</li>

<li><a id="org9cee690"></a>The generic functions<br />
<div class="outline-text-6" id="text-org9cee690">
<p>
The following functions parameterize on whether we need to find
dataflow-variables based on definitions or uses, whether it are on-device
variables or on-host variables and which slot we use for calls.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def-on-device-variables-in/out</span> (cfgraph on-device-call-slot)
  (def/use-device/host-variables
      cfgraph #'def-variables 'def-on-device-variable
      (on-device-func on-device-call-slot 'def-on-device-variable)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-on-device-variables-in/out</span> (cfgraph on-device-call-slot)
  (def/use-device/host-variables
      cfgraph #'use-variables 'use-on-device-variable
      (on-device-func on-device-call-slot 'use-on-device-variable)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def-on-host-variables-in/out</span> (cfgraph on-device-call-slot)
  (def/use-device/host-variables
      cfgraph #'def-variables 'def-on-host-variable
      (on-host-func on-device-call-slot 'def-on-host-variable)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-on-host-variables-in/out</span> (cfgraph on-device-call-slot)
  (def/use-device/host-variables
      cfgraph #'use-variables 'use-on-host-variable
      (on-host-func on-device-call-slot 'use-on-host-variable)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">def/use-device/host-variables</span> (cfgraph source-func class-symbol pred)
  (<span style="color: #a020f0;">let</span> ((source-map (funcall source-func cfgraph))
        (result-map (make-hash-table)))
    (<span style="color: #a020f0;">dolist</span> (bb (basic-blocks cfgraph))
      (add-to-map bb source-map result-map class-symbol pred))
    result-map))
</pre>
</div>
</div>
</li>


<li><a id="org850e237"></a>Predicate functions<br />
<div class="outline-text-6" id="text-org850e237">
<p>
The following two functions return a predicate function that based on a
slot-value for calls and type can tell whether it is a device or host variable:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">on-device-func</span> (on-device-call-slot type)
  #'(<span style="color: #a020f0;">lambda</span> (bb dataflow-variable)
      (on-device-variable-p bb dataflow-variable on-device-call-slot type)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">on-host-func</span> (on-device-call-slot type)
  #'(<span style="color: #a020f0;">lambda</span> (bb dataflow-variable)
      (on-host-variable-p bb dataflow-variable on-device-call-slot type)))
</pre>
</div>


<p>
A dataflow-variable in a basic block bb is an on-device-variable if it is
within a foreach statement, or it is on a device in a call.  Besides those, it
has to be written and a primitive type or it has to be a non-primitive type.
Whether it is written does not matter at that point.  Finally, the declaration
of the variable should not be within a foreach statement.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">on-device-variable-p</span> (bb dataflow-var on-device-call-slot type)
  (and (or (bb-in-foreach-p bb)
           (on-device/host-in-call bb dataflow-var on-device-call-slot type))
       (or (written (decl dataflow-var))
           (not (primitive-type-p (get-type-decl (decl dataflow-var)))))
       (not (in-foreach-p (decl dataflow-var)))))
</pre>
</div>

<p>
Whether a basic block is in a foreach statement:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">bb-in-foreach-p</span> (bb))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">bb-in-foreach-p</span> ((bb bb))
  (in-foreach-p (get-ast-basic-block bb)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">bb-in-foreach-p</span> ((bb bb-foreach))
  t)
</pre>
</div>

<p>
Whether a dataflow-variable in a basic block is a host variable is defined to
be that it is on the device or host based on the type in a call and it should
not be an on-device use or definition or the basic block should not be a swap
statements.  Swap statements swap two pointers and are excluded to be uses or
definitions.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">on-host-variable-p</span> (bb dataflow-var on-device-call-slot type)
  (or (on-device/host-in-call bb dataflow-var on-device-call-slot type)
      (not (or (on-device-variable-p
                bb dataflow-var on-device-call-slot 'def-on-device-variable)
               (on-device-variable-p
                bb dataflow-var on-device-call-slot 'use-on-device-variable)
               (swap-p bb)))))
</pre>
</div>

<p>
Whether a basic block is a swap statement:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">swap-p</span> (bb/stat))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">swap-p</span> ((bb bb))
  (and (typep bb 'bb-stat)
       (swap-p (stat bb))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">swap-p</span> ((s stat))
  (typep s 'swap-stat))
</pre>
</div>

<p>
Whether a dataflow-variable in basic block bb is on the device or host (based
on the type) within a call means that the basic block has to be a call
statement and the declaration of the dataflow-variable has to be a parameter
that is on the device within the called function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">on-device/host-in-call</span> (bb dataflow-var on-device-call-slot type)
  (<span style="color: #a020f0;">with-slots</span> (decl) dataflow-var
    (and (typep bb 'bb-stat)
         (typep (stat bb) 'call-stat)
         (not (builtin-func-p (call (stat bb))))
         (param-on-device/host-p
          decl (call (stat bb)) on-device-call-slot type))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">param-on-device/host-p</span> (decl-calling-func call on-device-call-slot type)
  (and (decl-calling-func-in-called-func-p decl-calling-func call)
       (<span style="color: #a020f0;">let</span> ((decl-called-func
              (decl-calling-func-&gt;called-func decl-calling-func call))
             (on-device-variables-func (slot-value (func call)
                                                   on-device-call-slot)))
         (<span style="color: #a020f0;">loop</span> for on-device-var in on-device-variables-func
            thereis (and (eq decl-called-func (decl on-device-var))
                         (eq (type-of on-device-var) type))))))
</pre>
</div>
</div>
</li>



<li><a id="orgc942427"></a>Helper functions<br />
<div class="outline-text-6" id="text-orgc942427">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-to-map</span> (bb source-map result-map class-symbol pred)
  (<span style="color: #a020f0;">let</span> ((source-elements (elements (gethash bb source-map)))
        (result-set (make-dataflow-set)))
    (<span style="color: #a020f0;">unless</span> (typep bb 'bb-decl)
      (add-all-to-set (mapcar #'(<span style="color: #a020f0;">lambda</span> (x) (change-class x class-symbol))
                              (filter #'(<span style="color: #a020f0;">lambda</span> (x) (funcall pred bb x))
                                      source-elements))
                      result-set))
    (setf (gethash bb result-map) result-set)))
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org53aa2b6" class="outline-5">
<h5 id="org53aa2b6"><span class="section-number-5">7.6.3.3</span> Testing on-device variables</h5>
<div class="outline-text-5" id="text-7-6-3-3">
</div>
<ul class="org-ul">
<li><a id="orga295dd3"></a>The package<br />
<div class="outline-text-6" id="text-orga295dd3">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-on-device-variables</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:controlflow</span>
        <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:resolve-vars</span> <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:resolve-calls</span>
        <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:set-vars-written</span> <span style="color: #483d8b;">:set-entry-exit-on-device-variables</span>
        <span style="color: #483d8b;">:test-dataflow-library</span> <span style="color: #483d8b;">:build-ast</span>
        <span style="color: #483d8b;">:on-device-variables</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-on-device-variables</span>))
</pre>
</div>
</div>
</li>

<li><a id="org61b9c6f"></a>The tests<br />
<div class="outline-text-6" id="text-org61b9c6f">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite on-device-variables <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite on-device-variables)

(test simple
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a ;</span>

<span style="color: #8b2252;">                  perfect void f(int n, float[n] a) {</span>
<span style="color: #8b2252;">                    foreach (int i in n threads) {</span>
<span style="color: #8b2252;">                      a[i] = 0;</span>
<span style="color: #8b2252;">                    }</span>
<span style="color: #8b2252;">                  }"</span>)
         (cfgraph (get-cfgraph input))
         (decl (build-decl <span style="color: #8b2252;">"a"</span> '((<span style="color: #8b2252;">"n"</span>))))
         (stat (build-assign-stat (build-var <span style="color: #8b2252;">"a"</span> '((<span style="color: #8b2252;">"i"</span>))) 0))
         (wanted (empty-dataflow-map cfgraph))
         (result (map-&gt;compare-set
                  (def-on-device-variables-in cfgraph) cfgraph)))

    (add-to-map wanted stat (build-on-device-definition decl))
    (is (set= (map-&gt;compare-set wanted cfgraph) result))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-on-device-definition</span> (decl)
  (make-instance 'def-on-device-variable <span style="color: #483d8b;">:decl</span> decl))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">add-to-map</span> (map stat dataflow-variable))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-to-map</span> (map (stat stat) dataflow-variable)
  (<span style="color: #a020f0;">loop</span> for bb being the hash-keys in map
     do (<span style="color: #a020f0;">when</span> (and (typep bb 'bb-stat)
                   (ast= stat (stat bb)))
          (add-to-set dataflow-variable (gethash bb map)))))

(test calls
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a ;</span>

<span style="color: #8b2252;">                  perfect void g(int n, float[n] a, const float[n] b) {</span>
<span style="color: #8b2252;">                    a[0] = 0;</span>
<span style="color: #8b2252;">                    foreach (int i in n threads) {</span>
<span style="color: #8b2252;">                      a[i] = b[i];</span>
<span style="color: #8b2252;">                    }</span>
<span style="color: #8b2252;">                  }</span>
<span style="color: #8b2252;">                  perfect void f(int n, float[n] a, const float[n] b) {</span>
<span style="color: #8b2252;">                    g(n, a, b);</span>
<span style="color: #8b2252;">                  }"</span>)
         (ast (get-ast input))
         (cfgraph (get-cfgraph-for-func <span style="color: #8b2252;">"f"</span> ast))
         (decl-a (build-decl <span style="color: #8b2252;">"a"</span> '((<span style="color: #8b2252;">"n"</span>))))
         (decl-b (build-decl <span style="color: #8b2252;">"b"</span> '((<span style="color: #8b2252;">"n"</span>)) t))
         (call-stat (build-call-stat <span style="color: #8b2252;">"g"</span> <span style="color: #8b2252;">"n"</span> <span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"b"</span>)))
    (is (and
         (correct (def-on-device-variables-out cfgraph)
                  (make-instance 'def-on-device-variable <span style="color: #483d8b;">:decl</span> decl-a)
                  cfgraph call-stat)
         (correct (def-on-host-variables-in cfgraph)
                  (make-instance 'def-on-host-variable <span style="color: #483d8b;">:decl</span> decl-a)
                  cfgraph call-stat)
         (correct (use-on-device-variables-out cfgraph)
                  (make-instance 'use-on-device-variable <span style="color: #483d8b;">:decl</span> decl-b)
                  cfgraph call-stat)
         (correct (use-on-device-variables-in cfgraph)
                  (make-instance 'use-on-device-variable <span style="color: #483d8b;">:decl</span> decl-b)
                  cfgraph call-stat)))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-on-host-definition</span> (decl)
  (make-instance 'def-on-host-variable <span style="color: #483d8b;">:decl</span> decl))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-on-device-use</span> (decl)
  (make-instance 'use-on-host-variable <span style="color: #483d8b;">:decl</span> decl))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">correct</span> (result-map dataflow-variable cfgraph call-stat)
  (<span style="color: #a020f0;">let</span> ((wanted (empty-dataflow-map cfgraph)))
    (add-to-map wanted call-stat dataflow-variable)
    (set= (map-&gt;compare-set result-map cfgraph)
          (map-&gt;compare-set wanted cfgraph))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-ast</span> (string)
  (<span style="color: #a020f0;">let</span> ((ast (parse-mcpl string)))
    (set-parents ast)
    (resolve-calls ast nil)
    (<span style="color: #a020f0;">let</span> ((callgraph (set-callgraph (funcs (code ast)))))
      (resolve-vars ast nil)
      (set-cfgraphs ast t t)
      (set-vars-written callgraph)
      (set-entry-exit-on-device-variables callgraph)
      ast)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-cfgraph-for-func</span> (func-name ast)
  (cfgraph (first (filter #'(<span style="color: #a020f0;">lambda</span> (f)
                       (string= (name (id f)) func-name))
                   (funcs (code ast))))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org3c39660" class="outline-4">
<h4 id="org3c39660"><span class="section-number-4">7.6.4</span> Definitions</h4>
<div class="outline-text-4" id="text-7-6-4">
<p>
This pass records for each basic block which variables it defines.  A
definition is a dataflow-variable associated with a basic block.
</p>
</div>

<div id="outline-container-org659aae1" class="outline-5">
<h5 id="org659aae1"><span class="section-number-5">7.6.4.1</span> The package</h5>
<div class="outline-text-5" id="text-7-6-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:definitions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:def-variables</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:definitions</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0c76e16" class="outline-5">
<h5 id="org0c76e16"><span class="section-number-5">7.6.4.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-6-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">definitions</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((map (def-variables cfgraph)))
    (<span style="color: #a020f0;">loop</span> for bb being the hash-keys in map
       do (create-definitions bb (gethash bb map)))
    map))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-definitions</span> (bb def-variable-set)
  (<span style="color: #a020f0;">loop</span> for def-var in (elements def-variable-set)
     do (change-class def-var 'definition <span style="color: #483d8b;">:bb</span> bb)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbbcf529" class="outline-5">
<h5 id="orgbbcf529"><span class="section-number-5">7.6.4.3</span> Testing definitions</h5>
<div class="outline-text-5" id="text-7-6-4-3">
</div>
<ul class="org-ul">
<li><a id="org1a3655f"></a>The package<br />
<div class="outline-text-6" id="text-org1a3655f">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-definitions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span>
        <span style="color: #483d8b;">:definitions</span> <span style="color: #483d8b;">:build-ast</span> <span style="color: #483d8b;">:test-dataflow-library</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-definitions</span>))
</pre>
</div>
</div>
</li>

<li><a id="org80b1730"></a>The tests<br />
<div class="outline-text-6" id="text-org80b1730">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite definitions <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite definitions)

(test parameter-def
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a ;</span>
<span style="color: #8b2252;">                  perfect void f(int a) {</span>
<span style="color: #8b2252;">                  }"</span>)
         (cfgraph (get-cfgraph input))
         (decl (build-decl <span style="color: #8b2252;">"a"</span>))
         (wanted-result (build-compare-set
                         (build-definition decl decl)))
         (result (map-&gt;compare-set (definitions cfgraph) cfgraph)))
    (is (set= wanted-result result))))

(test more-defs
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f(int a) {</span>
<span style="color: #8b2252;">                      int b = 1;</span>
<span style="color: #8b2252;">                  }"</span>)
         (a-decl (build-decl <span style="color: #8b2252;">"a"</span>))
         (decl-stat (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil 1))
         (cfgraph (get-cfgraph input))
         (wanted-result (build-compare-set
                         (build-definition a-decl a-decl)
                         (build-definition (decl decl-stat) decl-stat)))
         (result (map-&gt;compare-set (definitions cfgraph) cfgraph)))
    (is (set= wanted-result result))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org33c3ac2" class="outline-4">
<h4 id="org33c3ac2"><span class="section-number-4">7.6.5</span> Uses</h4>
<div class="outline-text-4" id="text-7-6-5">
<p>
This pass records for each basic block which variables it uses.  A
use is a dataflow-variable associated with a basic block.
</p>
</div>

<div id="outline-container-org801c08a" class="outline-5">
<h5 id="org801c08a"><span class="section-number-5">7.6.5.1</span> The package</h5>
<div class="outline-text-5" id="text-7-6-5-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:uses</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:use-variables</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:uses</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd907db3" class="outline-5">
<h5 id="orgd907db3"><span class="section-number-5">7.6.5.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-6-5-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">uses</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((map (use-variables cfgraph)))
    (<span style="color: #a020f0;">loop</span> for bb being the hash-keys in map
       do (create-uses bb (gethash bb map)))
    map))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-uses</span> (bb use-variable-set)
  (<span style="color: #a020f0;">loop</span> for use-var in (elements use-variable-set)
     do (change-class use-var 'use <span style="color: #483d8b;">:bb</span> bb)))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org1429e80" class="outline-4">
<h4 id="org1429e80"><span class="section-number-4">7.6.6</span> Entry/exit on-device variables</h4>
<div class="outline-text-4" id="text-7-6-6">
<p>
This pass determines the on-device variables at the entry and exit points of
functions.  It is required that the controlflow graph is an optimistic one.
</p>
</div>

<div id="outline-container-orged0aa17" class="outline-5">
<h5 id="orged0aa17"><span class="section-number-5">7.6.6.1</span> The package</h5>
<div class="outline-text-5" id="text-7-6-6-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:set-entry-exit-on-device-variables</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span>
        <span style="color: #483d8b;">:on-device-variables</span> <span style="color: #483d8b;">:dataflow-on-device-variables</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:set-entry-exit-on-device-variables</span>
           <span style="color: #483d8b;">:entry-on-device-variables-cfgraph</span>
           <span style="color: #483d8b;">:exit-on-device-variables-cfgraph</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd313514" class="outline-5">
<h5 id="orgd313514"><span class="section-number-5">7.6.6.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-6-6-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-entry-exit-on-device-variables</span> (callgraph)
  (<span style="color: #a020f0;">dolist</span> (func (reverse (funcs-ordered callgraph)))
    (<span style="color: #a020f0;">with-slots</span> (entry-on-device-variables exit-on-device-variables cfgraph)
        func
      (setf exit-on-device-variables
            (tolist (exit-on-device-variables-cfgraph cfgraph)
                    #'exit cfgraph))
      (setf entry-on-device-variables
            (tolist (entry-on-device-variables-cfgraph cfgraph)
                    #'entry cfgraph)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tolist</span> (map exit cfgraph)
  (elements (gethash (funcall exit cfgraph) map)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">entry-on-device-variables-cfgraph</span> (cfgraph)
  (entry/exit-on-device-variables cfgraph #'get-entry-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">exit-on-device-variables-cfgraph</span> (cfgraph)
  (entry/exit-on-device-variables cfgraph #'get-exit-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">entry/exit-on-device-variables</span> (cfgraph exit-on-device-variables)
  (filter-dataflow-map #'(<span style="color: #a020f0;">lambda</span> (dv) (param-p (decl dv)))
                       (funcall exit-on-device-variables cfgraph)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-exit-on-device-variables</span> (cfgraph)
  (get-entry/exit-on-device-variables cfgraph #'available-on-device-variables
                                  #'available-on-host-variables #'exit))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-entry-on-device-variables</span> (cfgraph)
  (get-entry/exit-on-device-variables cfgraph #'anticipated-on-device-variables
                                  #'anticipated-on-host-variables #'entry))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-entry/exit-on-device-variables</span>
    (cfgraph available-on-device-variables available-on-host-variables exit)
  (<span style="color: #a020f0;">let</span> ((available-on-device (funcall available-on-device-variables cfgraph))
        (available-on-host (funcall available-on-host-variables cfgraph))
        (result (empty-dataflow-map cfgraph))
        (exit-bb (funcall exit cfgraph)))
    (setf (gethash exit-bb result)
          (union (gethash exit-bb available-on-device)
                     (gethash exit-bb available-on-host)))
    result))



</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org83cff71" class="outline-3">
<h3 id="org83cff71"><span class="section-number-3">7.7</span> Dataflow</h3>
<div class="outline-text-3" id="text-7-7">
<p>
This section contains several generic dataflow passes.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org0aeb3ca">7.7.1. Dataflow for on-device variables</a></li>
<li><a href="#org80aea63">7.7.2. Aliases</a></li>
<li><a href="#orgc60f822">7.7.3. Dependencies</a></li>
<li><a href="#org8cae35c">7.7.4. Reaching definitions</a></li>
</ul>
</div>
</div>


<div id="outline-container-org0aeb3ca" class="outline-4">
<h4 id="org0aeb3ca"><span class="section-number-4">7.7.1</span> Dataflow for on-device variables</h4>
<div class="outline-text-4" id="text-7-7-1">
<p>
This pass determines for each block which variables are certain to be on the
device.  
</p>
</div>

<div id="outline-container-orgfb22d20" class="outline-5">
<h5 id="orgfb22d20"><span class="section-number-5">7.7.1.1</span> The package</h5>
<div class="outline-text-5" id="text-7-7-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:dataflow-on-device-variables</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>
        <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:on-device-variables</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:compose</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:available-on-device-variables</span>
           <span style="color: #483d8b;">:anticipated-on-device-variables</span>

           <span style="color: #483d8b;">:available-on-host-variables</span>
           <span style="color: #483d8b;">:anticipated-on-host-variables</span>

           <span style="color: #483d8b;">:live-on-device-variables</span>
           <span style="color: #483d8b;">:reaching-on-device-variables</span>

           <span style="color: #483d8b;">:gen-on-device-variables-in</span> <span style="color: #483d8b;">:kill-on-device-variables-in</span>
           <span style="color: #483d8b;">:gen-on-device-variables-out</span> <span style="color: #483d8b;">:kill-on-device-variables-out</span>

           <span style="color: #483d8b;">:gen-on-device-variables-in-w/o-use</span>
           <span style="color: #483d8b;">:gen-on-device-variables-out-w/o-use</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org38acc0e" class="outline-5">
<h5 id="org38acc0e"><span class="section-number-5">7.7.1.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-7-1-2">
</div>

<ul class="org-ul">
<li><a id="org6742aa0"></a>The exported functions<br />
<div class="outline-text-6" id="text-org6742aa0">
<p>
The function <code>available-on-device-variables</code> tells for each basic block which
on-device variables are certainly available after execution of the block.
Therefore, the wanted output is in the OUT variable of map.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">available-on-device-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-on-device-variables-out-w/o-use cfgraph))
        (kill (kill-on-device-variables-out cfgraph)))
    (must-forward cfgraph gen kill)))
</pre>
</div>

<p>
Similar to the above function, the function <code>anticipated-on-device-variables</code>
states for each basic block, which on-device variables are certain to be
expected at some point on the device.  The IN variable for each basic block is
the wanted output.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">anticipated-on-device-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-on-device-variables-in-w/o-use cfgraph))
        (kill (kill-on-device-variables-in cfgraph)))
    (must-backward cfgraph gen kill)))
(add-backward-dataflow-analysis 'available-on-device-variables)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">available-on-host-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-on-host-variables-out-w/o-use cfgraph))
        (kill (kill-on-host-variables-out cfgraph)))
    (must-forward cfgraph gen kill)))
(add-forward-dataflow-analysis 'available-on-host-variables)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">anticipated-on-host-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-on-host-variables-in-w/o-use cfgraph))
        (kill (kill-on-host-variables-in cfgraph)))
    (must-backward cfgraph gen kill)))
(add-backward-dataflow-analysis 'anticipated-on-host-variables)
</pre>
</div>

<p>
The anticipated and available analyses have their 'may' counterparts in live
and reaching respectively.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">live-on-device-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-on-device-variables-in-w/o-use cfgraph))
        (kill (kill-on-device-variables-in cfgraph)))
    (may-backward cfgraph gen kill)))
(add-backward-dataflow-analysis 'live-on-device-variables)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reaching-on-device-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-on-device-variables-out-w/o-use cfgraph))
        (kill (kill-on-device-variables-out cfgraph)))
    (may-forward cfgraph gen kill)))
(add-forward-dataflow-analysis 'reaching-on-device-variables)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-device-variables-out-w/o-use</span> (cfgraph)
  (gen-on-host/device-variables-in/out-w/o-use
   cfgraph #'gen-on-device-variables-out #'kill-use-variables-out
   'use-on-device-variable 'def-on-device-variable))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-device-variables-in-w/o-use</span> (cfgraph)
  (gen-on-host/device-variables-in/out-w/o-use
   cfgraph #'gen-on-device-variables-in #'kill-use-variables-in
   'use-on-device-variable 'def-on-device-variable))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-host-variables-out-w/o-use</span> (cfgraph)
  (gen-on-host/device-variables-in/out-w/o-use
   cfgraph #'gen-on-host-variables-out #'kill-use-variables-out
   'use-on-host-variable 'def-on-host-variable))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-host-variables-in-w/o-use</span> (cfgraph)
  (gen-on-host/device-variables-in/out-w/o-use
   cfgraph #'gen-on-host-variables-in #'kill-use-variables-in
   'use-on-host-variable 'def-on-host-variable))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-host/device-variables-in/out-w/o-use</span> (cfgraph gen-func kill-func
                                                    use-type def-type)
  (<span style="color: #a020f0;">let</span> ((gen (funcall gen-func cfgraph))
        (kill (funcall kill-func cfgraph)))
    (dataflow-union
     (dataflow-difference gen kill)
     (use-&gt;def kill use-type def-type))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">use-&gt;def</span> (kill use-type def-type)
  (combine kill kill #'eq
           #'(<span style="color: #a020f0;">lambda</span> (k k2) (and (eq k k2)
                                 (typep k use-type)))
           #'(<span style="color: #a020f0;">lambda</span> (k k2)
               (<span style="color: #a020f0;">declare</span> (ignore k2))
               (make-instance def-type <span style="color: #483d8b;">:decl</span> (decl k)))))

</pre>
</div>


<p>
The following functions define the gen and kill sets for on-device variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-device-variables-in</span> (cfgraph)
  (dataflow-union (def-on-device-variables-in cfgraph)
                  (use-on-device-variables-in cfgraph)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-device-variables-out</span> (cfgraph)
  (dataflow-union (def-on-device-variables-out cfgraph)
                  (use-on-device-variables-out cfgraph)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-on-device-variables-in</span> (cfgraph)
  (kill-on-device-variables-in/out cfgraph #'def-on-device-variables-in
                                   #'use-on-device-variables-in
                                   #'def-on-host-variables-in
                                   #'use-on-host-variables-in))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-on-device-variables-out</span> (cfgraph)
  (kill-on-device-variables-in/out cfgraph #'def-on-device-variables-out
                                   #'use-on-device-variables-out
                                   #'def-on-host-variables-out
                                   #'use-on-host-variables-out))
</pre>
</div>



<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-host-variables-in</span> (cfgraph)
  (dataflow-union (def-on-host-variables-in cfgraph)
                  (use-on-host-variables-in cfgraph)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-on-host-variables-out</span> (cfgraph)
  (dataflow-union (def-on-host-variables-out cfgraph)
                  (use-on-host-variables-out cfgraph)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-on-host-variables-in</span> (cfgraph)
  (kill-on-device-variables-in/out cfgraph #'def-on-host-variables-in
                                 #'use-on-host-variables-in
                                 #'def-on-device-variables-in
                                 #'use-on-device-variables-in))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-on-host-variables-out</span> (cfgraph)
  (kill-on-device-variables-in/out cfgraph #'def-on-host-variables-out
                                 #'use-on-host-variables-out
                                 #'def-on-device-variables-out
                                 #'use-on-device-variables-out))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-use-variables-in</span> (cfgraph)
  (kill-use-variables-in/out cfgraph #'def-on-host-variables-in
                             #'use-on-host-variables-in
                             #'def-on-device-variables-in
                             #'use-on-device-variables-in))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-use-variables-out</span> (cfgraph)
  (kill-use-variables-in/out cfgraph #'def-on-host-variables-out
                             #'use-on-host-variables-out
                             #'def-on-device-variables-out
                             #'use-on-device-variables-out))

</pre>
</div>
</div>
</li>


<li><a id="org8bfee38"></a>The generic functions<br />
<div class="outline-text-6" id="text-org8bfee38">
<p>
The following function states that the solution is the union of the kills that
host definitions do with the kills that host use do.
A host definition kills device definitions and device uses, whereas a host use
kills only device definitions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-on-device-variables-in/out</span> (cfgraph def-on-device-func
                                        use-on-device-func
                                        def-on-host-func
                                        use-on-host-func)
  (<span style="color: #a020f0;">let</span> ((def-on-device (funcall def-on-device-func cfgraph))
        (use-on-device (funcall use-on-device-func cfgraph))
        (def-on-host (funcall def-on-host-func cfgraph))
        (use-on-host (funcall use-on-host-func cfgraph)))
    (<span style="color: #a020f0;">let</span> ((def-host-kills
           (combine-kills
            def-on-host (dataflow-union def-on-device use-on-device)))
          (use-host-kills
           (combine-kills use-on-host def-on-device)))
      (dataflow-union def-host-kills use-host-kills))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">combine-kills</span> (host/def-map device/use-map)
  (combine host/def-map device/use-map
           (compose #'not #'eq)
           #'(<span style="color: #a020f0;">lambda</span> (hde dde) (eq (decl hde) (decl dde)))
           #'(<span style="color: #a020f0;">lambda</span> (hde dde) (<span style="color: #a020f0;">declare</span> (ignore hde)) dde)))



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-use-variables-in/out</span> (cfgraph def-on-device-func
                                        use-on-device-func
                                        def-on-host-func
                                        use-on-host-func)
  (<span style="color: #a020f0;">let</span> ((def-on-device (funcall def-on-device-func cfgraph))
        (use-on-device (funcall use-on-device-func cfgraph))
        (def-on-host (funcall def-on-host-func cfgraph))
        (use-on-host (funcall use-on-host-func cfgraph)))
    (<span style="color: #a020f0;">let</span> ((def-use-device-kills
           (combine-def-use-kills def-on-device use-on-device))
          (def-use-host-kills
           (combine-def-use-kills def-on-host use-on-host)))
      (dataflow-union def-use-device-kills def-use-host-kills))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">combine-def-use-kills</span> (def-map use-map)
  (combine use-map def-map
           (constantly t)
           #'(<span style="color: #a020f0;">lambda</span> (use def) (eq (decl def) (decl use)))
           #'(<span style="color: #a020f0;">lambda</span> (use def) (<span style="color: #a020f0;">declare</span> (ignore def)) use)))


</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org80aea63" class="outline-4">
<h4 id="org80aea63"><span class="section-number-4">7.7.2</span> Aliases</h4>
<div class="outline-text-4" id="text-7-7-2">
<p>
This package performs alias analysis as a dataflow analysis.  For each basic
block, we record which <b>may-aliases</b> are known.
</p>
</div>

<div id="outline-container-orgc6c826f" class="outline-5">
<h5 id="orgc6c826f"><span class="section-number-5">7.7.2.1</span> The package</h5>
<div class="outline-text-5" id="text-7-7-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:aliases</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:controlflow</span>
        <span style="color: #483d8b;">:check-types</span> <span style="color: #483d8b;">:print-pretty</span> <span style="color: #483d8b;">:print-bb</span> <span style="color: #483d8b;">:print-dataflow</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:compose</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:aliases</span> <span style="color: #483d8b;">:alias</span> <span style="color: #483d8b;">:tile</span> <span style="color: #483d8b;">:get-aliases-ast</span> <span style="color: #483d8b;">:get-primary-decl</span>
           <span style="color: #483d8b;">:get-decls-aliased-to-var</span> <span style="color: #483d8b;">:make-alias</span> <span style="color: #483d8b;">:make-tile</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6cdb4f5" class="outline-5">
<h5 id="org6cdb4f5"><span class="section-number-5">7.7.2.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-7-2-2">
</div>

<ul class="org-ul">
<li><a id="orgcead778"></a>The datastructures<br />
<div class="outline-text-6" id="text-orgcead778">
<p>
We define an alias as a dataflow-variable associated to a basic block.  Besides
this, we associate another variable to an alias, namely the alias that refers
to the dataflow-variable.  An alias has three slots:
</p>
<dl class="org-dl">
<dt><code>decl</code></dt><dd>the declaration to which the alias refers,</dd>
<dt><code>alias</code></dt><dd>the declaration that is the alias, and</dd>
<dt><code>bb</code></dt><dd>the basic block where the alias was created.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">alias</span> (dataflow-variable-with-bb)
  ((alias <span style="color: #483d8b;">:initarg</span> <span style="color: #483d8b;">:alias</span> <span style="color: #483d8b;">:initform</span> (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"must supply alias"</span>) <span style="color: #483d8b;">:reader</span> alias)))
</pre>
</div>

<p>
A tile is an alias but it points somewhere in the original variable.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">tile</span> (alias) ())
</pre>
</div>
</div>
</li>

<li><a id="org1d8a992"></a>The alias-analysis functions<br />
<div class="outline-text-6" id="text-org1d8a992">
<p>
We define the <code>aliases</code> as being the <code>reaching-aliases</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">aliases</span> (cfgraph)
  (reaching-aliases cfgraph))
</pre>
</div>

<p>
The <code>reaching-aliases</code> functions is a may-forward analysis with a <code>gen</code> and
<code>kill</code> set:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reaching-aliases</span> (cfgraph)
  (may-forward cfgraph (gen-aliases cfgraph) (kill-aliases cfgraph)))
</pre>
</div>

<p>
The <code>gen-aliases</code> functions gives for each basic block the aliases with
<b>unique-decls</b> that are created in this basic block.  We consider an alias with
a unique declaration an alias that does not point to another alias, but to the
first declaration.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-aliases</span> (cfgraph)
  (alias-vars-unique-decls cfgraph))
</pre>
</div>

<p>
The <code>kill-aliases</code> function is a combination of the aliases with unique
declarations.  Essentially, an alias kills another alias if the alias slots of
both aliases are the same, but the declaration are not (they point to a
different declaration).
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-aliases</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((aliases (alias-vars-unique-decls cfgraph)))
    (combine aliases aliases (compose #'not #'eq)
             #'(<span style="color: #a020f0;">lambda</span> (de1 de2) (and (eq (alias de1) (alias de2))
                                      (not (eq (decl de1) (decl de2)))))
             #'(<span style="color: #a020f0;">lambda</span> (de1 de2) (<span style="color: #a020f0;">declare</span> (ignore de1)) de2))))
</pre>
</div>

<p>
The function <code>alias-vars-unique-decls</code> records per basic block the aliases that
are becoming available in that basic block.  It ensures that we record the
first declaration instead of another alias.  In the example below, instead of
the second alias pointing to <code>a2</code> an already existing alias, it points to
<code>decl1</code>, the first known declaration.
</p>

<pre class="example">
f(decl1, decl2) {
  a1 = decl1;     // &lt;decl1, a1&gt;
  a2 = a1;        // &lt;decl1, a2&gt;
</pre>

<p>
We do by first recording all alias variables (that do not have unique
declarations), perform a forward dataflow-analysis with a transfer function
that retrieves the original declarations from the IN set for the dataflow-value
under investigation at block <code>bb</code>.  Since this forward dataflow analysis
accumulates the dataflow-values from each predecessor block, we filter each set
keeping only the dataflow-elements that are defined in the basic block in the
map.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">alias-vars-unique-decls</span> (cfgraph)
  (<span style="color: #a020f0;">let*</span> ((alias-vars (alias-vars cfgraph))
         (forward (dataflow-forward
                   cfgraph
                   (make-dataflow-set)
                   (make-dataflow-set)
                   #'(<span style="color: #a020f0;">lambda</span> (bb v)
                       (find-original-decls (gethash bb alias-vars) v))
                   #'union))
         (result (empty-dataflow-map cfgraph)))
    (<span style="color: #a020f0;">loop</span> for bb being the hash-key in forward using (hash-value set)
       do (setf (gethash bb result) (filter-set bb set)))
    result))
</pre>
</div>

<p>
The following function modifies the declaration in the aliases in the
<code>to-modify-set</code> when there is an alias in the <code>to-compare-set</code> that has an
alias that is a <code>decl</code> in the <code>to-modify-set</code>.  The <code>decl</code> of the element in
the <code>to-modify-set</code> will point to the same <code>decl</code> of the element in the
<code>to-compare-set</code>.  
</p>

<p>
The function includes all elements of the <code>to-compare-set</code> in the result and
iterates over all elements in the <code>to-modify-set</code> and adds these to the result
set as well.  For each element in the <code>to-compare-set</code> we verify whether there
is an element that satisfies the condition of above and modify the element.
This means that this function is basically a union, but with a small twist.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-original-decls</span> (to-modify-set to-compare-set)
  (<span style="color: #a020f0;">let</span> ((result (make-dataflow-set (elements to-compare-set))))
    (<span style="color: #a020f0;">loop</span> for to-modify in (elements to-modify-set)
       do
         (<span style="color: #a020f0;">loop</span> for to-compare in (elements to-compare-set)
            do (<span style="color: #a020f0;">with-slots</span> (decl) to-modify
                      (<span style="color: #a020f0;">when</span> (eq (alias to-compare) decl)
                        (setf decl (decl to-compare)))))
         (add-to-set to-modify  result))
    result))
</pre>
</div>

<p>
The following function filters only the elements in set that have a basic block
that is similar to the basic block <code>bb</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">filter-set</span> (bb set)
  (make-dataflow-set (filter #'(<span style="color: #a020f0;">lambda</span> (alias)
                                 (eq (bb alias) bb))
                             (elements set))))
</pre>
</div>

<p>
The function <code>alias-vars</code> records all aliases but not with unique
declarations.  For example, in the example below we would like to record that
<code>a2</code> aliases to <code>decl1</code>, instead of to <code>a1</code>:
</p>

<pre class="example">
f(decl1, decl2) {
  a1 = decl1;     // &lt;decl1, a1&gt;
  a2 = a1;        // &lt;a1, a2&gt;
</pre>

<p>
The function creates a map and adds all aliases retrieved from the AST form
belonging to the basic block.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">alias-vars</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((bbs (mapcar #'element (vertexes cfgraph)))
        (map (make-hash-table)))
    (<span style="color: #a020f0;">dolist</span> (bb bbs)
      (<span style="color: #a020f0;">let</span> ((set (make-dataflow-set)))
         (get-alias-vars-from-bb bb set)
         (setf (gethash bb map) set)))
    map))
</pre>
</div>
</div>
</li>

<li><a id="org1d4cce0"></a>Other exported functions<br />
<div class="outline-text-6" id="text-org1d4cce0">
<p>
Retrieving the aliases that are known to be available at some point in the AST:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-aliases-ast</span> (ast)
  <span style="color: #8b2252;">"Retrieve a list of aliases that are available at the point of AST-form ast."</span>
  (<span style="color: #a020f0;">let*</span> ((func (get-func ast))
         (cfgraph (cfgraph func))
         (bb (get-basic-block-ast ast cfgraph)))
    (elements (gethash bb (aliases cfgraph)))))
</pre>
</div>

<p>
Retrieving the primary declaration from a variable or declaration:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-primary-decl</span> (var/var-expr/decl)
  <span style="color: #8b2252;">"Retrieve the primary declaration of the variable.</span>

<span style="color: #8b2252;">The var can be a var, var-expr, decl.   A primary declaration is a declaration</span>
<span style="color: #8b2252;">that did not have any aliases when it was first declared."</span>
  (get-primary-decl-with-aliases
   var/var-expr/decl (get-aliases-ast var/var-expr/decl)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-primary-decl-with-aliases</span> (var/var-expr/decl aliases))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-primary-decl-with-aliases</span> ((ve var-expr) aliases)
  (get-primary-decl-with-aliases (var ve) aliases))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-primary-decl-with-aliases</span> ((v var) aliases)
  (get-primary-decl-with-aliases (get-decl-var v) aliases))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-primary-decl-with-aliases</span> ((d decl) aliases)
  (<span style="color: #a020f0;">let</span> ((primary-decls (remove-duplicates
                        (mapcar #'decl
                                (filter #'(<span style="color: #a020f0;">lambda</span> (alias)
                                            (eq (alias alias) d)) <span style="color: #ff0000; font-weight: bold;">aliases)))))</span>
    (<span style="color: #a020f0;">cond</span> ((null primary-decls)
           d)
          ((eql (length primary-decls) 1)
           (first primary-decls))
          (t
           (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"More than one primary decl."</span>)))))
</pre>
</div>

<p>
Retrieve the declarations that are aliased to 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-decls-aliased-to-var</span> (var/var-expr/decl)
  <span style="color: #8b2252;">"Retrieve a list of decls that are aliased to var.</span>

<span style="color: #8b2252;">The var can be a var, var-expr, decl."</span>
  (get-decls-aliased-to-var-with-aliases
   var/var-expr/decl (get-aliases-ast var/var-expr/decl)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-decls-aliased-to-var-with-aliases</span> (var/var-expr/decl aliases))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-decls-aliased-to-var-with-aliases</span> ((ve var-expr) aliases)
  (get-decls-aliased-to-var-with-aliases (var ve) aliases))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-decls-aliased-to-var-with-aliases</span> ((v var) aliases)
  (get-decls-aliased-to-var-with-aliases (get-decl-var v) aliases))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-decls-aliased-to-var-with-aliases</span> ((d decl) aliases)
  (<span style="color: #a020f0;">let</span> ((primary-decl (get-primary-decl-with-aliases d aliases)))
    (remove d (cons primary-decl
                    (remove-duplicates
                     (mapcar #'alias (filter #'(<span style="color: #a020f0;">lambda</span> (alias)
                                                 (eq (decl alias) primary-decl))
                                             aliases)))))))
</pre>
</div>
</div>
</li>



<li><a id="orgd457e95"></a>Retrieving the alias variables from the AST<br />
<div class="outline-text-6" id="text-orgd457e95">
<p>
The function <code>get-alias-from-bb</code> retrieves the aliases from the basic block and
store them into <code>set</code>.  Basically, we only have to investigate statements:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-alias-vars-from-bb</span> (bb set))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-alias-vars-from-bb</span> ((bb bb) set) set)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-alias-vars-from-bb</span> ((bb bb-stat) set)
  (get-alias-vars-from-stat (stat bb) set bb))
</pre>
</div>

<p>
We only have to analyze <code>assign-statements</code> and declaration statements:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-alias-vars-from-stat</span> (stat set bb))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-alias-vars-from-stat</span> ((s stat) set bb) set)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-alias-vars-from-stat</span> ((ds decl-stat) set bb)
  (get-alias-vars-from-decl (decl ds) set bb))
</pre>
</div>

<p>
For an assignment if the types of the variable and expression are not
primitive, we either add a tile or an alias to the set:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-alias-vars-from-stat</span> ((as assign-stat) set bb)
  (<span style="color: #a020f0;">with-slots</span> (var expr) as
    (<span style="color: #a020f0;">when</span> (typep expr 'var-expr)
      (<span style="color: #a020f0;">let</span> ((type-var (get-type var))
            (type-expr (eval-type expr)))
        (<span style="color: #a020f0;">cond</span> ((and (primitive-type-p type-var)
                    (primitive-type-p type-expr))
               nil)
              ((tile-expr-p expr)
               (add-to-set (make-tile expr var bb) set))
              (t
               (add-to-set (make-alias expr var bb) set)))))))
</pre>
</div>

<p>
For declarations, we only have to analyze assignment declarations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">get-alias-vars-from-decl</span> (decl set bb))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-alias-vars-from-decl</span> ((ad assign-decl) set bb)
  (<span style="color: #a020f0;">with-slots</span> (expr) ad
    (<span style="color: #a020f0;">when</span> (typep expr 'var-expr)
        (<span style="color: #a020f0;">let</span> ((type-decl (get-type-decl ad))
              (type-expr (eval-type expr)))
          (<span style="color: #a020f0;">cond</span> ((and (primitive-type-p type-decl)
                      (primitive-type-p type-expr))
                 nil)
                ((tile-expr-p expr)
                 (add-to-set (make-tile expr ad bb) set))
                (t
                 (add-to-set (make-alias expr ad bb) set)))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">get-alias-vars-from-decl</span> ((nd normal-decl) set bb))
</pre>
</div>
</div>
</li>

<li><a id="org3f5951a"></a>Helper functions<br />
<div class="outline-text-6" id="text-org3f5951a">
<p>
The following helper functions make things a bit easier:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tile-expr-p</span> (expr)
  (not (ast= (get-type (get-decl-var (var expr)))
             (eval-type expr))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-tile</span> (decl alias bb)
  (make-tile/alias decl alias bb 'tile))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-alias</span> (decl alias bb)
  (make-tile/alias decl alias bb 'alias))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">make-tile/alias</span> (decl alias bb type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">make-tile/alias</span> ((ve var-expr) (v var) bb type)
  (make-tile/alias (get-decl-var ve) (get-decl-var v) bb type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">make-tile/alias</span> ((ve var-expr) (alias decl) bb type)
  (make-tile/alias (get-decl-var ve) alias bb type))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">make-tile/alias</span> ((decl decl) (alias decl) bb type)
  (make-instance type <span style="color: #483d8b;">:decl</span> decl <span style="color: #483d8b;">:alias</span> alias <span style="color: #483d8b;">:bb</span> bb))
</pre>
</div>

<p>
We also have to take into account printing aliases and equality of aliases:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-object</span> ((d alias) stream)
  (print-unreadable-object (d stream <span style="color: #483d8b;">:type</span> t)
    (format stream <span style="color: #8b2252;">"~a: ~a, ~a"</span> (bb d) (decl d) (alias d))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dataflow-element</span> ((d alias))
  (format nil <span style="color: #8b2252;">"&lt;d: ~a, a: ~a, at: ~a&gt;"</span> (pp (decl d)) (pp (alias d)) (print-bb (bb d))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">eq-dataflow-element</span> (e1 e2)
  (<span style="color: #483d8b;">:method-combination</span> and))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-dataflow-element</span> and ((a1 alias) (a2 alias))
  (ast= (alias a1) (alias a2)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-dataflow-element</span> and ((a1 tile) (a2 tile))
  (ast= (alias a1) (alias a2)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-dataflow-element</span> and ((a1 alias) (a2 tile))
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">eq-dataflow-element</span> and ((a1 tile) (a2 alias))
  nil)
</pre>
</div>
</div>
</li>
</ul>
</div>





<div id="outline-container-org53d2477" class="outline-5">
<h5 id="org53d2477"><span class="section-number-5">7.7.2.3</span> Testing</h5>
<div class="outline-text-5" id="text-7-7-2-3">
</div>
<ul class="org-ul">
<li><a id="org5a0244a"></a>The package<br />
<div class="outline-text-6" id="text-org5a0244a">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-aliases</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:aliases</span>
        <span style="color: #483d8b;">:test-dataflow-library</span> <span style="color: #483d8b;">:build-ast</span>)
  (<span style="color: #483d8b;">:shadow</span> <span style="color: #483d8b;">:get-cfgraph</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-aliases</span>))
</pre>
</div>
</div>
</li>

<li><a id="org100cb09"></a>The tests<br />
<div class="outline-text-6" id="text-org100cb09">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite aliases <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite aliases)


(test vars
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                   module a;</span>
<span style="color: #8b2252;">                   perfect void f(int h, int w, float[h][w] input) {</span>
<span style="color: #8b2252;">                     float[w] input1D = input[2];</span>
<span style="color: #8b2252;">                   }"</span>)
         (cfgraph (get-cfgraph input))
         (result (map-&gt;compare-set (aliases::alias-vars cfgraph) cfgraph))
         (assign-decl (build-decl <span style="color: #8b2252;">"input1D"</span> '((<span style="color: #8b2252;">"w"</span>))
                                  nil (build-expr <span style="color: #8b2252;">"input"</span> '((2)))))
         (decl (build-decl <span style="color: #8b2252;">"input"</span> '((<span style="color: #8b2252;">"h"</span>) (<span style="color: #8b2252;">"w"</span>))))
         (stat (make-decl-stat assign-decl))
         (bb (make-bb-stat stat))
         (tile (make-tile decl assign-decl bb))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element (build-decl <span style="color: #8b2252;">"h"</span>) (build-dataflow-set))
                  (build-element (build-decl <span style="color: #8b2252;">"w"</span>) (build-dataflow-set))
                  (build-element decl (build-dataflow-set))
                  (build-element stat (build-dataflow-set tile))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (is (set= wanted result)))
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                   module a;</span>
<span style="color: #8b2252;">                   perfect void f(int n, float[n] decl) {</span>
<span style="color: #8b2252;">                     float[n] alias1 = decl;</span>
<span style="color: #8b2252;">                     float[n] alias2 = alias1;</span>
<span style="color: #8b2252;">                   }"</span>)
         (cfgraph (get-cfgraph input))
         (result (map-&gt;compare-set (aliases::alias-vars cfgraph) cfgraph))
         (assign-decl1 (build-decl <span style="color: #8b2252;">"alias1"</span> '((<span style="color: #8b2252;">"n"</span>))
                                   nil (build-expr <span style="color: #8b2252;">"decl"</span>)))
         (assign-decl2 (build-decl <span style="color: #8b2252;">"alias2"</span> '((<span style="color: #8b2252;">"n"</span>))
                                   nil (build-expr <span style="color: #8b2252;">"alias1"</span>)))
         (decl (build-decl <span style="color: #8b2252;">"decl"</span> '((<span style="color: #8b2252;">"n"</span>))))
         (stat1 (make-decl-stat assign-decl1))
         (stat2 (make-decl-stat assign-decl2))
         (bb1 (make-bb-stat stat1))
         (bb2 (make-bb-stat stat2))
         (alias1 (make-alias decl assign-decl1 bb1))
         (alias2 (make-alias assign-decl1 assign-decl2 bb2))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element (build-decl <span style="color: #8b2252;">"n"</span>) (build-dataflow-set))
                  (build-element decl (build-dataflow-set))
                  (build-element stat1 (build-dataflow-set alias1))
                  (build-element stat2 (build-dataflow-set alias2))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (is (set= wanted result))))

(test unique-decls
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                   module a;</span>
<span style="color: #8b2252;">                   perfect void f(int n, float[n] decl) {</span>
<span style="color: #8b2252;">                     float[n] alias1 = decl;</span>
<span style="color: #8b2252;">                     float[n] alias2 = alias1;</span>
<span style="color: #8b2252;">                   }"</span>)
         (cfgraph (get-cfgraph input))
         (result (map-&gt;compare-set
                  (aliases::alias-vars-unique-decls cfgraph) cfgraph))
         (assign-decl1 (build-decl <span style="color: #8b2252;">"alias1"</span> '((<span style="color: #8b2252;">"n"</span>))
                                   nil (build-expr <span style="color: #8b2252;">"decl"</span>)))
         (assign-decl2 (build-decl <span style="color: #8b2252;">"alias2"</span> '((<span style="color: #8b2252;">"n"</span>))
                                   nil (build-expr <span style="color: #8b2252;">"alias1"</span>)))
         (decl (build-decl <span style="color: #8b2252;">"decl"</span> '((<span style="color: #8b2252;">"n"</span>))))
         (stat1 (make-decl-stat assign-decl1))
         (stat2 (make-decl-stat assign-decl2))
         (bb1 (make-bb-stat stat1))
         (bb2 (make-bb-stat stat2))
         (alias1 (make-alias decl assign-decl1 bb1))
         (alias2 (make-alias decl assign-decl2 bb2))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element (build-decl <span style="color: #8b2252;">"n"</span>) (build-dataflow-set))
                  (build-element decl (build-dataflow-set))
                  (build-element stat1 (build-dataflow-set alias1))
                  (build-element stat2 (build-dataflow-set alias2))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (is (set= wanted result))))

(test simple
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                   module a;</span>
<span style="color: #8b2252;">                   perfect void f(int h, int w, float[h][w] input) {</span>
<span style="color: #8b2252;">                     float[w] input1D = input[2];</span>
<span style="color: #8b2252;">                   }"</span>)
         (cfgraph (get-cfgraph input))
         (result (map-&gt;compare-set (aliases cfgraph) cfgraph))
         (assign-decl (build-decl <span style="color: #8b2252;">"input1D"</span> '((<span style="color: #8b2252;">"w"</span>))
                                  nil (build-expr <span style="color: #8b2252;">"input"</span> '((2)))))
         (decl (build-decl <span style="color: #8b2252;">"input"</span> '((<span style="color: #8b2252;">"h"</span>) (<span style="color: #8b2252;">"w"</span>))))
         (stat (make-decl-stat assign-decl))
         (bb (make-bb-stat stat))
         (tile (make-alias decl assign-decl bb))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element (build-decl <span style="color: #8b2252;">"h"</span>) (build-dataflow-set))
                  (build-element (build-decl <span style="color: #8b2252;">"w"</span>) (build-dataflow-set))
                  (build-element decl (build-dataflow-set))
                  (build-element stat (build-dataflow-set tile))
                  (build-element (make-bb-exit) (build-dataflow-set tile)))))
    (is (set= wanted result))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-cfgraph</span> (input)
  (<span style="color: #a020f0;">multiple-value-bind</span> (cfgraph ast) (test-dataflow-library:get-cfgraph input)
    (check-types:check-types ast)
    cfgraph))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">should go to dataflow-test-library</span>
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">add-to-map</span> (map stat dataflow-variable))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-to-map</span> (map (stat stat) dataflow-variable)
  (<span style="color: #a020f0;">loop</span> for bb being the hash-keys in map
     do (<span style="color: #a020f0;">when</span> (and (typep bb 'bb-stat)
                   (ast= stat (stat bb)))
          (add-to-set dataflow-variable (gethash bb map)))))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*cfgraph*</span> nil)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">bla</span> ()
  (<span style="color: #a020f0;">let</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                   module a;</span>
<span style="color: #8b2252;">                   perfect void f(int h, int w, float[h][w] input) {</span>
<span style="color: #8b2252;">                     float[w] input1D = input[2];</span>
<span style="color: #8b2252;">                   }"</span>))
    (<span style="color: #a020f0;">multiple-value-bind</span> (cfgraph ast) (get-cfgraph input)
      (check-types:check-types ast)
      (setf *cfgraph* cfgraph)
      (aliases::alias-vars cfgraph))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgc60f822" class="outline-4">
<h4 id="orgc60f822"><span class="section-number-4">7.7.3</span> Dependencies</h4>
<div class="outline-text-4" id="text-7-7-3">
<p>
This pass gives all kinds of access to dependencies.
</p>
</div>

<div id="outline-container-org0493459" class="outline-5">
<h5 id="org0493459"><span class="section-number-5">7.7.3.1</span> The package</h5>
<div class="outline-text-5" id="text-7-7-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:dependencies</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span>
        <span style="color: #483d8b;">:reaching-definitions</span> <span style="color: #483d8b;">:uses</span> <span style="color: #483d8b;">:definitions</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:anaphora</span> <span style="color: #483d8b;">:awhen</span> <span style="color: #483d8b;">:it</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span> <span style="color: #483d8b;">:fixed-point</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:defs-before-uses</span>
           <span style="color: #483d8b;">:direct-defs-before-uses</span>
           <span style="color: #483d8b;">:get-defs-before-uses-ast</span>
           <span style="color: #483d8b;">:get-direct-defs-before-uses-ast</span>

           <span style="color: #483d8b;">:defs-after-uses</span>
           <span style="color: #483d8b;">:get-defs-after-uses-ast</span>

           <span style="color: #483d8b;">:defs-after-defs</span>
           <span style="color: #483d8b;">:get-defs-after-defs-ast</span>

           <span style="color: #483d8b;">:uses-after-uses</span>
           <span style="color: #483d8b;">:get-uses-after-uses-ast</span>

           <span style="color: #483d8b;">:uses-before-uses</span>
           <span style="color: #483d8b;">:get-uses-before-uses-ast</span>

           <span style="color: #483d8b;">:uses-after-defs</span>
           <span style="color: #483d8b;">:get-uses-after-defs-ast</span>

           <span style="color: #483d8b;">:defs-before-defs</span>
           <span style="color: #483d8b;">:get-defs-before-defs-ast</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org698cd0b" class="outline-5">
<h5 id="org698cd0b"><span class="section-number-5">7.7.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-7-3-2">
</div>

<ul class="org-ul">
<li><a id="org5683aae"></a>Definitions before uses<br />
<div class="outline-text-6" id="text-org5683aae">
<p>
The <code>defs-before-uses</code> function of a control flow graph gives all the
dependencies of a control-flow block.  They are formed with the
<code>defs-before-uses-*</code> functions from the <code>:dataflow</code> package which only gives
the direct definitions of a use.  This function corrects for control-flow using
reaching definitions and discovers the indirect dependencies.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defs-before-uses</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((in/out 0))
    (take-closure
     cfgraph
     (correct-with-reaching-definitions
      cfgraph (defs-with-uses cfgraph) in/out)
     in/out)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">direct-defs-before-uses</span> (cfgraph)
  (correct-with-reaching-definitions cfgraph (defs-with-uses cfgraph) 0))
</pre>
</div>

<p>
The following function gives the dependencies of a particular statement:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-defs-before-uses-ast</span> (stat)
  (get-dataflow-elements-ast
   stat #'defs-before-uses))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-direct-defs-before-uses-ast</span> (stat)
  (get-dataflow-elements-ast
   stat #'direct-defs-before-uses))
</pre>
</div>
</div>
</li>


<li><a id="org46e4ed6"></a>Definitions after uses<br />
<div class="outline-text-6" id="text-org46e4ed6">
<p>
The <code>defs-after-uses</code> function of a control flow graph gives all the
uses of a control-flow block with a definition.  They are formed with the
<code>defs-with-uses-*</code> functions from the <code>:dataflow</code> package which only gives
the direct definitions of a use.  This function corrects for control-flow using
reaching definitions and discovers the indirect dependencies.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:dependencies</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defs-after-uses</span> (cfgraph)
  (correct-with-following-definitions
      cfgraph (defs-with-uses cfgraph) 0))
</pre>
</div>

<p>
The following function gives the definitions after the uses of a stat.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-defs-after-uses-ast</span> (stat)
  (get-dataflow-elements-ast
   stat #'defs-after-uses))
</pre>
</div>
</div>
</li>

<li><a id="orgeee442c"></a>Definitions after definitions<br />
<div class="outline-text-6" id="text-orgeee442c">
<p>
The <code>defs-after-defs</code> function of a control flow graph gives all the
definitions of a control-flow block right after this control-flow-block.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defs-after-defs</span> (cfgraph)
  (correct-with-following-definitions
   cfgraph (kill-definitions cfgraph) 1))
</pre>
</div>

<p>
The following function gives the dependencies of a particular statement:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-defs-after-defs-ast</span> (stat)
  (get-dataflow-elements-ast
   stat #'defs-after-defs))
</pre>
</div>
</div>
</li>

<li><a id="org4d990fc"></a>Uses after uses<br />
<div class="outline-text-6" id="text-org4d990fc">
<p>
The following function gives given a basic block, the uses of the uses within
that basic block after this basic block.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">uses-after-uses</span> (cfgraph)
  (correct-with-following-uses cfgraph (uses-with-uses cfgraph) 1))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-uses-after-uses-ast</span> (stat)
  (get-dataflow-elements-ast stat #'uses-after-uses))
</pre>
</div>
</div>
</li>

<li><a id="orgce7fcea"></a>Uses before uses<br />
<div class="outline-text-6" id="text-orgce7fcea">
<p>
The following functions give, given a basic block, the uses of the uses within
that basic block before this basic block.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">uses-before-uses</span> (cfgraph)
  (correct-with-reaching-uses cfgraph (uses-with-uses cfgraph) 1))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-uses-before-uses-ast</span> (stat)
  (get-dataflow-elements-ast stat #'uses-before-uses))
</pre>
</div>
</div>
</li>

<li><a id="org84d4132"></a>Uses after defs<br />
<div class="outline-text-6" id="text-org84d4132">
<p>
The following functions give, given a basic block, the uses of the uses within
that basic block before this basic block.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">uses-after-defs</span> (cfgraph)
  (correct-with-following-uses cfgraph (uses-with-defs cfgraph) 0))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-uses-after-defs-ast</span> (ast)
  (get-dataflow-elements-ast ast #'uses-after-defs))
</pre>
</div>
</div>
</li>

<li><a id="orgc0a8650"></a>Definitions before definitions<br />
<div class="outline-text-6" id="text-orgc0a8650">
<p>
The <code>defs-before-defs</code> function of a control flow graph gives all the
definitions of a control-flow block right after this control-flow-block.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defs-before-defs</span> (cfgraph)
  (correct-with-reaching-definitions
   cfgraph (kill-definitions cfgraph) 1))
</pre>
</div>

<p>
The following function gives the dependencies of a particular statement:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-defs-before-defs-ast</span> (stat)
  (get-dataflow-elements-ast
   stat #'defs-before-defs))
</pre>
</div>
</div>
</li>


<li><a id="org2cd3703"></a>Definitions with uses<br />
<div class="outline-text-6" id="text-org2cd3703">
<p>
The <code>defs-with-uses</code> functions returns a mapping from basic-blocks to a set
of definitions that are used in the basic block.  This basicly states that a
basic block depends directly on another basic block that defines a declaration.
</p>

<p>
An example of an element of the map is: <code>bb1 -&gt; bb2 . decl1</code>, or basic block
<code>bb1</code> uses a variable that is defined in <code>bb2</code> and the declaration of that
variable is <code>decl1</code>.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">defs-with-uses</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((uses (uses cfgraph))
        (defs (definitions cfgraph)))
    (combine uses defs
             (constantly t)
             #'(<span style="color: #a020f0;">lambda</span> (use def) (eq (decl use) (decl def)))
             #'(<span style="color: #a020f0;">lambda</span> (use def) (<span style="color: #a020f0;">declare</span> (ignore use)) def))))
</pre>
</div>
</div>
</li>



<li><a id="orge7c4c39"></a>Uses with definitions<br />
<div class="outline-text-6" id="text-orge7c4c39">
<p>
The <code>use-with-defs</code> function returns a mapping from basic-block to a set of
 of uses that use the definition in that block.   
</p>

<p>
An example of an instance of the map is: <code>bb1 -&gt; bb2 . decl1</code>, or basic block
<code>bb1</code> defines a variable that is used in <code>bb2</code> and the declaration of that
variable is <code>decl1</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">uses-with-defs</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((uses (uses cfgraph))
        (defs (definitions cfgraph)))
    (combine defs uses
             (constantly t)
             #'(<span style="color: #a020f0;">lambda</span> (def use) (eq (decl def) (decl use)))
             #'(<span style="color: #a020f0;">lambda</span> (def use) (<span style="color: #a020f0;">declare</span> (ignore def)) use))))
</pre>
</div>
</div>
</li>

<li><a id="org50777a0"></a>Uses with uses<br />
<div class="outline-text-6" id="text-org50777a0">
<p>
The following functions create a mapping from a use to any other use with the
same declaration.  It is an over-approximation of uses after uses and also
uses before uses.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">uses-with-uses</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((uses (uses cfgraph)))
    (combine uses uses
             (constantly t)
             #'(<span style="color: #a020f0;">lambda</span> (use1 use2) (eq (decl use1) (decl use2)))
             #'(<span style="color: #a020f0;">lambda</span> (use1 use2) (<span style="color: #a020f0;">declare</span> (ignore use1)) use2))))
</pre>
</div>
</div>
</li>


<li><a id="orgead0e58"></a>Utility functions<br />
<div class="outline-text-6" id="text-orgead0e58">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-dataflow-elements-ast</span> (ast func)
  (get-dataflow-elements-ast2 ast (funcall func (cfgraph (get-func ast)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-dataflow-elements-ast2</span> (ast map)
  (<span style="color: #a020f0;">let</span> ((basic-blocks-ast (ast-&gt;basic-blocks ast))
        (set (make-set)))
    (<span style="color: #a020f0;">dolist</span> (bb basic-blocks-ast)
      (awhen (gethash bb map)
        (add-all-to-set (elements it) set)))
    (filter #'(<span style="color: #a020f0;">lambda</span> (v)
                (not (member (bb v) basic-blocks-ast)))
            (elements set))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">take-closure</span> (cfgraph map out/in)
  (<span style="color: #a020f0;">let</span> ((reaching-definitions
         (nth-value out/in (reaching-definitions cfgraph))))
    (fixed-point map #'dataflow::copy #'dataflow::compare
      (maphash #'(<span style="color: #a020f0;">lambda</span> (k v)
                   (<span style="color: #a020f0;">dolist</span> (definition (elements v))
                     (add-all-to-set
                      (elements (intersection
                                 (gethash k reaching-definitions)
                                 (gethash (bb definition) map)))
                      v)))
               map))
    map))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">correct-with-reaching-definitions</span> (cfgraph func out/in)
  (correct-with-reaching/following cfgraph func #'reaching-definitions out/in))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">correct-with-following-definitions</span> (cfgraph func out/in)
  (correct-with-reaching/following cfgraph func #'following-definitions out/in))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">correct-with-reaching-uses</span> (cfgraph func out/in)
  (correct-with-reaching/following cfgraph func #'reaching-uses out/in))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">correct-with-following-uses</span> (cfgraph func out/in)
  (correct-with-reaching/following cfgraph func #'following-uses out/in))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">correct-with-reaching/following</span> (cfgraph func reaching-func out/in)
  (<span style="color: #a020f0;">let</span> ((reaching-following (nth-value out/in (funcall reaching-func cfgraph)))
        (map (make-hash-table)))
    (<span style="color: #a020f0;">dolist</span> (bb (basic-blocks cfgraph))
      (setf (gethash bb map) (intersection
                                         (gethash bb reaching-following)
                                         (gethash bb func))))
    map))
</pre>
</div>
</div>
</li>
</ul>
</div>




<div id="outline-container-orgf7913aa" class="outline-5">
<h5 id="orgf7913aa"><span class="section-number-5">7.7.3.3</span> Testing dependencies</h5>
<div class="outline-text-5" id="text-7-7-3-3">
</div>
<ul class="org-ul">
<li><a id="org70d4d80"></a>The package<br />
<div class="outline-text-6" id="text-org70d4d80">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-dependencies</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:simple-sets</span>
        <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span>
        <span style="color: #483d8b;">:test-dataflow-library</span> <span style="color: #483d8b;">:build-ast</span> <span style="color: #483d8b;">:dependencies</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-dependencies</span>))
</pre>
</div>
</div>
</li>

<li><a id="org3233845"></a>Top-level<br />
<div class="outline-text-6" id="text-org3233845">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite dependencies <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite dependencies)
</pre>
</div>
</div>
</li>


<li><a id="orgdf9935a"></a>Testing defs-with-uses<br />
<div class="outline-text-6" id="text-orgdf9935a">
<div class="org-src-container">
<pre class="src src-lisp">(test defs-with-uses
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                      b = 2;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (assign-stat-b (build-assign-stat <span style="color: #8b2252;">"b"</span> 2))
         (cfgraph (get-cfgraph input))
         (result (map-&gt;compare-set
                  (dependencies::defs-with-uses cfgraph) cfgraph))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set))
                  (build-element decl-stat-b
                                 (build-dataflow-set
                                  (build-definition
                                   (decl decl-stat-a) decl-stat-a)))
                  (build-element decl-stat-c
                                 (build-dataflow-set
                                  (build-definition
                                   (decl decl-stat-b) decl-stat-b)
                                  (build-definition
                                   (decl decl-stat-b) assign-stat-b)))
                  (build-element assign-stat-b (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (is (set= result wanted))))
</pre>
</div>
</div>
</li>




<li><a id="org58becef"></a>Testing dependencies<br />
<div class="outline-text-6" id="text-org58becef">
<div class="org-src-container">
<pre class="src src-lisp">(test dependencies-simple
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                      b = 2;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (assign-stat-b (build-assign-stat <span style="color: #8b2252;">"b"</span> 2))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set))
                  (build-element decl-stat-b
                                 (build-dataflow-set
                                  (build-definition (decl decl-stat-a) decl-stat-a)))
                  (build-element decl-stat-c
                                 (build-dataflow-set
                                  (build-definition (decl decl-stat-b) decl-stat-b)
                                  (build-definition (decl decl-stat-a) decl-stat-a)))
                  (build-element assign-stat-b (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (is (set= (map-&gt;compare-set (defs-before-uses cfgraph) cfgraph) wanted))))

(test dependencies-backwards
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 1;</span>


<span style="color: #8b2252;">                      int c = 3;</span>
<span style="color: #8b2252;">                      int d = c;</span>
<span style="color: #8b2252;">                      c = a;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 1))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil 3))
         (decl-stat-d (build-decl-stat <span style="color: #8b2252;">"d"</span> nil nil <span style="color: #8b2252;">"c"</span>))
         (assign-stat-c-a (build-assign-stat <span style="color: #8b2252;">"c"</span> <span style="color: #8b2252;">"a"</span>))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set))
                  (build-element decl-stat-c (build-dataflow-set))
                  (build-element decl-stat-d
                                 (build-dataflow-set
                                  (build-definition
                                   (decl decl-stat-c)
                                   decl-stat-c)))
                  (build-element assign-stat-c-a
                                 (build-dataflow-set
                                  (build-definition
                                   (decl decl-stat-a)
                                   decl-stat-a)))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (is (set= (map-&gt;compare-set (defs-before-uses cfgraph) cfgraph) wanted))))

</pre>
</div>
</div>
</li>



<li><a id="orge6ef7fa"></a>Testing uses after uses<br />
<div class="outline-text-6" id="text-orge6ef7fa">
<div class="org-src-container">
<pre class="src src-lisp">(test uses-after-uses
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                      int d = a;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (decl-stat-d (build-decl-stat <span style="color: #8b2252;">"d"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set))
                  (build-element decl-stat-b (build-dataflow-set
                                              (build-use (decl decl-stat-a) decl-stat-d)))
                  (build-element decl-stat-c (build-dataflow-set))
                  (build-element decl-stat-d (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (<span style="color: #a020f0;">let</span> ((result (dependencies::uses-after-uses cfgraph)))
      (is (set= (map-&gt;compare-set result cfgraph) wanted)))))
</pre>
</div>
</div>
</li>

<li><a id="org89c4b41"></a>Testing defs after uses<br />
<div class="outline-text-6" id="text-org89c4b41">
<div class="org-src-container">
<pre class="src src-lisp">(test defs-after-uses
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                      a = 3;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (assign-stat-a (build-assign-stat <span style="color: #8b2252;">"a"</span> 3))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set))
                  (build-element decl-stat-b (build-dataflow-set
                                              (build-definition (decl decl-stat-a) assign-stat-a)))
                  (build-element decl-stat-c (build-dataflow-set))
                  (build-element assign-stat-a (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (<span style="color: #a020f0;">let</span> ((result (defs-after-uses cfgraph)))
      (is (set= (map-&gt;compare-set result cfgraph) wanted)))))
</pre>
</div>
</div>
</li>


<li><a id="org4533d9d"></a>Testing uses after defs<br />
<div class="outline-text-6" id="text-org4533d9d">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*cfgraph*</span> nil)

(test uses-after-defs
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                      int d = a;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (decl-stat-d (build-decl-stat <span style="color: #8b2252;">"d"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element
                   decl-stat-a
                   (build-dataflow-set
                    (build-use (decl decl-stat-a) decl-stat-b)
                    (build-use (decl decl-stat-a) decl-stat-d)))
                  (build-element
                   decl-stat-b
                   (build-dataflow-set
                    (build-use (decl decl-stat-b) decl-stat-c)))
                  (build-element decl-stat-c (build-dataflow-set))
                  (build-element decl-stat-d (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (<span style="color: #a020f0;">let</span> ((result (uses-after-defs cfgraph)))
      (setf *cfgraph* cfgraph)
      (is (set= (map-&gt;compare-set result cfgraph) wanted)))))
</pre>
</div>
</div>
</li>



<li><a id="org6b6416e"></a>Testing defs before defs<br />
<div class="outline-text-6" id="text-org6b6416e">
<div class="org-src-container">
<pre class="src src-lisp">(test defs-before-defs
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                      a = 3;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (assign-stat-a (build-assign-stat <span style="color: #8b2252;">"a"</span> 3))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set))
                  (build-element decl-stat-b (build-dataflow-set))
                  (build-element decl-stat-c (build-dataflow-set))
                  (build-element assign-stat-a (build-dataflow-set
                                                (build-definition (decl decl-stat-a) decl-stat-a)))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (<span style="color: #a020f0;">let</span> ((result (defs-before-defs cfgraph)))
      (is (set= (map-&gt;compare-set result cfgraph) wanted)))))
</pre>
</div>
</div>
</li>


<li><a id="org5b5ab82"></a>Testing defs after defs<br />
<div class="outline-text-6" id="text-org5b5ab82">
<div class="org-src-container">
<pre class="src src-lisp">(test defs-after-defs
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                      a = 3;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (assign-stat-a (build-assign-stat <span style="color: #8b2252;">"a"</span> 3))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set
                                              (build-definition (decl decl-stat-a) assign-stat-a)))
                  (build-element decl-stat-b (build-dataflow-set))
                  (build-element decl-stat-c (build-dataflow-set))
                  (build-element assign-stat-a (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (<span style="color: #a020f0;">let</span> ((result (defs-after-defs cfgraph)))
      (is (set= (map-&gt;compare-set result cfgraph) wanted)))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>



<div id="outline-container-org8cae35c" class="outline-4">
<h4 id="org8cae35c"><span class="section-number-4">7.7.4</span> Reaching definitions</h4>
<div class="outline-text-4" id="text-7-7-4">
</div>
<div id="outline-container-org7fb6dc4" class="outline-5">
<h5 id="org7fb6dc4"><span class="section-number-5">7.7.4.1</span> The package</h5>
<div class="outline-text-5" id="text-7-7-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:reaching-definitions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:definitions</span> <span style="color: #483d8b;">:uses</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:compose</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:reaching-definitions</span> <span style="color: #483d8b;">:following-definitions</span> 
           <span style="color: #483d8b;">:reaching-uses</span> <span style="color: #483d8b;">:following-uses</span>

           <span style="color: #483d8b;">:gen-definitions</span>
           <span style="color: #483d8b;">:kill-definitions</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga52eb47" class="outline-5">
<h5 id="orga52eb47"><span class="section-number-5">7.7.4.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-7-4-2">
<p>
The following dataflow-analyses have been defined.  The forward/backward
parameter determines whether dataflow values go forward in the control-flow or
backward.  The entry function defines the dataflow-value at the entry.  The top
function initializes IN or OUT (depending on the direction) to an initial value
that should be the neutral element.  The transfer function determines in which
way dataflow-values are transfered from IN to OUT and is dependent on the
semantics of the statement.  The meet function determines what happens between
predecessors and successors in the graph.
</p>

<p>
Reaching definitions:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">parameter</th>
<th scope="col" class="org-left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">forward/backward</td>
<td class="org-left">forward</td>
</tr>

<tr>
<td class="org-left">entry</td>
<td class="org-left">empty set</td>
</tr>

<tr>
<td class="org-left">top</td>
<td class="org-left">function that returns the empty set</td>
</tr>

<tr>
<td class="org-left">transfer-function</td>
<td class="org-left">union with difference</td>
</tr>

<tr>
<td class="org-left">meet-function</td>
<td class="org-left">union</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reaching-definitions</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-definitions cfgraph))
        (kill (kill-definitions cfgraph)))
    (dataflow-forward
     cfgraph
     (make-dataflow-set)
     (make-dataflow-set)
     #'(<span style="color: #a020f0;">lambda</span> (bb v)
         (union (gethash bb gen) (set-difference v (gethash bb kill))))
     #'union)))
</pre>
</div>

<p>
Following definitions:
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">parameter</th>
<th scope="col" class="org-left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">forward/backward</td>
<td class="org-left">forward</td>
</tr>

<tr>
<td class="org-left">entry</td>
<td class="org-left">empty set</td>
</tr>

<tr>
<td class="org-left">top</td>
<td class="org-left">function that returns the empty set</td>
</tr>

<tr>
<td class="org-left">transfer-function</td>
<td class="org-left">union with difference</td>
</tr>

<tr>
<td class="org-left">meet-function</td>
<td class="org-left">union</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">following-definitions</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-definitions cfgraph))
        (kill (kill-definitions cfgraph)))
    (dataflow-backward
     cfgraph
     (make-dataflow-set)
     (make-dataflow-set)
     #'(<span style="color: #a020f0;">lambda</span> (bb v)
         (union (gethash bb gen) (set-difference v (gethash bb kill))))
     #'union)))
</pre>
</div>



<p>
For reaching-uses, the following parameters are used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">parameter</th>
<th scope="col" class="org-left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">forward/backward</td>
<td class="org-left">forward</td>
</tr>

<tr>
<td class="org-left">entry</td>
<td class="org-left">empty set</td>
</tr>

<tr>
<td class="org-left">top</td>
<td class="org-left">function that returns the empty set</td>
</tr>

<tr>
<td class="org-left">transfer-function</td>
<td class="org-left">union</td>
</tr>

<tr>
<td class="org-left">meet-function</td>
<td class="org-left">union</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">reaching-uses</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((uses (uses cfgraph)))
    (dataflow-forward
     cfgraph
     (make-dataflow-set)
     (make-dataflow-set)
     #'(<span style="color: #a020f0;">lambda</span> (bb v)
         (union v (gethash bb uses)))
     #'union)))
(add-forward-dataflow-analysis 'reaching-uses)
</pre>
</div>

<p>
For following-uses, the following parameters are used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">parameter</th>
<th scope="col" class="org-left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">forward/backward</td>
<td class="org-left">backward</td>
</tr>

<tr>
<td class="org-left">entry</td>
<td class="org-left">empty set</td>
</tr>

<tr>
<td class="org-left">top</td>
<td class="org-left">function that returns the empty set</td>
</tr>

<tr>
<td class="org-left">transfer-function</td>
<td class="org-left">union</td>
</tr>

<tr>
<td class="org-left">meet-function</td>
<td class="org-left">union</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">following-uses</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((uses (uses cfgraph)))
    (dataflow-backward
     cfgraph
     (make-dataflow-set)
     (make-dataflow-set)
     #'(<span style="color: #a020f0;">lambda</span> (bb v)
         (union v (gethash bb uses)))
     #'union)))
(add-backward-dataflow-analysis 'following-uses)
</pre>
</div>

<p>
The reaching definitions family of functions make use of gen-definitions and
kill-definitions that are defined below:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-definitions</span> (cfgraph)
  (definitions cfgraph))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">kill-definitions</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((defs (definitions cfgraph)))
    (combine defs defs (compose #'not #'eq)
             #'(<span style="color: #a020f0;">lambda</span> (de1 de2) (eq (decl de1) (decl de2)))
             #'(<span style="color: #a020f0;">lambda</span> (de1 de2) (<span style="color: #a020f0;">declare</span> (ignore de1)) de2))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org88f707f" class="outline-5">
<h5 id="org88f707f"><span class="section-number-5">7.7.4.3</span> Testing reaching definitions</h5>
<div class="outline-text-5" id="text-7-7-4-3">
</div>
<ul class="org-ul">
<li><a id="org29a760c"></a>The package<br />
<div class="outline-text-6" id="text-org29a760c">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-reaching-definitions</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:test-mcl</span>
        <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span>
        <span style="color: #483d8b;">:test-dataflow-library</span> <span style="color: #483d8b;">:build-ast</span> <span style="color: #483d8b;">:reaching-definitions</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-reaching-definitions</span>))
</pre>
</div>
</div>
</li>

<li><a id="org6f65301"></a>The top-level-tests<br />
<div class="outline-text-6" id="text-org6f65301">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite reaching-definitions <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite reaching-definitions)
</pre>
</div>
</div>
</li>



<li><a id="orgff9b113"></a>Testing gen-kill-definitions<br />
<div class="outline-text-6" id="text-orgff9b113">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite gen-kill <span style="color: #483d8b;">:in</span> reaching-definitions)
(in-suite gen-kill)

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*input-1*</span> <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                   module a;</span>
<span style="color: #8b2252;">                   perfect void f(int a) {</span>
<span style="color: #8b2252;">                       int b = 1;</span>
<span style="color: #8b2252;">                       a = 3;</span>
<span style="color: #8b2252;">                       b = 2;</span>
<span style="color: #8b2252;">                   }"</span>)

(test gen-definitions
  (<span style="color: #a020f0;">let*</span> ((a-decl (build-decl <span style="color: #8b2252;">"a"</span>))
         (decl-stat (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil 1))
         (assign-a (build-assign-stat <span style="color: #8b2252;">"a"</span> 3))
         (assign-b (build-assign-stat <span style="color: #8b2252;">"b"</span> 2))
         (cfgraph (get-cfgraph *input-1*))
         (result (map-&gt;compare-set (gen-definitions cfgraph) cfgraph))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set))
                  (build-element a-decl
                                 (build-dataflow-set
                                  (build-definition a-decl a-decl)))
                  (build-element assign-b
                                 (build-dataflow-set
                                  (build-definition (decl decl-stat) assign-b)))
                  (build-element assign-a
                                 (build-dataflow-set
                                  (build-definition a-decl assign-a)))
                  (build-element decl-stat
                                 (build-dataflow-set
                                  (build-definition (decl decl-stat) decl-stat))))))
    (is (set= result wanted))))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*result*</span> nil)
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*wanted*</span> nil)

(test kill-definitions
  (<span style="color: #a020f0;">let*</span> ((a-decl (build-decl <span style="color: #8b2252;">"a"</span>))
         (decl-stat (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil 1))
         (assign-a (build-assign-stat <span style="color: #8b2252;">"a"</span> 3))
         (assign-b (build-assign-stat <span style="color: #8b2252;">"b"</span> 2))
         (cfgraph (get-cfgraph *input-1*))
         (result (map-&gt;compare-set (kill-definitions cfgraph) cfgraph))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set))
                  (build-element a-decl
                                 (build-dataflow-set
                                  (build-definition a-decl assign-a)))
                  (build-element assign-b
                                 (build-dataflow-set
                                  (build-definition (decl decl-stat) decl-stat)))
                  (build-element assign-a
                                 (build-dataflow-set
                                  (build-definition a-decl a-decl)))
                  (build-element decl-stat
                                 (build-dataflow-set
                                  (build-definition (decl decl-stat) assign-b))))))
    (setf *result* result)
    (setf *wanted* wanted)
    (is (set= result wanted))))


</pre>
</div>
</div>
</li>




<li><a id="org1ac228e"></a>Testing reaching-definitions<br />
<div class="outline-text-6" id="text-org1ac228e">
<div class="org-src-container">
<pre class="src src-lisp">
(def-suite simple <span style="color: #483d8b;">:in</span> reaching-definitions)
(in-suite simple)

(test simple
  (<span style="color: #a020f0;">let*</span> ((cfgraph (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                                module a;</span>
<span style="color: #8b2252;">                                perfect void f(int a) {</span>
<span style="color: #8b2252;">                                    int b = 1;</span>
<span style="color: #8b2252;">                                    a = 2;</span>
<span style="color: #8b2252;">                                    b = 3;</span>
<span style="color: #8b2252;">                                }"</span>))
         (a-decl (build-decl <span style="color: #8b2252;">"a"</span>))
         (b-decl-stat (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil 1))
         (a-assign-stat (build-assign-stat <span style="color: #8b2252;">"a"</span> 2))
         (b-assign-stat (build-assign-stat <span style="color: #8b2252;">"b"</span> 3))
         (wanted-in (build-compare-set
                     (build-element (make-bb-entry) (build-dataflow-set))
                     (build-element a-decl (build-dataflow-set))
                     (build-element
                      b-decl-stat
                      (build-dataflow-set
                       (build-definition a-decl a-decl)))
                     (build-element
                      a-assign-stat
                      (build-dataflow-set
                       (build-definition a-decl a-decl)
                       (build-definition (decl b-decl-stat) b-decl-stat)))
                     (build-element
                      b-assign-stat
                      (build-dataflow-set
                       (build-definition a-decl a-assign-stat)
                       (build-definition (decl b-decl-stat) b-decl-stat)))
                     (build-element
                      (make-bb-exit)
                      (build-dataflow-set
                       (build-definition a-decl a-assign-stat)
                       (build-definition (decl b-decl-stat) b-assign-stat)))))
         (wanted-out (build-compare-set
                      (build-element (make-bb-entry) (build-dataflow-set))
                      (build-element
                       a-decl
                       (build-dataflow-set
                        (build-definition a-decl a-decl)))
                      (build-element
                       b-decl-stat
                       (build-dataflow-set
                        (build-definition a-decl a-decl)
                        (build-definition (decl b-decl-stat) b-decl-stat)))
                      (build-element
                       a-assign-stat
                       (build-dataflow-set
                        (build-definition a-decl a-assign-stat)
                        (build-definition (decl b-decl-stat) b-decl-stat)))
                      (build-element
                       b-assign-stat
                       (build-dataflow-set
                        (build-definition a-decl a-assign-stat)
                        (build-definition (decl b-decl-stat) b-assign-stat)))
                      (build-element
                       (make-bb-exit)
                       (build-dataflow-set
                        (build-definition a-decl a-assign-stat)
                        (build-definition (decl b-decl-stat) b-assign-stat))))))
    (<span style="color: #a020f0;">multiple-value-bind</span> (out in) (reaching-definitions cfgraph)
                                        <span style="color: #b22222;">;       (format t "in:~%")</span>
                                        <span style="color: #b22222;">;       (print-dataflow-result in t)</span>
                                        <span style="color: #b22222;">;       (format t "out:~%")</span>
                                        <span style="color: #b22222;">;       (print-dataflow-result out t)</span>
      (is (and
           (set= wanted-in (map-&gt;compare-set in cfgraph))
           (set= wanted-out (map-&gt;compare-set out cfgraph)))))))



<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun test ()</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(multiple-value-bind (in out)</span>
<span style="color: #b22222;">;;       </span><span style="color: #b22222;">(reaching-definitions (get-cfgraph</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">                              (print-test in)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(format t "out:~%")</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(print-test out)))</span>


<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun print-test (dataflow-result)</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(maphash #'(lambda (k v)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">            (format t "~a: ~a~%" k v)) dataflow-result))</span>
</pre>
</div>
</div>
</li>

<li><a id="org222147b"></a>Testing following-definitions<br />
<div class="outline-text-6" id="text-org222147b">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite following-definitions <span style="color: #483d8b;">:in</span> reaching-definitions)
(in-suite following-definitions)

(test following-definitions
  (<span style="color: #a020f0;">let*</span> ((cfgraph (get-cfgraph <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                                module a;</span>
<span style="color: #8b2252;">                                perfect void f(int a) {</span>
<span style="color: #8b2252;">                                    int b = 1;</span>
<span style="color: #8b2252;">                                    a = 2;</span>
<span style="color: #8b2252;">                                    b = 3;</span>
<span style="color: #8b2252;">                                }"</span>))
         (a-decl (build-decl <span style="color: #8b2252;">"a"</span>))
         (b-decl-stat (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil 1))
         (a-assign-stat (build-assign-stat <span style="color: #8b2252;">"a"</span> 2))
         (b-assign-stat (build-assign-stat <span style="color: #8b2252;">"b"</span> 3))
         (dataflow-set (build-dataflow-set
                        (build-definition a-decl a-decl)
                        (build-definition (decl b-decl-stat) b-decl-stat)))
         (dataflow-set2 (build-dataflow-set
                         (build-definition a-decl a-assign-stat)
                         (build-definition (decl b-decl-stat) b-decl-stat)))
         (dataflow-set3 (build-dataflow-set
                         (build-definition a-decl a-assign-stat)
                         (build-definition (decl b-decl-stat) b-assign-stat)))
         (wanted-in (build-compare-set
                     (build-element (make-bb-entry) dataflow-set)
                     (build-element a-decl dataflow-set)
                     (build-element b-decl-stat dataflow-set2)
                     (build-element a-assign-stat dataflow-set3)
                     (build-element
                      b-assign-stat
                      (build-dataflow-set
                       (build-definition (decl b-decl-stat) b-assign-stat)))
                     (build-element (make-bb-exit) (build-dataflow-set))))
         (wanted-out (build-compare-set
                      (build-element (make-bb-entry) dataflow-set)
                      (build-element a-decl dataflow-set2)
                      (build-element b-decl-stat dataflow-set3)
                      (build-element
                       a-assign-stat
                       (build-dataflow-set
                        (build-definition (decl b-decl-stat) b-assign-stat)))
                      (build-element b-assign-stat (build-dataflow-set))
                      (build-element (make-bb-exit) (build-dataflow-set)))))
    (<span style="color: #a020f0;">multiple-value-bind</span> (in out) (following-definitions cfgraph)
      (is (and
           (set= wanted-in (map-&gt;compare-set in cfgraph))
           (set= wanted-out (map-&gt;compare-set out cfgraph)))))))

</pre>
</div>
</div>
</li>


<li><a id="org6e8c21d"></a>Testing reaching uses<br />
<div class="outline-text-6" id="text-org6e8c21d">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite reaching-uses <span style="color: #483d8b;">:in</span> reaching-definitions)
(in-suite reaching-uses)

(test reaching-uses
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (cfgraph (get-cfgraph input))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) (build-dataflow-set))
                  (build-element decl-stat-a (build-dataflow-set))
                  (build-element decl-stat-b (build-dataflow-set))
                  (build-element decl-stat-c
                                 (build-dataflow-set
                                  (build-use (decl decl-stat-a) decl-stat-b)))
                  (build-element (make-bb-exit) (build-dataflow-set
                                                 (build-use (decl decl-stat-a) decl-stat-b)
                                                 (build-use (decl decl-stat-b) decl-stat-c))))))
    (<span style="color: #a020f0;">let</span> ((result (in-set (reaching-uses cfgraph))))
      (is (set= (map-&gt;compare-set result cfgraph) wanted)))))
</pre>
</div>
</div>
</li>

<li><a id="org6fd05fe"></a>Testing following uses<br />
<div class="outline-text-6" id="text-org6fd05fe">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite following-uses <span style="color: #483d8b;">:in</span> reaching-definitions)
(in-suite following-uses)

(test following-uses
  (<span style="color: #a020f0;">let*</span> ((input <span style="color: #8b2252;">"package m;</span>
<span style="color: #8b2252;">                  module a;</span>
<span style="color: #8b2252;">                  perfect void f() {</span>
<span style="color: #8b2252;">                      int a = 2;</span>
<span style="color: #8b2252;">                      int b = a;</span>
<span style="color: #8b2252;">                      int c = b;</span>
<span style="color: #8b2252;">                  }"</span>)
         (decl-stat-a (build-decl-stat <span style="color: #8b2252;">"a"</span> nil nil 2))
         (decl-stat-b (build-decl-stat <span style="color: #8b2252;">"b"</span> nil nil <span style="color: #8b2252;">"a"</span>))
         (decl-stat-c (build-decl-stat <span style="color: #8b2252;">"c"</span> nil nil <span style="color: #8b2252;">"b"</span>))
         (cfgraph (get-cfgraph input))
         (dataflow-set (build-dataflow-set
                        (build-use (decl decl-stat-a) decl-stat-b)
                        (build-use (decl decl-stat-b) decl-stat-c)))
         (wanted (build-compare-set
                  (build-element (make-bb-entry) dataflow-set)
                  (build-element decl-stat-a dataflow-set)
                  (build-element decl-stat-b (build-dataflow-set
                                              (build-use (decl decl-stat-b) decl-stat-c)))
                  (build-element decl-stat-c (build-dataflow-set))
                  (build-element (make-bb-exit) (build-dataflow-set)))))
    (<span style="color: #a020f0;">let</span> ((result (out-set (following-uses cfgraph))))
      (is (set= (map-&gt;compare-set result cfgraph) wanted)))))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2eb1fbd" class="outline-3">
<h3 id="org2eb1fbd"><span class="section-number-3">7.8</span> Printing</h3>
<div class="outline-text-3" id="text-7-8">
<p>
This section discusses several micro-passes that perform some form of printing output.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org8ecb405">7.8.1. print-pretty</a></li>
<li><a href="#org4cff8d4">7.8.2. print-dataflow</a></li>
<li><a href="#orgdc9b6f3">7.8.3. print basic blocks</a></li>
<li><a href="#orgca0b6ff">7.8.4. print</a></li>
<li><a href="#orgfe9b6b3">7.8.5. Print the AST in JSON format</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8ecb405" class="outline-4">
<h4 id="org8ecb405"><span class="section-number-4">7.8.1</span> print-pretty</h4>
<div class="outline-text-4" id="text-7-8-1">
<p>
Pretty printing of the MCPL AST.
</p>
</div>

<div id="outline-container-org9a8c6e4" class="outline-5">
<h5 id="org9a8c6e4"><span class="section-number-5">7.8.1.1</span> The package</h5>
<div class="outline-text-5" id="text-7-8-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:print-pretty</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:code-emitter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:pp</span> <span style="color: #483d8b;">:pp-base-type</span> <span style="color: #483d8b;">:pp-array-part</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9202884" class="outline-5">
<h5 id="org9202884"><span class="section-number-5">7.8.1.2</span> Pretty printing functions</h5>
<div class="outline-text-5" id="text-7-8-1-2">
<p>
There is only one method that is exported: <code>pp</code>, a generic method that matches
all the different AST forms.  If an AST form is not supported, an error is
thrown. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">pp</span> (ast <span style="color: #228b22;">&amp;optional</span> pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ast ast) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not yet implemented: ~s"</span> ast))
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org9796800"></a>top-level<br />
<div class="outline-text-6" id="text-org9796800">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:print-pretty</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((m module) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (pkg id exports imports code) m
    (emit <span style="color: #8b2252;">"package ~a;"</span> (funcall pp pkg pp)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"module ~a;"</span> (funcall pp id pp)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a"</span> (pp-exports exports pp)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a"</span> (funcall pp imports pp)
          <span style="color: #8b2252;">""</span>
          <span style="color: #8b2252;">"~a"</span> (funcall pp code pp))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pp-exports</span> (exports pp)
  (<span style="color: #a020f0;">if</span> exports
      (emit <span style="color: #8b2252;">"export ~a;"</span> (funcall pp exports))
      <span style="color: #8b2252;">""</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((i lib-import) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"import ~a;"</span> (funcall pp (id i) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((code code) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a"</span> (funcall pp (top-decls code) pp)
        <span style="color: #8b2252;">""</span>
        <span style="color: #8b2252;">"~a"</span> (funcall pp (funcs code) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((f func) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (hw-desc mcl-type id params code-block) f
    (emit <span style="color: #8b2252;">"~a ~a ~a(~a) ~a"</span>
          (funcall pp hw-desc pp) (funcall pp mcl-type pp) (funcall pp id pp)
          (funcall pp params pp) (funcall pp code-block pp))))
</pre>
</div>
</div>
</li>

<li><a id="orgd89ae10"></a>declarations<br />
<div class="outline-text-6" id="text-orgd89ae10">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:print-pretty</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((d normal-decl) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a~a"</span> (funcall pp (modifiers d) pp) (funcall pp (basic-decls d) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ad assign-decl) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (modifiers basic-decl expr) ad
    (emit <span style="color: #8b2252;">"~a~a = ~a"</span> (funcall pp modifiers pp)
          (funcall pp basic-decl pp) (funcall pp expr pp))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((m const) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">"const"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((m user-defined) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (funcall pp (modifier m) pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((bd basic-decl) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a ~a"</span> (funcall pp (mcl-type bd) pp) (funcall pp (id bd) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((cd const-decl) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a;"</span> (funcall pp (decl cd) pp)))
</pre>
</div>
</div>
</li>

<li><a id="org817d5cb"></a>types<br />
<div class="outline-text-6" id="text-org817d5cb">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((td typedef) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (id params fields) td
    (<span style="color: #a020f0;">if</span> params
        (emit <span style="color: #8b2252;">"type ~a(~a) {"</span> (funcall pp id pp) (funcall pp params pp)
              <span style="color: #8b2252;">"    ~a"</span> (pp-fields fields pp)
              <span style="color: #8b2252;">"}"</span>)
        (emit <span style="color: #8b2252;">"type ~a {"</span> (funcall pp id pp)
              <span style="color: #8b2252;">"    ~a"</span> (pp-fields fields pp)
              <span style="color: #8b2252;">"}"</span>))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((v void) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">"void"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((i int) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">"int"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((f flt) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">"float"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((d double) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">"double"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((b mcl-byte) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">"byte"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((b bool) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">"bool"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ct custom-type) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (id params) ct
    (<span style="color: #a020f0;">if</span> params
        (emit <span style="color: #8b2252;">"~a(~a)"</span> (funcall pp id pp) (funcall pp params pp))
        (funcall pp id pp))))
</pre>
</div>

<p>
The following methods deal with array types.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">pp-base-type</span> (ast <span style="color: #228b22;">&amp;optional</span> pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp-base-type</span> ((ast ast) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not a type ~a"</span> ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp-base-type</span> ((type mcl-type) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (funcall pp type pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp-base-type</span> ((at array-type) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (pp-base-type (base-type at) pp))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">pp-array-part</span> (ast <span style="color: #228b22;">&amp;optional</span> pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp-array-part</span> ((ast ast) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not a type ~a"</span> ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp-array-part</span> ((type mcl-type) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  <span style="color: #8b2252;">""</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp-array-part</span> ((at array-type) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (base-type sizes) at
    (emit <span style="color: #8b2252;">"[~a]~a"</span> (funcall pp sizes pp) (pp-array-part base-type pp))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((at array-type) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a~a"</span> (pp-base-type (base-type at) pp) (pp-array-part at pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((as array-size) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (funcall pp (size as) pp))
</pre>
</div>
</div>
</li>

<li><a id="org1820a70"></a>statements<br />
<div class="outline-text-6" id="text-org1820a70">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ds decl-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a;"</span> (funcall pp (decl ds) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((cs call-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a;"</span> (funcall pp (call cs) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((as assign-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a = ~a;"</span> (funcall pp (var as) pp) (funcall pp (expr as) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((c call) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a(~a)"</span> (funcall pp (id c) pp) (pp-params (params c) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((is if-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (cond-expr stat elsestat) is
    (<span style="color: #a020f0;">if</span> elsestat
        (emit <span style="color: #8b2252;">"if (~a) ~a"</span> (funcall pp cond-expr pp) (funcall pp stat pp)
              <span style="color: #8b2252;">"else ~a"</span> (funcall pp elsestat pp))
        (emit <span style="color: #8b2252;">"if (~a) ~a"</span> (funcall pp cond-expr pp) (funcall pp stat pp)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((bs block-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (funcall pp (code-block bs) pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((cb code-block) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"{"</span>
        <span style="color: #8b2252;">"    ~a"</span> (funcall pp (stats cb) pp)
        <span style="color: #8b2252;">"}"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((fe foreach-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (decl nr-iters par-group stat) fe
    (emit <span style="color: #8b2252;">"foreach (~a in ~a ~a) ~a"</span>
          (funcall pp decl pp) (funcall pp nr-iters pp)
          (funcall pp par-group pp) (funcall pp stat pp))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((f for-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (decl cond-expr inc stat) f
    (emit <span style="color: #8b2252;">"for (~a; ~a; ~a) ~a"</span>
          (funcall pp decl pp) (funcall pp cond-expr pp)
          (funcall pp inc pp) (funcall pp stat pp))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((is inc-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a;"</span> (funcall pp (inc is) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((i inc) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (var option) i
    (emit <span style="color: #8b2252;">"~a~a"</span> (funcall pp var pp) (<span style="color: #a020f0;">if</span> option <span style="color: #8b2252;">"++"</span> <span style="color: #8b2252;">"--"</span>))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((i inc-step) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (var option expr) i
    (emit <span style="color: #8b2252;">"~a ~a ~a"</span> (funcall pp var pp) option (funcall pp expr pp))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((as as-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (var basic-decls) as
    (emit <span style="color: #8b2252;">"~a as ~a;"</span> (funcall pp var pp) (funcall pp basic-decls pp))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ss swap-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (var-left var-right) ss
    (emit <span style="color: #8b2252;">"~a &lt;=&gt; ~a;"</span> (funcall pp var-left pp) (funcall pp var-right pp))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((bs barrier-stat) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"barrier(~a);"</span> (funcall pp (mem-space bs))))
</pre>
</div>
</div>
</li>

<li><a id="org17d9519"></a>vars<br />
<div class="outline-text-6" id="text-org17d9519">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:print-pretty</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((nv normal-var) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (funcall pp (basic-var nv) pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((dv dot-var) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (emit <span style="color: #8b2252;">"~a.~a"</span> (funcall pp (basic-var dv) pp) (funcall pp (var dv) pp)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((bv basic-var) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (id array-exprs) bv
    (emit <span style="color: #8b2252;">"~a~a"</span> (funcall pp id pp)
          (<span style="color: #a020f0;">if</span> array-exprs
              (emit <span style="color: #8b2252;">"[~a]"</span> (funcall pp array-exprs pp))
              <span style="color: #8b2252;">""</span>))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((id id) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  (name id))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ci compound-id) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">with-slots</span> (name compound) ci
    (emit <span style="color: #8b2252;">"~a.~a"</span> name (funcall pp compound pp))))
</pre>
</div>
</div>
</li>

<li><a id="org651c8e9"></a>expressions<br />
<div class="outline-text-6" id="text-org651c8e9">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:print-pretty</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ic int-constant) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  (format nil <span style="color: #8b2252;">"~a"</span> (int-value ic)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((fc float-constant) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  (format nil <span style="color: #8b2252;">"~a"</span> (float-value fc)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((bc bool-constant) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">declare</span> (ignore pp))
  (<span style="color: #a020f0;">if</span> (bool-value bc) <span style="color: #8b2252;">"true"</span> <span style="color: #8b2252;">"false"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((m minus) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (unary-pp <span style="color: #8b2252;">"-"</span> m pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((n neg) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (unary-pp <span style="color: #8b2252;">"!"</span> n pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((lt lt) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"&lt;"</span> lt pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((gt gt) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"&gt;"</span> gt pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((le le) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"&lt;="</span> le pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ge ge) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"&gt;="</span> ge pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ve var-expr) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (funcall pp (var ve) pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((add add) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"+"</span> add pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((sub sub) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"-"</span> sub pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((mul mul) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"*"</span> mul pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((div div) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"/"</span> div pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((m modulo) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"%"</span> m pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((equ equ) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"=="</span> equ pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((la log-and) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"&amp;&amp;"</span> la pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ba bitand) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"&amp;"</span> ba pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((bsl bitshl) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"&lt;&lt;"</span> bsl pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((ce call-expr) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (funcall pp (call ce) pp))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((p pow) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (binary-pp <span style="color: #8b2252;">"^"</span> p pp))
</pre>
</div>
</div>
</li>



<li><a id="org54f4148"></a>generic methods<br />
<div class="outline-text-6" id="text-org54f4148">
<p>
The following code deals with lists of various AST forms:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:print-pretty</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pp</span> ((l list) <span style="color: #228b22;">&amp;optional</span> (pp #'pp))
  (<span style="color: #a020f0;">if</span> (null l)
      <span style="color: #8b2252;">""</span>
      (<span style="color: #a020f0;">typecase</span> (car l)
        ((or func typedef)
         (emit-list l <span style="color: #483d8b;">:nr-lines</span> 2 <span style="color: #483d8b;">:function</span> pp))
        (const-decl
         (emit-list l <span style="color: #483d8b;">:nr-lines</span> 1 <span style="color: #483d8b;">:function</span> pp))
        (decl
         (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span> <span style="color: #483d8b;">:function</span> pp))
        (basic-decl
         (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">" as "</span> <span style="color: #483d8b;">:function</span> pp))
        ((or array-size var-expr)
         (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span> <span style="color: #483d8b;">:function</span> pp))
        ((or lib-import stat)
         (emit-list l <span style="color: #483d8b;">:function</span> pp))
        (decl-modifier
         (emit <span style="color: #8b2252;">"~a "</span> (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">" "</span> <span style="color: #483d8b;">:function</span> pp)))
        (expr
         (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">"]["</span> <span style="color: #483d8b;">:function</span> pp))
        (cons
         (pp2 l pp))
        (id
         (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span> <span style="color: #483d8b;">:function</span> pp))
        (t (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not yet implemented for list: ~s"</span> (car l))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pp-params</span> (l pp)
  (<span style="color: #a020f0;">if</span> (null l)
      <span style="color: #8b2252;">""</span>
      (<span style="color: #a020f0;">typecase</span> (car l)
        (expr
         (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">", "</span>
                    <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (funcall pp x pp))))
        (t (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not for params: ~s"</span> (car l))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pp-fields</span> (l pp)
  (<span style="color: #a020f0;">if</span> (null l)
      <span style="color: #8b2252;">""</span>
      (<span style="color: #a020f0;">typecase</span> (car l)
        (normal-decl
         (emit-list l <span style="color: #483d8b;">:nr-lines</span> 1 <span style="color: #483d8b;">:function</span> #'(<span style="color: #a020f0;">lambda</span> (x) (pp-field x pp))))
        (t (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not for params: ~s"</span> (car l))))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pp-field</span> (decl pp)
  (emit <span style="color: #8b2252;">"~a;"</span> (pp decl pp)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pp2</span> (l pp)
  (<span style="color: #a020f0;">typecase</span> (caar l)
    (expr
     (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">"]["</span> <span style="color: #483d8b;">:function</span> pp))
    (t (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"not yet implemented for pp2: ~s"</span> (caar l)))))
</pre>
</div>

<p>
A generic method for binary operators:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">binary-pp</span> (operator ast pp)
  (<span style="color: #a020f0;">let</span> ((l (l ast))
        (r (r ast)))
    (emit <span style="color: #8b2252;">"~a ~a ~a"</span> (brack ast l t pp) operator (brack ast r nil pp))))
</pre>
</div>

<p>
A generic method for unary operators:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">unary-pp</span> (operator ast pp)
  (<span style="color: #a020f0;">let</span> ((e (e ast)))
    (emit <span style="color: #8b2252;">"~a~a"</span> operator (brack ast e nil pp))))
</pre>
</div>

<p>
The <code>brack</code> function emits parentheses if neccessary:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">brack</span> (parent child child-at-left-p pp)
  (<span style="color: #a020f0;">if</span> (needs-bracketing-p parent child child-at-left-p)
      (emit <span style="color: #8b2252;">"(~a)"</span> (funcall pp child pp))
      (emit <span style="color: #8b2252;">"~a"</span> (funcall pp child pp))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">needs-bracketing-p</span> (parent child child-at-left-p)
  (<span style="color: #a020f0;">if</span> (not (binary-p child))
      nil
      (<span style="color: #a020f0;">let</span> ((priority-parent (priority parent))
            (priority-child (priority child)))
        (<span style="color: #a020f0;">cond</span> ((&lt; priority-parent priority-child) 
               nil)
              ((&gt; priority-parent priority-child)
               t)
              (t
               (<span style="color: #a020f0;">cond</span> ((left-associative-p parent)
                      (not child-at-left-p))
                     ((right-associative-p parent)
                      child-at-left-p)
                     (t
                      nil)))))))
</pre>
</div>
</div>
</li>
</ul>
</div>


<div id="outline-container-org0a781b1" class="outline-5">
<h5 id="org0a781b1"><span class="section-number-5">7.8.1.3</span> Testing pretty printing</h5>
<div class="outline-text-5" id="text-7-8-1-3">
</div>
<ul class="org-ul">
<li><a id="orgc0ba099"></a>The package<br />
<div class="outline-text-6" id="text-orgc0ba099">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-print-pretty</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:print-pretty</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:id</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-print-pretty</span>))
</pre>
</div>
</div>
</li>

<li><a id="org8e2ea6c"></a>Testing a module<br />
<div class="outline-text-6" id="text-org8e2ea6c">
<p>
The following function tests several lines of an MCPL module:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-suite print-pretty <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite print-pretty)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pp-equal</span> (<span style="color: #228b22;">&amp;rest</span> lines)
  (<span style="color: #a020f0;">let</span> ((s (format nil <span style="color: #8b2252;">"~{~a~^~%~}"</span> lines)))
    (equal s (pp (parse-mcpl s)))))
</pre>
</div>

<p>
Testing a simple module:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(test module
  (is
    (pp-equal <span style="color: #8b2252;">"package m;"</span>
             <span style="color: #8b2252;">""</span>
             <span style="color: #8b2252;">"module a;"</span>
             <span style="color: #8b2252;">""</span>
             <span style="color: #8b2252;">""</span>
             <span style="color: #8b2252;">""</span>
             <span style="color: #8b2252;">"import perfect;"</span>
             <span style="color: #8b2252;">""</span>
             <span style="color: #8b2252;">""</span>
             <span style="color: #8b2252;">""</span>
             <span style="color: #8b2252;">"perfect void f(int a, int b) {"</span>
             <span style="color: #8b2252;">"    foreach (int i in 2 threads) {"</span>
             <span style="color: #8b2252;">"        int[2, 3] a;"</span>
             <span style="color: #8b2252;">"    }"</span>
             <span style="color: #8b2252;">"}"</span>
             <span style="color: #8b2252;">""</span>)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">expression-equal</span> (s <span style="color: #228b22;">&amp;optional</span> result)
  (equal (<span style="color: #a020f0;">if</span> result result s) (pp (parse-mcpl-expr s))))

(test priorities
  (is (expression-equal <span style="color: #8b2252;">"2 + 3 * 4"</span>))
  (is (expression-equal <span style="color: #8b2252;">"(2 + 3) * 4"</span>))
  (is (expression-equal <span style="color: #8b2252;">"((1 - 2) &lt;&lt; 3) + 4"</span> <span style="color: #8b2252;">"(1 - 2 &lt;&lt; 3) + 4"</span>)))
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org4cff8d4" class="outline-4">
<h4 id="org4cff8d4"><span class="section-number-4">7.8.2</span> print-dataflow</h4>
<div class="outline-text-4" id="text-7-8-2">
</div>
<div id="outline-container-orgf112f2f" class="outline-5">
<h5 id="orgf112f2f"><span class="section-number-5">7.8.2.1</span> The package</h5>
<div class="outline-text-5" id="text-7-8-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:print-dataflow</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:print-pretty</span>
        <span style="color: #483d8b;">:print-bb</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:set-difference</span> <span style="color: #483d8b;">:intersection</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:print-dataflow-result</span> <span style="color: #483d8b;">:print-dataflow-element</span> <span style="color: #483d8b;">:print-dataflow-set</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org47cad34" class="outline-5">
<h5 id="org47cad34"><span class="section-number-5">7.8.2.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-8-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-dataflow-element</span> (dataflow-element))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-dataflow-set</span> (dataflow-set)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"print a set of dataflow elements"</span>))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-dataflow-result</span> (hash-table stream)
  (<span style="color: #483d8b;">:documentation</span> <span style="color: #8b2252;">"print a hash-table with as keys basic blocks and values</span>
<span style="color: #8b2252;">  dataflow-sets onto stream"</span>))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dataflow-element</span> ((d dataflow-variable-with-bb))
  (format nil <span style="color: #8b2252;">"&lt;~a, ~a&gt;"</span> (pp (decl d)) (print-bb (bb d))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dataflow-set</span> ((set simple-set))
  (format nil <span style="color: #8b2252;">"{~{~a~^, ~}}"</span> (mapcar #'print-dataflow-element (elements set))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dataflow-element</span> ((d dataflow-variable))
  (format nil <span style="color: #8b2252;">"&lt;~a&gt;"</span> (pp (decl d))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dataflow-result</span> (hash-table stream)
  (maphash #'(<span style="color: #a020f0;">lambda</span> (k v)
               (format stream <span style="color: #8b2252;">"~a: ~a~%"</span> (print-bb k) (print-dataflow-set v)))
           hash-table))
</pre>
</div>
</div>
</div>
</div>





<div id="outline-container-orgdc9b6f3" class="outline-4">
<h4 id="orgdc9b6f3"><span class="section-number-4">7.8.3</span> print basic blocks</h4>
<div class="outline-text-4" id="text-7-8-3">
</div>
<div id="outline-container-orgd5dc394" class="outline-5">
<h5 id="orgd5dc394"><span class="section-number-5">7.8.3.1</span> The package</h5>
<div class="outline-text-5" id="text-7-8-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:print-bb</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:print-pretty</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:print-bb</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org91dd1da" class="outline-5">
<h5 id="org91dd1da"><span class="section-number-5">7.8.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-8-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-bb</span> (bb))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-bb</span> ((bb bb-entry))
  (<span style="color: #a020f0;">declare</span> (ignore bb))
  <span style="color: #8b2252;">"entry"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-bb</span> ((bb bb-exit))
  (<span style="color: #a020f0;">declare</span> (ignore bb))
  <span style="color: #8b2252;">"exit"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-bb</span> ((bb bb-decl-generic))
  (pp (decl bb)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-bb</span> ((bb bb-stat-generic))
  (pp (stat bb)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-bb</span> ((bb bb-expr-generic))
  (pp (expr bb)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-bb</span> ((bb bb-inc-generic))
  (pp (inc bb)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-bb</span> ((bb bb-foreach))
  (format nil <span style="color: #8b2252;">"foreach ~a"</span> (pp (decl (stat bb)))))
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-orgca0b6ff" class="outline-4">
<h4 id="orgca0b6ff"><span class="section-number-4">7.8.4</span> print</h4>
<div class="outline-text-4" id="text-7-8-4">
</div>
<div id="outline-container-org95bad9a" class="outline-5">
<h5 id="org95bad9a"><span class="section-number-5">7.8.4.1</span> The package</h5>
<div class="outline-text-5" id="text-7-8-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:print</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:print-ast</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a76d03" class="outline-5">
<h5 id="org3a76d03"><span class="section-number-5">7.8.4.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-8-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">let</span> ((indentation 0)
      (s (make-string-output-stream)))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dec</span> ()
    (decf indentation))

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-print</span> (f v)
    (incf indentation)
    (format s (concatenate 'string <span style="color: #8b2252;">"~vt"</span> f <span style="color: #8b2252;">"~%"</span>) indentation v))

  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-forward</span> (ast))
  (<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-backward</span> (ast))

  (defvisitor print-backward ast (ast string list number symbol)
     (dec))


  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-forward</span> ((ast ast))
    (do-print <span style="color: #8b2252;">"~a"</span> (class-name (class-of ast)))
    t)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-forward</span> ((str string))
    (do-print <span style="color: #8b2252;">"~s"</span> str)
    t)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-forward</span> ((l list))
    (incf indentation)
    t)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-forward</span> ((n number))
    (do-print <span style="color: #8b2252;">"~a"</span> n)
    t)

  (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-forward</span> ((s symbol))
    (do-print <span style="color: #8b2252;">"~a"</span> s)
    t)

  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-ast</span> (ast)
    (setf indentation 0)
    (visit ast #'print-forward #'print-backward)
    (get-output-stream-string s))) 
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-orgfe9b6b3" class="outline-4">
<h4 id="orgfe9b6b3"><span class="section-number-4">7.8.5</span> Print the AST in JSON format</h4>
<div class="outline-text-4" id="text-7-8-5">
</div>
<div id="outline-container-org40377b7" class="outline-5">
<h5 id="org40377b7"><span class="section-number-5">7.8.5.1</span> The package</h5>
<div class="outline-text-5" id="text-7-8-5-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:print-ast-json</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:code-emitter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:print-ast-json</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b4a8d8" class="outline-5">
<h5 id="org4b4a8d8"><span class="section-number-5">7.8.5.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-8-5-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">slot-values</span> (object)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (slot-name)
              (slot-value object slot-name))
          (slot-names-children object)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">slot-name-&gt;string</span> (slot-name)
  (kebab:to-camel-case (format nil <span style="color: #8b2252;">"~a"</span> slot-name)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">slot-names</span> (object)
  (mapcar #'slot-name-&gt;string (slot-names-children object)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-slots</span> (ast class-name)
  (emit-list (mapcar #'(<span style="color: #a020f0;">lambda</span> (slot-name slot-value)
                         (emit <span style="color: #8b2252;">"\"~a\": ~a"</span> slot-name (print-ast slot-value)))
                     (cons <span style="color: #8b2252;">"class"</span> (slot-names ast))
                     (cons class-name (slot-values ast)))
             <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">","</span>
             <span style="color: #483d8b;">:nr-lines</span> 1
             ))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-ast</span> (ast))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-ast</span> ((s string))
  (format nil <span style="color: #8b2252;">"~s"</span> s))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-ast</span> ((n number))
  (format nil <span style="color: #8b2252;">"~a"</span> n))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-ast</span> ((s (eql t)))
  <span style="color: #8b2252;">"true"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-ast</span> ((s (eql nil)))
  <span style="color: #8b2252;">"false"</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-ast</span> ((l list))
  (<span style="color: #a020f0;">if</span> l
      (emit <span style="color: #8b2252;">"["</span>
            <span style="color: #8b2252;">"  ~a"</span> (emit-list l <span style="color: #483d8b;">:separator</span> <span style="color: #8b2252;">","</span> <span style="color: #483d8b;">:nr-lines</span> 1 <span style="color: #483d8b;">:function</span> #'print-ast)
            <span style="color: #8b2252;">"]"</span>)
      (emit <span style="color: #8b2252;">"[]"</span>)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-ast</span> ((ast ast))
  (emit <span style="color: #8b2252;">"{"</span>
        <span style="color: #8b2252;">"  ~a"</span> (print-slots ast (kebab:to-camel-case (symbol-name (sb-mop:class-name (class-of ast)))))
        <span style="color: #8b2252;">"}"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-ast-json</span> (ast)
  (print-ast ast))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org03c4550" class="outline-3">
<h3 id="org03c4550"><span class="section-number-3">7.9</span> Visualization</h3>
<div class="outline-text-3" id="text-7-9">
<p>
This section shows micro-passes that visualize the AST, for example visualizing
control flow or call graphs.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#org974d284">7.9.1. Visualize graphs</a></li>
<li><a href="#org7ff3979">7.9.2. Visualize controlflow graphs</a></li>
<li><a href="#org70fbb1e">7.9.3. Visualize callgraph</a></li>
<li><a href="#orga2202f2">7.9.4. Visualize dataflow graphs</a></li>
</ul>
</div>
</div>

<div id="outline-container-org974d284" class="outline-4">
<h4 id="org974d284"><span class="section-number-4">7.9.1</span> Visualize graphs</h4>
<div class="outline-text-4" id="text-7-9-1">
</div>
<div id="outline-container-org65f6966" class="outline-5">
<h5 id="org65f6966"><span class="section-number-5">7.9.1.1</span> The package</h5>
<div class="outline-text-5" id="text-7-9-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:visualize-graph</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:visualize-graph</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org8c0140e" class="outline-5">
<h5 id="org8c0140e"><span class="section-number-5">7.9.1.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-9-1-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visualize-graph</span> (graph vertex-label-func vertex-func filename-output)
  (graph-&gt;dot graph filename-output
              <span style="color: #483d8b;">:edge-labeler</span> nil
              <span style="color: #483d8b;">:vertex-formatter</span> vertex-func
              <span style="color: #483d8b;">:vertex-labeler</span> vertex-label-func))
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org7ff3979" class="outline-4">
<h4 id="org7ff3979"><span class="section-number-4">7.9.2</span> Visualize controlflow graphs</h4>
<div class="outline-text-4" id="text-7-9-2">
</div>
<div id="outline-container-orge877b6d" class="outline-5">
<h5 id="orge877b6d"><span class="section-number-5">7.9.2.1</span> The package</h5>
<div class="outline-text-5" id="text-7-9-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:visualize-cfgraph</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:visualize-graph</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:print-bb</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:visualize-cfgraph</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org3415c78" class="outline-5">
<h5 id="org3415c78"><span class="section-number-5">7.9.2.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-9-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">format-cf-label</span> (vertex stream)
  (format stream <span style="color: #8b2252;">"~a"</span> (print-bb (element vertex))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">format-vertex</span> (vertex stream)
  (<span style="color: #a020f0;">declare</span> (ignore vertex))
  (format stream <span style="color: #8b2252;">""</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visualize-cfgraph</span> (cfgraph filename-output)
  (visualize-graph cfgraph #'format-cf-label #'format-vertex filename-output)) 
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org70fbb1e" class="outline-4">
<h4 id="org70fbb1e"><span class="section-number-4">7.9.3</span> Visualize callgraph</h4>
<div class="outline-text-4" id="text-7-9-3">
</div>
<div id="outline-container-org7d48bb4" class="outline-5">
<h5 id="org7d48bb4"><span class="section-number-5">7.9.3.1</span> The package</h5>
<div class="outline-text-5" id="text-7-9-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:visualize-callgraph</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:visualize-graph</span> <span style="color: #483d8b;">:controlflow</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:visualize-callgraph</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org8c8cded" class="outline-5">
<h5 id="org8c8cded"><span class="section-number-5">7.9.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-9-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">format-callgraph-label</span> (vertex stream)
  (format stream <span style="color: #8b2252;">"~a"</span> (name (id (element vertex)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">format-vertex</span> (vertex stream)
  (<span style="color: #a020f0;">declare</span> (ignore vertex))
  (format stream <span style="color: #8b2252;">""</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visualize-callgraph</span> (callgraph filename-output)
  (visualize-graph
   callgraph #'format-callgraph-label #'format-vertex filename-output)) 
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-orga2202f2" class="outline-4">
<h4 id="orga2202f2"><span class="section-number-4">7.9.4</span> Visualize dataflow graphs</h4>
<div class="outline-text-4" id="text-7-9-4">
</div>
<div id="outline-container-orgc51c792" class="outline-5">
<h5 id="orgc51c792"><span class="section-number-5">7.9.4.1</span> The package</h5>
<div class="outline-text-5" id="text-7-9-4-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:visualize-dataflow-graph</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:visualize-graph</span> <span style="color: #483d8b;">:controlflow</span>
        <span style="color: #483d8b;">:print-bb</span> <span style="color: #483d8b;">:print-dataflow</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:escape</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:visualize-dataflow-graph</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org6437de0" class="outline-5">
<h5 id="org6437de0"><span class="section-number-5">7.9.4.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-9-4-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">format-dataflow-label</span> (vertex stream dataflow-info-in dataflow-info-out)
  (<span style="color: #a020f0;">let</span> ((bb (element vertex)))
    (<span style="color: #a020f0;">if</span> dataflow-info-in
        (format stream <span style="color: #8b2252;">"{ ~a | "</span> (get-dataflow-set bb dataflow-info-in))
        (format stream <span style="color: #8b2252;">"{ "</span>))
    (format stream <span style="color: #8b2252;">"~a"</span> (do-escape (print-bb bb)))
    (<span style="color: #a020f0;">if</span> dataflow-info-out
        (format stream <span style="color: #8b2252;">" | ~a }"</span> (get-dataflow-set bb dataflow-info-out))
        (format stream <span style="color: #8b2252;">" }"</span>))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-dataflow-set</span> (bb dataflow-info)
  (do-escape (print-dataflow-set (gethash bb dataflow-info))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">do-escape</span> (s)
  (escape s <span style="color: #8b2252;">"{"</span> <span style="color: #8b2252;">"}"</span> <span style="color: #8b2252;">"&lt;"</span> <span style="color: #8b2252;">"&gt;"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">visualize-dataflow-graph</span> (cfgraph if-forward-in if-forward-out
                                 filename-output)
  (visualize-graph cfgraph
                   #'(<span style="color: #a020f0;">lambda</span> (vertex stream)
                       (format-dataflow-label
                        vertex stream if-forward-in if-forward-out))
                   #'(<span style="color: #a020f0;">lambda</span> (vertex stream)
                       (<span style="color: #a020f0;">declare</span> (ignore vertex))
                      (format stream <span style="color: #8b2252;">"shape=record"</span>))
                   filename-output))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org652f86e" class="outline-3">
<h3 id="org652f86e"><span class="section-number-3">7.10</span> Transfers</h3>
<div class="outline-text-3" id="text-7-10">
<p>
This section discusses several micro-passes that help generate transfers to and
from the device.
</p>

<div id="text-table-of-contents">
<ul>
<li><a href="#orgebced99">7.10.1. Generate transfers</a></li>
<li><a href="#org07a72d4">7.10.2. Generate allocations</a></li>
<li><a href="#org373222e">7.10.3. Remove unnecessary transfers</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgebced99" class="outline-4">
<h4 id="orgebced99"><span class="section-number-4">7.10.1</span> Generate transfers</h4>
<div class="outline-text-4" id="text-7-10-1">
</div>
<div id="outline-container-orgc10d205" class="outline-5">
<h5 id="orgc10d205"><span class="section-number-5">7.10.1.1</span> The package</h5>
<div class="outline-text-5" id="text-7-10-1-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:generate-transfers</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:logging</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:dataflow</span>
        <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:on-device-variables</span> <span style="color: #483d8b;">:dataflow-on-device-variables</span>
        <span style="color: #483d8b;">:dependencies</span>
        <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:set-entry-exit-on-device-variables</span> <span style="color: #483d8b;">:set-vars-written</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:intersection</span> <span style="color: #483d8b;">:set-difference</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:with-gensyms</span> <span style="color: #483d8b;">:copy-hash-table</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:generate-transfers</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org7bdf6c1" class="outline-5">
<h5 id="org7bdf6c1"><span class="section-number-5">7.10.1.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-10-1-2">
<p>
Generating transfers relies heavily on dataflow-analysis based on
<code>on-device-variables</code> and <code>on-host-variables</code> that separate between
whether variables are used or defined on the host or device.  Using all kinds
of forward and backward, must or may analyses where for example host variables
kill device variables, we try to determine the optimal placement of transfers,
that are in the end represented by <code>on-device-variables</code>.  
</p>

<p>
Optimal placement is considered as a placement as close as possible to a
foreach statement - otherwise we would use more memory than necessary - unless
we can save transfers.
</p>

<p>
This analysis uses two main passes, one forward and one backward.  The forward
pass places the transfers from device, whereas the backward pass places the
transfers to the device.  Because the analysis is almost symmetric for the
forward and backward dataflow problems, we only write the code for the forward
dataflow problem and parameterize it where possible.  The analysis maintains a
global variable <code>*state*</code>, a struct that determines all parameters for forward
and backward dataflow.
</p>
</div>

<ul class="org-ul">
<li><a id="org86eda2c"></a>The global state<br />
<div class="outline-text-6" id="text-org86eda2c">
<p>
The <code>global-state</code> struct maintains the current function on which the analysis
is being performed and the functions that have already been analyzed.  It
defines several functions that steer the analysis for forward or backward
dataflow.  It maintains slot values for functions that determine whether a
parameter of the function is written or read on the device.  Finally, it
maintains state per function in maps (hash-tables).  This allows us to use the
macro <code>with-func-state</code> that will automatically give us the <code>cfgraph</code>, <code>out</code>,
etc. for the current function.
</p>

<p>
The fields <code>current-func</code> and <code>funcs-done-set</code> keep track of which function is
or has to be analyzed.  The struct then defines several functions.  Since many
functions are symmetric, we only discuss one of them.  Furthermore, some
functions, for example <code>exit-</code> functions are exit functions on the forward pass
and <code>entry-</code> functions on the backward pass:
</p>
<dl class="org-dl">
<dt><code>transfers-before/after-func</code></dt><dd>returns the transfers to be placed before a
basic block</dd>
<dt><code>exit-transfers-func</code></dt><dd>gives the exit transfers, the transfers that exit a
function.</dd>
<dt><code>transfers-from-device-without-to-caller-before-func</code></dt><dd>gives the transfers
from device without the transfers that can be done inside the caller, the
function that calls a function.  The <code>transfers-before-func</code> above gives
for each block the transfers that have to be placed.  However, in some
cases, the transfers can be handled by the calling function.  The function
<code>transfers-from-device-without-to-caller-before</code> removes those transfers
and leaves them to the higher function.</dd>
<dt><code>exit-func</code></dt><dd>gives the exit (or entry) node of the control flow graph.</dd>
<dt><code>insert-transfer-func</code></dt><dd>a function that decides whether the transfers
should be transfers <b>to</b> the device or transfers <b>from</b> the device.</dd>
<dt><code>insert-before-func</code></dt><dd>decides whether a transfer should be placed before a
basic block or after a basic block.  The other function does the opposite
of this one.</dd>
</dl>

<p>
The struct holds a variable for the <code>on-device-variables</code> for a function.  The
slot can be the <code>exit-on-device-variables</code> or <code>entry-on-device-variables</code>
depending on the direction of the analysis.  This slot in a function indicates
which <i>on-device-</i>, but also which <i>on-host-</i> variables are available
before/after a call to the function.
</p>

<p>
The struct then defines several maps.  The key for the map is the current
function, so state is maintained for each function about:
</p>
<dl class="org-dl">
<dt><code>cfgraph</code></dt><dd>the control-flow-graph</dd>
<dt><code>exit-transfers</code></dt><dd>the device variables on exit (or entry in the other
direction).</dd>
<dt><code>transfers</code></dt><dd>the transfers that could be inserted at some point.</dd>
<dt><code>transfers-outside-func-set</code></dt><dd>contains the entry/exit-on-device variables
of a called function translated to the ones in the calling function minus
the transfers of the block.  In general it contains the transfers that
should be done outside of the called function.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defstruct</span> <span style="color: #228b22;">global-state</span>
  current-func
  funcs-done-set

  <span style="color: #b22222;">;; </span><span style="color: #b22222;">functions</span>
  transfers-before-func
  transfers-after-func
  exit-transfers-func
  transfers-from-device-without-to-caller-before-func
  transfers-from-device-without-to-caller-after-func
  exit-func
  insert-transfer-func
  insert-before-func
  insert-after-func

  <span style="color: #b22222;">;; </span><span style="color: #b22222;">slots</span>
  on-device-variables

  <span style="color: #b22222;">;; </span><span style="color: #b22222;">per func state</span>
  cfgraph-map
  exit-transfers-map
  transfers-map
  transfers-outside-func-set-map)
</pre>
</div>

<p>
We can initialize the state with the following function, setting several
variables to the versions for both forward and backward analysis:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-initial-global-state</span> (transfers-before-func transfers-after-func
                                  exit-transfers-func
                                  transfers-from-device-without-to-caller-before-func
                                  transfers-from-device-without-to-caller-after-func
                                  exit-func insert-transfer-func
                                  insert-before-func
                                  insert-after-func

                                  on-device-variables)
  (make-global-state
   <span style="color: #483d8b;">:current-func</span> nil
   <span style="color: #483d8b;">:funcs-done-set</span> (make-set)

   <span style="color: #483d8b;">:transfers-before-func</span> transfers-before-func
   <span style="color: #483d8b;">:transfers-after-func</span> transfers-after-func
   <span style="color: #483d8b;">:exit-transfers-func</span> exit-transfers-func
   <span style="color: #483d8b;">:transfers-from-device-without-to-caller-before-func</span>
   transfers-from-device-without-to-caller-before-func
   <span style="color: #483d8b;">:transfers-from-device-without-to-caller-after-func</span>
   transfers-from-device-without-to-caller-after-func
   <span style="color: #483d8b;">:exit-func</span> exit-func
   <span style="color: #483d8b;">:insert-transfer-func</span> insert-transfer-func
   <span style="color: #483d8b;">:insert-before-func</span> insert-before-func
   <span style="color: #483d8b;">:insert-after-func</span> insert-after-func

   <span style="color: #483d8b;">:on-device-variables</span> on-device-variables

   <span style="color: #483d8b;">:cfgraph-map</span> (make-hash-table)
   <span style="color: #483d8b;">:transfers-map</span> (make-hash-table)
   <span style="color: #483d8b;">:exit-transfers-map</span> (make-hash-table)
   <span style="color: #483d8b;">:transfers-outside-func-set-map</span> (make-hash-table)))
</pre>
</div>

<p>
The following functions initialize the state for forward and backward dataflow:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-global-state-forward</span> ()
  (make-initial-global-state #'transfers-from-device-before
                             #'transfers-from-device-after
                             #'exit-transfers
                             #'xfers-from-device-w/o-to-caller-xfers-before
                             #'xfers-from-device-w/o-to-caller-xfers-after
                             #'exit
                             #'insert-transfer-from
                             #'insert-before-ast
                             #'insert-after-ast
                             'exit-on-device-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-global-state-backward</span> ()
  (make-initial-global-state #'transfers-to-device-before
                             #'transfers-to-device-after
                             #'entry-transfers
                             #'xfers-to-device-w/o-to-caller-xfers-before
                             #'xfers-to-device-w/o-to-caller-xfers-after
                             #'entry
                             #'insert-transfer-to
                             #'insert-before-ast
                             #'insert-after-ast
                             'entry-on-device-variables))
</pre>
</div>
</div>
</li>

<li><a id="orgfb4c987"></a>The entry point<br />
<div class="outline-text-6" id="text-orgfb4c987">
<p>
The analysis has several phases.  First, we initialize the global state
variables.  The second phase analyzes each call and records which
on-device-variables should be transfered before or after the call, or within
the called function.  This phase has to occur before generating the actual
transfers, because multiple calls of the same function may have different
requirements.  The final phase inserts all the transfers.
</p>

<p>
The function below is the entry point.  We use optimistic control-flow graphs,
which means that foreach loops are regarded as one basic block and for-loops
are assumed to iterate at least one time.  The global state is set up two
times, one for the forward analysis and one for the backward analysis.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*state*</span> nil)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-transfers</span> (callgraph)
  (log-micro-pass <span style="color: #8b2252;">"generate-transfers"</span> callgraph)
  (set-optimistic-cfgraphs callgraph)

  (<span style="color: #a020f0;">let*</span> ((funcs-ordered (funcs-ordered callgraph))
         (root-funcs (tops-callgraph callgraph))
         (state-forward (make-global-state-forward))
         (state-backward (make-global-state-backward)))
    (setf *state* state-forward)
    (populate-global-state (reverse funcs-ordered))
    (setf *state* state-backward)
    (populate-global-state (reverse funcs-ordered))


    (setf *state* state-forward)
    (<span style="color: #a020f0;">with-slots</span> (transfers-after-func) *state*
      (analyze-calls-funcs funcs-ordered transfers-after-func)
      (<span style="color: #a020f0;">dolist</span> (root-func root-funcs) (generate-transfers-func root-func)))

    (setf *state* state-backward)
    (<span style="color: #a020f0;">with-slots</span> (transfers-before-func) *state*
      (analyze-calls-funcs funcs-ordered transfers-before-func)
      (<span style="color: #a020f0;">dolist</span> (root-func root-funcs) (generate-transfers-func root-func)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">set-optimistic-cfgraphs</span> (callgraph)
  (<span style="color: #a020f0;">loop</span> for f in (funcs-ordered callgraph)
     do (set-cfgraphs:set-cfgraphs f t t)))
</pre>
</div>
</div>
</li>


<li><a id="orgc14e4ee"></a>Phase 1: Populating the global state<br />
<div class="outline-text-6" id="text-orgc14e4ee">
<p>
To generate transfers, we first have to analyze the callgraph from leaf nodes
to the root.  For each function, we register whether device-variables are
available at entry or exit.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">populate-global-state</span> (ordered-funcs)
  (<span style="color: #a020f0;">dolist</span> (func ordered-funcs) (populate-global-state-func func)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">populate-global-state-func</span> (func)
  (<span style="color: #a020f0;">with-slots</span> (current-func exit-transfers-func) *state*
    (setf current-func func)

    (with-func-state (exit-transfers cfgraph transfers-outside-func-set)
      (setf cfgraph (cfgraph func))
      (setf transfers-outside-func-set (make-dataflow-set))

      (setf exit-transfers (funcall exit-transfers-func cfgraph)))))
</pre>
</div>
</div>
</li>


<li><a id="org84d0b54"></a><span class="todo TODO">TODO</span> Phase 2: Analyzing the calls<br />
<div class="outline-text-6" id="text-org84d0b54">
<p>
The following phase analyzes the function from the root function and all the
called functions.  For each function we record whether transfers should be done
outside of the function.  <b>Update this:</b> If it is clear that a variable is
indeed handled in the called function, then we record this for other calls in
<code>transfers-done-outside-func-set</code>.  The process is explained below.  The
functions below analyze each basic block for being a call:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze-calls-funcs</span> (funcs transfers-func)
  (<span style="color: #a020f0;">dolist</span> (func funcs) (analyze-calls-func func transfers-func)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze-calls-func</span> (func transfers-func)
  (<span style="color: #a020f0;">with-slots</span> (current-func funcs-done-set) *state*
    (setf current-func func)
    (with-func-state (cfgraph transfers)
      (setf transfers (funcall transfers-func cfgraph))
      (<span style="color: #a020f0;">loop</span> for bb in (basic-blocks cfgraph)
         do (analyze-basic-block bb)))))

</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze-basic-block</span> (bb)
  (<span style="color: #a020f0;">when</span> (call-p bb)
    (analyze-call bb)))
</pre>
</div>

<p>
When analyzing a call, we have to make a distinction between the calling-func
and the called-func.  The main goal of the code below is to record what
transfers can be performed outside of the called function.  As soon it is
beneficial for the calling function to place the transfers in the calling
function, this will be recorded for the called function in
<code>transfers-outside-func-set</code>.
</p>

<p>
A situation where it is beneficial to move transfers from the called to the
calling function is illustrated below:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000ff;">f</span>(out) {
  foreach(out)
}

<span style="color: #0000ff;">g</span>(out) {
  f(out);
  f(out);
}
</pre>
</div>

<p>
Placing the transfers in <code>f()</code> would lead to unnecessary transfers, it is
better to place the transfers in <code>g()</code> before and after the two calls.
</p>

<p>
To determine the transfers that can be performed outside of the function, we
retrieve the <code>on-device-variables</code> that are available on entry or exit of the
called function.  This set represents the <code>on-device-variables</code> that can be
moved outside of the called function, into the calling function.  We store this
in <code>device-variables-called-func</code>.  
</p>

<p>
We have to compare this set with the <code>on-device-variables</code> that can be
performed at the block of the call.  Therefore, we have to transform the
<code>device-variables-called-func</code> with each <code>on-device-variable</code> containing a
declaration of the called func, to <code>on-device-variables</code> with declarations of
the calling funcs.  We then subtract the <code>transfers-block-calling-func</code> that
represents the transfers that in principal could be done at the block of the
call from the <code>device-variables-called-func</code>.  If there is a block with a call
to the function that does not have transfers of <code>-on-device-variables</code> that are
available on entry or exit, then it means that it is better to perform the
transfers in the calling function.  Therefore, we store the difference of
<code>device-variables-called-func</code> and <code>transfers-block-calling-func</code> in the result
set <code>transfers-outside-func-set-called-func</code>.  Before we do that we have to
transform the declarations back to the declarations of the called function.
</p>

<p>
<b>This has to be propagated back to where the transfers originate from, so back
up the call chain&#x2026;</b>
</p>

<p>
In the example above, there would be transfers to the device at the first call
to <code>f()</code> in <code>g()</code>.  Therefore we subtract those transfers from what is
available at entry in <code>f()</code>, which is <code>out</code>.  This means that nothing is added
to <code>transfers-outside-func-set-called-func</code>.  However, at the second call to
<code>f()</code> in <code>g()</code>, there will be no transfers to the device.  This means that
<code>out</code> will be added to <code>transfers-outside-func-set-called-func</code>.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze-call</span> (bb)
  (<span style="color: #a020f0;">with-slots</span> (on-device-variables transfers-outside-func-set-map) *state*
    (with-func-state (transfers)
      (<span style="color: #a020f0;">let*</span> ((call (call (stat bb)))
             (called-func (func call))
             (calling-func (get-func call))
             (transfers-block-calling-func (gethash bb transfers))
             (transfers-outside-func-set-called-func
              (gethash called-func transfers-outside-func-set-map))
             (transfers-outside-func-set-calling-func
              (gethash calling-func transfers-outside-func-set-map)))
        (<span style="color: #a020f0;">unless</span> (builtin-func-p call)
          (<span style="color: #a020f0;">let</span> ((device-variables-called-func
                 (filter #'(<span style="color: #a020f0;">lambda</span> (x) (typep x 'on-device-variable))
                         (slot-value called-func on-device-variables))))
            (add-all-to-set
             (dataflow-variables-calling-func-&gt;called-func 
              (elements
               (union
                (set-difference
                 (make-dataflow-set (dataflow-variables-called-func-&gt;calling-func
                                     device-variables-called-func
                                     call))
                 transfers-block-calling-func)
                (intersection
                 transfers-outside-func-set-calling-func
                 transfers-block-calling-func)))
              call)
             transfers-outside-func-set-called-func)))))))
</pre>
</div>
</div>
</li>



<li><a id="org0029c24"></a>Phase 3: Generating the transfers<br />
<div class="outline-text-6" id="text-org0029c24">
<p>
In <code>generate-transfers-func</code> we determine the transfers that should be inserted
in the given function.  This means that we have to exclude transfers that can
be done by the caller.  This is determined in <code>compute-transfers-before/after</code>.
We then just generate the transfers based on all the generation functions that
have been set in the global state.  
</p>

<p>
This function sets the current function for using <code>with-func-state</code> and we make
sure that each function is only done once.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-transfers-func</span> (func)
  (<span style="color: #a020f0;">with-slots</span> (current-func funcs-done-set) *state*
    (<span style="color: #a020f0;">unless</span> (contains-p funcs-done-set func)
      (setf current-func func)
      (with-func-state (cfgraph transfers-outside-func)
        <span style="color: #b22222;">;;</span><span style="color: #b22222;">(break)</span>
        (<span style="color: #a020f0;">let</span> ((transfers-before (compute-transfers-before))
              (transfers-after (compute-transfers-after)))
          (<span style="color: #a020f0;">loop</span> for bb in (basic-blocks cfgraph)
             do (gen-transfer-bb-before bb transfers-before)
               (gen-transfer-bb-after bb transfers-after))
          (add-to-set func funcs-done-set))))))
</pre>
</div>

<p>
The following two functions compute the transfers that have to be inserted
before and after a statement respectively.  It calls the function 
<code>transfers-from-device-without-to-caller-before</code> or <code>-after</code>.  These two
functions return a map of the transfers that have to be inserted within this
function excluding the function that will be done by the calling function.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-transfers-before</span> ()
  (<span style="color: #a020f0;">with-slots</span> (transfers-from-device-without-to-caller-before-func) *state*
    (compute-transfers transfers-from-device-without-to-caller-before-func)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-transfers-after</span> ()
  (<span style="color: #a020f0;">with-slots</span> (transfers-from-device-without-to-caller-after-func) *state*
    (compute-transfers transfers-from-device-without-to-caller-after-func)))
</pre>
</div>

<p>
The <code>compute-transfers</code> function creates a <code>gen</code> set for the
<code>transfers-from-device-without-to-caller-before</code> or <code>-after</code> functions.  The
<code>gen</code> function is formed by the <code>exit-tranfers</code> intersected with the
<code>transfers-outside-func-set</code>, or the transfers that can be done outside of this
function.  This results in a <code>gen</code> function that will filter out the transfers
that can be performed in the caller.  With this <code>gen</code> set we call the
<code>transfers-from-device-without-to-caller</code> functions.  The analysis is explained
later in this document.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">compute-transfers</span> (transfers-from-device-w/o-to-caller-func)
  (with-func-state (cfgraph exit-transfers transfers-outside-func-set)
    (<span style="color: #a020f0;">let</span> ((gen (remove-transfers
                cfgraph exit-transfers transfers-outside-func-set)))
      (funcall transfers-from-device-w/o-to-caller-func cfgraph gen))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-transfers</span> (cfgraph exit-transfers to-remove)
  (<span style="color: #a020f0;">with-slots</span> (exit-func) *state*
    (<span style="color: #a020f0;">let</span> ((exit-transfers (gethash (funcall exit-func cfgraph) exit-transfers))
          (map (empty-dataflow-map cfgraph)))
      (setf (gethash (funcall exit-func cfgraph) map)
            (intersection exit-transfers to-remove))
      map)))
</pre>
</div>

<p>
The following function generate transfers before or after a basic block.  For
transfers before a basic block, it is not possible to place a transfer before
an <code>entry</code> block.  Placing a transfer before an <code>exit</code> block is problematic
because there is no AST form associated with an <code>exit</code> block.  Therefore we
retrieve the (only) predecessor of the <code>exit</code> block and place a transfer after
the predecessor.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-transfer-bb-before</span> (bb transfers))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb-before</span> ((bb bb) transfers)
  (<span style="color: #a020f0;">with-slots</span> (insert-before-func) *state*
    (gen-transfer-bb bb transfers insert-before-func)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb-before</span> ((bb bb-exit) transfers)
  (gen-transfer-bb-before/after bb transfers
                                #'gen-transfer-bb-after #'predecessors))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb-before</span> ((bb bb-entry) transfers)
  nil)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-transfer-bb-after</span> (bb transfers))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb-after</span> ((bb bb) transfers)
  (<span style="color: #a020f0;">with-slots</span> (insert-after-func) *state*
    (gen-transfer-bb bb transfers insert-after-func)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb-after</span> ((bb bb-entry) transfers)
  (gen-transfer-bb-before/after bb transfers
                                #'gen-transfer-bb-before #'successors))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb-after</span> ((bb bb-exit) transfers)
  nil)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-transfer-bb-before/after</span> (bb transfers func pred/succ-func)
  (with-func-state (cfgraph)
    (<span style="color: #a020f0;">let</span> ((transfers (copy-hash-table transfers))
          (pred/succ (first (funcall pred/succ-func bb cfgraph))))
      (setf (gethash pred/succ transfers) (gethash bb transfers))
      (funcall func pred/succ transfers))))
</pre>
</div>

<p>
The following generic function uses an insertion function to place transfers
before or after a basic block.  The generic case retrieves the AST of the basic
block, transforms the transfers to declarations and generates the transfers.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">gen-transfer-bb</span> (bb transfers insert-func))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb</span> ((bb bb) transfers insert-func)
  (gen-transfer-with-decls (get-ast-basic-block bb)
                           (transfers-&gt;decls (gethash bb transfers))
                           insert-func))
</pre>
</div>

<p>
If the basic block is a statement we do something special when the statement is
a call function, otherwise we fall back to the generic case.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb</span> ((bb bb-stat) transfers insert-func)
  (<span style="color: #a020f0;">let*</span> ((stat (stat bb)))
    (<span style="color: #a020f0;">if</span> (typep stat 'call-stat)
        (gen-transfer-call (call stat) bb transfers insert-func)
        (call-next-method))))
</pre>
</div>

<p>
When we find a call, we recursively generate the transfers for the called
function.  After that, in the current function, we retrieve the transfers that
can be done outside the called function and inside the calling function, we
intersect that with the transfers that should be done in the call anyway and
insert them. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-transfer-call</span> (call bb transfers insert-func)
  (<span style="color: #a020f0;">unless</span> (builtin-func-p call)
    (<span style="color: #a020f0;">let</span> ((called-func (func call)))
      (with-new-func-state called-func
        (generate-transfers-func called-func))
      (<span style="color: #a020f0;">with-slots</span> (transfers-outside-func-set-map) *state*
        (<span style="color: #a020f0;">let</span> ((transfers-outside-called-func
               (gethash called-func transfers-outside-func-set-map)))
          (gen-transfer-with-decls
           (get-ast-basic-block bb)
           (cl:intersection
            (dataflow-variables-&gt;decls-calling-func
             (elements transfers-outside-called-func) call)
            (transfers-&gt;decls (gethash bb transfers)))
           insert-func))))))
</pre>
</div>

<p>
We do a special trick with for-loops if the insert function is the insert after
function.  We switch to the insert-before function.  This has to do with how a
for-loop is built up in the AST.  
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">gen-transfer-bb</span> ((bb bb-for-decl) transfers insert-func)
  (<span style="color: #a020f0;">with-slots</span> (insert-before-func insert-after-func) *state*
    (<span style="color: #a020f0;">if</span> (eq insert-func insert-after-func)
        (gen-transfer-bb bb transfers insert-before-func)
        (call-next-method))))
</pre>
</div>

<p>
The following functions perform the real insertion into the AST.  It sorts the
declarations and removes duplicates before inserting.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-transfer-with-decls</span> (ast decls insert-func)
  (<span style="color: #a020f0;">with-slots</span> (insert-transfer-func) *state*
    (<span style="color: #a020f0;">let</span> ((decls (sort (remove-duplicates decls) #'ast&lt;)))
      (<span style="color: #a020f0;">dolist</span> (d decls)
        (funcall insert-transfer-func d ast insert-func)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-transfer-to</span> (decl ast insert-func)
  (<span style="color: #a020f0;">let</span> ((transfer (create-host-&gt;device-transfer decl)))
    (funcall insert-func ast transfer)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-transfer-from</span> (decl ast insert-func)
  (<span style="color: #a020f0;">let</span> ((transfer (create-device-&gt;host-transfer decl)))
    (funcall insert-func ast transfer)))
</pre>
</div>
</div>
</li>


<li><a id="orgcbb5c94"></a>Dataflow solutions<br />
<div class="outline-text-6" id="text-orgcbb5c94">
<p>
The following function constitute various dataflow solutions.  This is where
the real analysis happens.
</p>

<p>
The code below determines the blocks which need a transfer from or to the
device.  There are two possibilities, putting a transfers after a block and
putting a transfers in front of a block (before).  The analysis is symmetric,
so this text will discusses everything in terms of transfers to the device.  In
the end, we want a mapping from basic blocks to a set of <code>on-device-variables</code>.
For each on-device-variable, we will generate a transfer.
</p>

<p>
The easiest way of thinking about generating a transfer-to-device is as
follows:  As soon a block generates an on-device-variable, we have to put a
transfer in front of it.  However, this should not be done if the variable is
<i>reaching</i>, which means that the variable may already be on the device:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transfers-to-device-before</span> (cfgraph)
  (dataflow-difference (gen-on-device-variables-in-w/o-use cfgraph)
                       (in-set (reaching-on-device-variables cfgraph))))
</pre>
</div>

<p>
The following example illustrates why we do not generate a transfer when the
on-device-variable is reaching, or may be available:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000ff;">foreach</span>(out,in)
<span style="color: #0000ff;">foreach</span>(out,in)
</pre>
</div>

<p>
Both foreach statements generate <code>out</code> and <code>in</code> in the IN direction, but there
should only be a transfer-to before the first.  So, an exception to the rule
above is when an on-device-variable is already available (the
on-device-variable is certain to be on the device).  Actually, this is not
precise enough.  The exception should be when the on-device-variables is
reaching (the on-device-variable may be on the device).  This is clear in the
following situation:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">if</span> (...) {
  statement1;
  statement2;
}
<span style="color: #a020f0;">else</span> {
  foreach(out)
}
<span style="color: #0000ff;">foreach</span>(out)
</pre>
</div>

<p>
In this case we prefer to have transfers to before the foreach in the else
branch, but not before the last foreach.  To make it correct, we should add
transfers-to at the end of the <i>then</i> clause of the if-statement, after
<code>statement2</code> (we assume here that these statements do not need transfers).  At
the last foreach statement, out is not available (guaranteed to be on the
device), but it is reaching (may be on the device).  Therefore we need to
subtract the reaching set from the gen set.  So, in summary, the function
<code>transfers-to-device-before</code> creates on-device-variables if a block generates
an on-device-variable, unless this variable is reaching.
</p>

<p>
The previous example also shows why we need a <code>transfers-to-device-after</code>.  We
want to place transfers to the device as late as possible in the <i>then</i> clause,
after <code>statement2</code>.  The following function defines
<code>transfers-to-device-after</code>: 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transfers-to-device-after</span> (cfgraph)
  (dataflow-intersection
   (dataflow-difference
    (latest-on-device-kills cfgraph)
    (reaching-on-device-variables cfgraph))
   (out-set (live-on-device-variables cfgraph))))
</pre>
</div>

<p>
It finds the latest on-device kills, the points in the graph where a kill has
to take place as late as possible.  The kill of a device variable represents a
point where transfers to the device can happen (at a very late point).
However, there should only be transfers to the device if the on-device
variables are not reaching, following a similar argument as with
<code>transfers-to-device-before</code>.   Furthermore, if the on-device-variables are not
live, (may be available at a later point), then the transfers should also not
take place.  
</p>

<p>
The following example shows why we need to intersect it with the live
on-device-variables, or the variables that may be expected to be on the device
at a later stage.  If we don't intersect with the live variables, the
<code>transfers-to-device-after</code> will generate a transfer to the device after <code>out =
0;</code>.  However, this is not necessary since the variable is not live.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">if</span> (...) {
  foreach(out)
  out = 0;
}
<span style="color: #a020f0;">else</span> {
  foreach(out)
}
</pre>
</div>

<p>
The latest on-device kills are formed by comparing the late kills with the
successor values of the late kills.  The successor-values are formed by the
union of the on-device variables of each successor.  If we take the difference,
we get the blocks after which we can place a transfer-to provided the
conditions stated before.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">latest-on-device-kills</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((late-kills (late-on-device-kills cfgraph)))
    (dataflow-difference late-kills
                         (get-successor-values late-kills cfgraph))))
</pre>
</div>

<p>
The late on-device kills use as generator set the kills in the OUT direction
and the IN values of the reaching on-device variables.  Since this is a forward
dataflow equation, we need the OUT of the kills.  We need the IN set of the
reaching on-device variables because we need to kill the kills as soon as
possible.  Otherwise, we would end up with kills that are too late.  We use the
universal set (all dataflow values) of kill for the values for the <code>entry</code>
basic block, in other words, we assume that the entry already kills everything
with dummy kills that can move forward through the flow graph.  By assuming
everything is already killed, we can also place the latest transfer without the
need of actually killing a variable.  The following two examples show the
difference.  In the first example, there will be a late kill after <code>out = 0</code>
because the statement kills.  However, in the second example there would be no
such late kill because nothing is killed.  This is mitigated by using dummy
kill values for the <code>entry</code> block.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">if</span> (...) {
  foreach(out)
  out = 0;
}
<span style="color: #a020f0;">else</span> {
  foreach(out)
}
<span style="color: #0000ff;">foreach</span>(out)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #a020f0;">if</span> (...) {
  foreach(out)
}
<span style="color: #a020f0;">else</span> {
  foreach(out)
}
<span style="color: #0000ff;">foreach</span>(out)
</pre>
</div>

<p>
We use a union to let the dataflow values go as far as possible without
interference from other paths that do not have kills.  The function is listed
below:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">late-on-device-kills</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (kill-on-device-variables-out cfgraph))
        (kill (in-set (reaching-on-device-variables cfgraph))))
    (dataflow-forward
     cfgraph (universal-set kill) (make-dataflow-set)
     #'(<span style="color: #a020f0;">lambda</span> (bb v)
         (union (gethash bb gen) (set-difference v (gethash bb kill))))
     #'union)))
</pre>
</div>

<p>
The following functions are completely symmetric but just for transfers from
the device:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transfers-from-device-after</span> (cfgraph)
  (dataflow-difference (gen-on-device-variables-out-w/o-use cfgraph)
                       (out-set (live-on-device-variables cfgraph))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transfers-from-device-before</span> (cfgraph)
  (dataflow-intersection
   (dataflow-difference
    (earliest-on-device-kills cfgraph)
    (live-on-device-variables cfgraph))
   (in-set (reaching-on-device-variables cfgraph))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">earliest-on-device-kills</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((early-kills (early-on-device-kills cfgraph)))
    (dataflow-difference early-kills
                         (get-predecessor-values early-kills cfgraph))))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">early-on-device-kills</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (kill-on-device-variables-in cfgraph))
        (kill (out-set (live-on-device-variables cfgraph))))
    (dataflow-backward
     cfgraph (universal-set kill) (make-dataflow-set)
     #'(<span style="color: #a020f0;">lambda</span> (bb v)
         (union (gethash bb gen) (set-difference v (gethash bb kill))))
     #'union)))
</pre>
</div>


<p>
The following two functions retrieve, based on a <code>gen</code> set, the transfers to
the device excluding the transfers that can be performed by the calling
function.  This is based on the <code>gen</code> set that contains the on-device variables
that can be moved to the caller, the transfers-to the device that represents
the transfers if no transfers could be moved to the caller, and the function
<code>to-caller-transfers-to-device</code>. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">xfers-to-device-w/o-to-caller-xfers-before</span> (cfgraph gen)
  (xfers-to/from-device-w/o-to-caller-xfers
   cfgraph gen #'transfers-to-device-before
   #'to-caller-transfers-to-device))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">xfers-to-device-w/o-to-caller-xfers-after</span> (cfgraph gen)
  (xfers-to/from-device-w/o-to-caller-xfers
   cfgraph gen #'transfers-to-device-after
   #'to-caller-transfers-to-device))
</pre>
</div>

<p>
The following function removes the transfers that can be moved to the caller
from all the transfers:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">xfers-to/from-device-w/o-to-caller-xfers</span> (cfgraph gen
                                                 transfers-to/from-device
                                                 to-caller-transfers)
  (<span style="color: #a020f0;">let</span> ((transfers (funcall transfers-to/from-device cfgraph))
        (to-caller (funcall to-caller-transfers cfgraph gen)))
    <span style="color: #b22222;">;;</span><span style="color: #b22222;">(break)</span>
    (dataflow-difference transfers to-caller)))
</pre>
</div>

<p>
The <code>to-caller-transfers-to-device</code> is based on the <code>gen</code> set, the <code>entry</code>
block, the transfers to the device before and after and it is a forward
dataflow problem:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">to-caller-transfers-to-device</span> (cfgraph gen)
  (to-caller-transfers-from/to-device
   cfgraph gen #'entry #'transfers-to-device-before
   #'transfers-to-device-after #'dataflow-forward))
</pre>
</div>

<p>
The following function returns the transfers that are moved to the caller.  The
result should be a map of the transfers that can be moved.  Note that this
should only be the transfers in the beginning of the function, not transfers
that have to be performed again because of a kill.
</p>

<p>
The <code>gen</code> set is formed by the entry transfers of the function intersected with
the transfers that can be moved to the caller, so in other words, we do not
generate transfers that are not exported from the function.  As <code>kill</code> set we
use all possible transfers.  From then on, we do a forward dataflow with as
start values the dataflow-variables in the entry block.  We try to flow these
variables as far as possible in the most restrictive way, namely they can only
flow further if all paths contain it (using intersection).  We find the
end-result by taking the difference between the IN and OUT set, which means
that if an entry dataflow-variable is killed in a block, then this is a
transfer that can be moved to the caller.
</p>

<p>
It may be possible that the entry set is already the kill set.  In that case,
the dataflow analysis will not give the proper result because of the boundary
conditions at the entry.  Therefore, if the <code>gen</code> set is not empty and the
result of the dataflow is empty, then the transfers that can move to the caller
are in the entry function.  We then just return the <code>gen</code> set which represents
the transfers that can move to the caller but cannot travel further.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">to-caller-transfers-from/to-device</span> (cfgraph gen entry
                                           transfers-from-device-before
                                           transfers-from-device-after
                                           dataflow-forward)
  (<span style="color: #a020f0;">let</span> ((entry-bb (funcall entry cfgraph))
        (kill (dataflow-union (funcall transfers-from-device-before cfgraph)
                              (funcall transfers-from-device-after cfgraph))))
    (<span style="color: #a020f0;">multiple-value-bind</span> (out in)
        (funcall dataflow-forward cfgraph (gethash entry-bb gen)
                 (universal-set gen)
                 #'(<span style="color: #a020f0;">lambda</span> (bb v)
                     (union (gethash bb gen)
                                (set-difference v (gethash bb kill))))
                 #'intersection)
      (<span style="color: #a020f0;">let</span> ((difference-in-out (dataflow-difference in out)))
        (<span style="color: #a020f0;">if</span> (and (empty-dataflow-map-p difference-in-out)
                 (not (empty-dataflow-map-p gen)))
            gen
            difference-in-out)))))
</pre>
</div>

<p>
The following functions do the same and are completely symmetric:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">xfers-from-device-w/o-to-caller-xfers-before</span> (cfgraph gen)
  (xfers-to/from-device-w/o-to-caller-xfers
   cfgraph gen #'transfers-from-device-before
   #'to-caller-transfers-from-device))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">xfers-from-device-w/o-to-caller-xfers-after</span> (cfgraph gen)
  (xfers-to/from-device-w/o-to-caller-xfers
   cfgraph gen #'transfers-from-device-after
   #'to-caller-transfers-from-device))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">to-caller-transfers-from-device</span> (cfgraph gen)
  (to-caller-transfers-from/to-device
   cfgraph gen #'exit #'transfers-from-device-before
   #'transfers-from-device-after #'dataflow-backward))
</pre>
</div>
</div>
</li>






<li><a id="org7210678"></a>Helper functions<br />
<div class="outline-text-6" id="text-org7210678">
<p>
The following functions convert dataflow-variables from calling function to
called function and vice-versa:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">dataflow-variables-&gt;decls-calling-func</span> (dataflow-variables call)
  (mapcar #'(<span style="color: #a020f0;">lambda</span> (dv) (decl-called-func-&gt;calling-func (decl dv) call))
          dataflow-variables))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transfers-&gt;decls</span> (transfers)
  (mapcar #'decl (elements transfers)))
</pre>
</div>

<p>
The following functions create the transfers:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-host-&gt;device-transfer</span> (decl)
  (create-transfer <span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span> decl))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun create-allocation (decl)</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(create-transfer "mcl_builtin_allocate_on_device" decl))</span>

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-device-&gt;host-transfer</span> (decl)
  (create-transfer <span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span> decl))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(defun create-deallocation (decl)</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(create-transfer "mcl_builtin_deallocate_on_device" decl))</span>

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-transfer</span> (name-function decl)
  (make-call-stat
   (make-call
    (make-id name-function)
    (list 
     (make-var-expr (make-normal-var
                     (make-basic-var (make-id (name (get-id decl))) nil)))))))
</pre>
</div>

<p>
The following function give the entry/exit transfers but filter the on-host
variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">entry-transfers</span> (cfgraph)
  <span style="color: #8b2252;">"Returns the transfers that are anticipated on entry in the function."</span>
  (entry/exit-transfers cfgraph #'entry-on-device-variables-cfgraph))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">exit-transfers</span> (cfgraph)
  <span style="color: #8b2252;">"Returns the transfers that are available on exit in the function."</span>
  (entry/exit-transfers cfgraph #'exit-on-device-variables-cfgraph))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">entry/exit-transfers</span> (cfgraph exit-on-device-variables)
  <span style="color: #8b2252;">"Returns the transfers that are anticipated on entry in the function."</span>
  (filter-dataflow-map
   #'(<span style="color: #a020f0;">lambda</span> (x)
       (not (member (type-of x) '(use-on-host-variable def-on-host-variable))))
   (funcall exit-on-device-variables cfgraph)))
</pre>
</div>

<p>
Whether a basic block is call:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">call-p</span> (bb)
  (and (typep bb 'bb-stat) (typep (stat bb) 'call-stat)))
</pre>
</div>
</div>
</li>
</ul>
</div>



<div id="outline-container-org45395a9" class="outline-5">
<h5 id="org45395a9"><span class="section-number-5">7.10.1.3</span> Macros</h5>
<div class="outline-text-5" id="text-7-10-1-3">
<p>
The macro <code>with-func-state</code> translates states to the actual call into the maps:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">eval-when</span> (<span style="color: #483d8b;">:compile-toplevel</span> <span style="color: #483d8b;">:load-toplevel</span> <span style="color: #483d8b;">:execute</span>)
  (<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-symbol</span> (slot)
    `(,slot (gethash (global-state-current-func *state*)
                     (,(intern (format nil <span style="color: #8b2252;">"GLOBAL-STATE-~a-MAP"</span> slot))
                       *state*)))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-func-state</span> (slots <span style="color: #228b22;">&amp;body</span> body)
  `(<span style="color: #a020f0;">symbol-macrolet</span> (,@(<span style="color: #a020f0;">loop</span> for slot in slots collect (create-symbol slot)))
     ,@body))
</pre>
</div>

<p>
The following macro sets a new state and restores it to the old one when
exiting the scope:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-new-func-state</span> (func <span style="color: #228b22;">&amp;body</span> body)
  (with-gensyms (old-current-func)
    `(<span style="color: #a020f0;">with-slots</span> (current-func) *state*
       (<span style="color: #a020f0;">let</span> ((,old-current-func current-func))
         (setf current-func ,func)
         ,@body
         (setf current-func ,old-current-func)))))
</pre>
</div>
</div>
</div>


<div id="outline-container-org538e71d" class="outline-5">
<h5 id="org538e71d"><span class="section-number-5">7.10.1.4</span> Testing</h5>
<div class="outline-text-5" id="text-7-10-1-4">
</div>
<ul class="org-ul">
<li><a id="org6d62316"></a>The package<br />
<div class="outline-text-6" id="text-org6d62316">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-generate-transfers</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span>
        <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:check-types</span> <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:set-vars-written</span> <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:set-entry-exit-on-device-variables</span>
        <span style="color: #483d8b;">:generate-transfers</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-generate-transfers</span>))
</pre>
</div>
</div>
</li>

<li><a id="orgb5d9787"></a>The tests<br />
<div class="outline-text-6" id="text-orgb5d9787">
<p>
The top-level tests:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-suite generate-transfers <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite generate-transfers)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">(deftest test-generate-transfers ()</span>
<span style="color: #b22222;">;;   </span><span style="color: #b22222;">(combine-results</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-simple)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-host-writes)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-host-reads)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-multiple-foreach)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-if-statements)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-multiple-functions)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-sequences-of-calls)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-for-loops)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-local-variables)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-other-vars)</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">(test-tiles)))</span>
</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org3293a90"></a>Simple tests:<br />
<div class="outline-text-7" id="text-org3293a90">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite simple <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite simple)

(test simple
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="org29a3d1e"></a>Writes that occur on the host<br />
<div class="outline-text-7" id="text-org29a3d1e">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite host-writes <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite host-writes)
(test host-writes-only-read
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;"> }"</span>)))


(test host-writes-only-written
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
                     <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">}"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;"> }"</span>)))


(test host-writes-written-read
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">}"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;"> }"</span>)))
</pre>
</div>
</div>
</li>


<li><a id="org2bd6140"></a>Reads that occur on the host<br />
<div class="outline-text-7" id="text-org2bd6140">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite host-reads <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite host-reads)

(test host-reads-simple
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     const float f = output[0];</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     const float f = output[0];</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
                     <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     const float f = output[0];</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     const float f = output[0];</span>
<span style="color: #8b2252;"> }"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="org4e3dfd6"></a>Multiple foreach<br />
<div class="outline-text-7" id="text-org4e3dfd6">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite multiple-foreach <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite multiple-foreach)

(test multiple-foreach-simple
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>

<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">         output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>

<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">         output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>)))

(test multiple-foreach-reads
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>

<span style="color: #8b2252;">     const float f = input[0];</span>

<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>

<span style="color: #8b2252;">     const float f = input[0];</span>

<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>)))


(test multiple-foreach-writes
<span style="color: #b22222;">#|</span>
<span style="color: #b22222;">  (is </span>
<span style="color: #b22222;">        (transfers-ok (gen-transfers</span>
<span style="color: #b22222;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #b22222;">     foreach (const int i in n threads) {</span>
<span style="color: #b22222;">         output[i] = input[i];</span>
<span style="color: #b22222;">     }</span>

<span style="color: #b22222;">     input[0] = 2.0;</span>

<span style="color: #b22222;">     foreach (const int i in n threads) {</span>
<span style="color: #b22222;">         output[i] = input[i];</span>
<span style="color: #b22222;">     }</span>
<span style="color: #b22222;"> }")</span>
<span style="color: #b22222;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #b22222;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #b22222;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #b22222;">     foreach (const int i in n threads) {</span>
<span style="color: #b22222;">         output[i] = input[i];</span>
<span style="color: #b22222;">     }</span>

<span style="color: #b22222;">     input[0] = 2.0;</span>
<span style="color: #b22222;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #b22222;">     foreach (const int i in n threads) {</span>
<span style="color: #b22222;">         output[i] = input[i];</span>
<span style="color: #b22222;">     }</span>
<span style="color: #b22222;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #b22222;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #b22222;"> }"))</span>
<span style="color: #b22222;">|#</span>
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>

<span style="color: #8b2252;">     output[0] = 2.0;</span>

<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 2.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>

<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">       output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>

<span style="color: #8b2252;">     output[0] = 2.0;</span>

<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 2.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>)))




</pre>
</div>
</div>
</li>

<li><a id="org2ec325b"></a>Test if-statements<br />
<div class="outline-text-7" id="text-org2ec325b">
<p>
The if-statement logic has to be removed.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-suite if-statements <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite if-statements)

(test if-statements
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else { </span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else { </span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">       output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     const int a;</span>
<span style="color: #8b2252;">     output[0] = 0.0;</span>
<span style="color: #8b2252;">     const int b;</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else { </span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   const int c;</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">       output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     const int a;</span>
<span style="color: #8b2252;">     output[0] = 0.0;</span>
<span style="color: #8b2252;">     const int b;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   const int c;</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   const int a;</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     int b;</span>
<span style="color: #8b2252;">     output[0] = 0.0;</span>
<span style="color: #8b2252;">     int c;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else { </span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   const int a;</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     const int b;</span>
<span style="color: #8b2252;">     output[0] = 0.0;</span>
<span style="color: #8b2252;">     const int c;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">       output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     const int a;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else { </span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     const int a;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else { </span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (transfers-ok (gen-transfers
                 <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">    foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   output[0] = 1.0;</span>
<span style="color: #8b2252;">}</span>


<span style="color: #8b2252;">perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     int a;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   output[0] = 1.0;</span>
<span style="color: #8b2252;">}</span>


<span style="color: #8b2252;">perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     const int a;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="orgb9c37f2"></a>Multiple functions<br />
<div class="outline-text-7" id="text-orgb9c37f2">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite multiple-functions <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite multiple-functions)
(test simple
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))

</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(test host-writes-before
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">       f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(test host-writes-after
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(test different-calls
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   output[0] = 1.0;</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   output[0] = 1.0;</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   float[n] output2;</span>
<span style="color: #8b2252;">   f(n, output2, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   float[n] output2;</span>
<span style="color: #8b2252;">   f(n, output2, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   float[n] output2;</span>
<span style="color: #8b2252;">   f(n, output2, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   float[n] output2;</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output2);</span>
<span style="color: #8b2252;">   f(n, output2, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output2);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(test call-chains-simple
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))

  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   output[0] = 0.0;</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   output[0] = 0.0;</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))

  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   output[0] = 0.0;</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   output[0] = 0.0;</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   h(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   h(n, output, input);</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void i(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   h(n, output, input);</span>
<span style="color: #8b2252;">   h(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   f(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   g(n, output, input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void i(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   h(n, output, input);</span>
<span style="color: #8b2252;">   h(n, output, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(test call-chains-for-loops
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; n; i++) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   const int a;</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     g(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; n; i++) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   const int a;</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     g(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; n; i++) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>

<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     g(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; n; i++) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     g(n, output, input);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>)))
</pre>
</div>
</div>
</li>




<li><a id="orge817e0f"></a>Sequences of calls<br />
<div class="outline-text-7" id="text-orge817e0f">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite sequences-of-calls <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite sequences-of-calls)

(test simple
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
                     <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     const float f = input[0];</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     const float f = input[0];</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))


(test transfers
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     const float f = output[0];</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     const float f = output[0];</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;"> perfect void f1(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">         f1(n, output, input);</span>
<span style="color: #8b2252;">         f2(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f2(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);     </span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;"> perfect void f1(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);     </span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f2(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;"> perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">         f1(n, output, input);</span>
<span style="color: #8b2252;">         f2(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f2(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     input[0] = 1.0;</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);     </span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;"> perfect void f1(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);     </span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     f1(n, output, input);</span>
<span style="color: #8b2252;">     f2(n, output, input);</span>
<span style="color: #8b2252;"> }"</span>)))

</pre>
</div>
</div>
</li>

<li><a id="orgd726b3c"></a>For-loops<br />
<div class="outline-text-7" id="text-orgd726b3c">
<p>
The second test is not that ok.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-suite for-loops <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite for-loops)

(test simple
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
                     <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">         f(n, output, input);</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">         f(n, output, input);</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
                     <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     output[0] = 1.0;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">         f(n, output, input);</span>
<span style="color: #8b2252;">         output[0] = 1.0;</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">         f(n, output, input);</span>
<span style="color: #8b2252;">          output[0] = 1.0;</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))

(test swap
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output &lt;=&gt; input;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     output &lt;=&gt; input;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">      foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">         f(n, output, input);</span>
<span style="color: #8b2252;">         output &lt;=&gt; input;</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] = input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">         f(n, output, input);</span>
<span style="color: #8b2252;">         output &lt;=&gt; input;</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))


(test advanced
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>

<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">       output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>

<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     const float a = 2.0;</span>
<span style="color: #8b2252;">   }</span>

<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     const float a = 2.0;</span>
<span style="color: #8b2252;">   }</span>

<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>

<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     const float a = 2.0;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int j in n threads) {</span>
<span style="color: #8b2252;">     output[j] = input[j];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>

<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     const float a = 2.0;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="org07ee0de"></a>Local variables<br />
<div class="outline-text-7" id="text-org07ee0de">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite local-variables <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite local-variables)

(test local-variables
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     float result;</span>
<span style="color: #8b2252;">     result = input[i];</span>
<span style="color: #8b2252;">     output[i] = result;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     float result;</span>
<span style="color: #8b2252;">     result = input[i];</span>
<span style="color: #8b2252;">     output[i] = result;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="org4ce2c2f"></a>Other variables<br />
<div class="outline-text-7" id="text-org4ce2c2f">
<div class="org-src-container">
<pre class="src src-lisp">(test other-vars
  (is 
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     inputCopy[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = inputCopy[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(inputCopy);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     inputCopy[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = inputCopy[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(inputCopy);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   f(n, inputCopy, input);</span>
<span style="color: #8b2252;">   f(n, output, inputCopy);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   f(n, inputCopy, input);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">   f(n, output, inputCopy);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(inputCopy);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   f(n, inputCopy, input);</span>
<span style="color: #8b2252;">   g(n, output, inputCopy);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   f(n, inputCopy, input);</span>
<span style="color: #8b2252;">   g(n, output, inputCopy);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(inputCopy);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     output &lt;=&gt; input;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   h(n, inputCopy, input);</span>
<span style="color: #8b2252;">   g(n, output, inputCopy);</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output, float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   for (int i = 0; i &lt; 2; i++) {</span>
<span style="color: #8b2252;">     f(n, output, input);</span>
<span style="color: #8b2252;">     output &lt;=&gt; input;</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void h(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void k(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   h(n, inputCopy, input);</span>
<span style="color: #8b2252;">   g(n, output, inputCopy);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(inputCopy);</span>
<span style="color: #8b2252;"> }"</span>))
  (is (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">   float[n] inputCopy;</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     inputCopy[i] = input[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   inputCopy[0] = 0.0;</span>
<span style="color: #8b2252;">   foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">     output[i] = inputCopy[i];</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void g(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">    float[n] inputCopy;</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(inputCopy);</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        inputCopy[i] = input[i];</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_from_device(inputCopy);</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">    inputCopy[0] = 0.0;</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(inputCopy);</span>
<span style="color: #8b2252;">    foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">        output[i] = inputCopy[i];</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_from_device(inputCopy);</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;">"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="orgfaf1890"></a>Tiles<br />
<div class="outline-text-7" id="text-orgfaf1890">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite tiles <span style="color: #483d8b;">:in</span> generate-transfers)
(in-suite tiles)
(test tiles
  (is
    (transfers-ok (gen-transfers
<span style="color: #8b2252;">"perfect void f(const int h, const int w, float[h][w] output,</span>
<span style="color: #8b2252;">      const float[h][w] input) {</span>

<span style="color: #8b2252;">   for (int i = 0; i &lt; h; i++) {</span>
<span style="color: #8b2252;">     foreach (const int j in w threads) {</span>
<span style="color: #8b2252;">         output[j] = input[j];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }"</span>)
<span style="color: #8b2252;">"perfect void f(const int h, const int w, float[h][w] output, const float[h][w] input) {</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">    for (int i = 0; i &lt; h; i++) {</span>
<span style="color: #8b2252;">        foreach (const int j in w threads) {</span>
<span style="color: #8b2252;">            output[j] = input[j];</span>
<span style="color: #8b2252;">        }</span>
<span style="color: #8b2252;">    }</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">    mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}"</span>))
  (is (transfers-ok (gen-transfers
                     <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;"> }"</span>)
                    <span style="color: #8b2252;">"perfect void f(const int n, float[n] output, const float[n] input) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(input);</span>
<span style="color: #8b2252;">     foreach (const int i in n threads) {</span>
<span style="color: #8b2252;">         output[i] += input[i];</span>
<span style="color: #8b2252;">     }</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(input);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }"</span>)))
</pre>
</div>
</div>
</li>

<li><a id="org0f905b8"></a>Helper functions<br />
<div class="outline-text-7" id="text-org0f905b8">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">transfers-ok</span> (ast-with-generated-transfers string-wanted)
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "wanted:~%~a~%" (print-pretty:pp (string-&gt;ast string-wanted)))</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(format t "got:~%~a~%" (print-pretty:pp ast-with-generated-transfers))</span>
  (ast= ast-with-generated-transfers (string-&gt;ast string-wanted)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-transfers</span> (input-string)
  (<span style="color: #a020f0;">let*</span> ((module (string-&gt;ast input-string))
         (exports (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (set-parents module)
    (resolve-calls module exports)
    (resolve-vars module exports)
    (check-types module)
    (set-cfgraphs module t t)
    (<span style="color: #a020f0;">let</span> ((callgraph (set-callgraph (funcs (code module)))))
      (set-vars-written callgraph)
      (set-entry-exit-on-device-variables callgraph)
      (generate-transfers callgraph)
      module)))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*module-template*</span>
<span style="color: #8b2252;">"package a;</span>
<span style="color: #8b2252;"> module a;</span>
<span style="color: #8b2252;"> import perfect;</span>

<span style="color: #8b2252;"> ~a</span>
<span style="color: #8b2252;">"</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">string-&gt;ast</span> (input-string)
  (parse-mcpl (format nil *module-template* input-string)))
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org07a72d4" class="outline-4">
<h4 id="org07a72d4"><span class="section-number-4">7.10.2</span> Generate allocations</h4>
<div class="outline-text-4" id="text-7-10-2">
<p>
Generating allocations is more simple than generating transfers if this
dataflow solution is based on generating transfers.
</p>
</div>

<div id="outline-container-org48e68d7" class="outline-5">
<h5 id="org48e68d7"><span class="section-number-5">7.10.2.1</span> The package</h5>
<div class="outline-text-5" id="text-7-10-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:generate-allocations</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-graph</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:dataflow</span> <span style="color: #483d8b;">:controlflow</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:callgraph</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:simple-sets</span> <span style="color: #483d8b;">:union</span> <span style="color: #483d8b;">:set-difference</span> <span style="color: #483d8b;">:intersection</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:filter</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:generate-allocations</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgef8539d" class="outline-5">
<h5 id="orgef8539d"><span class="section-number-5">7.10.2.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-10-2-2">
<p>
The generating allocations and deallocations passes are completely symmetric.
Most of the code is written by assuming generating allocations.  Generating
allocations occurs in two phases.  First, we analyze the calls from the top
function and record whether allocations should be inserted in the calling
function or in the called function.  We then generate the allocations and
deallocations.  
</p>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-allocations</span> (callgraph)
  (<span style="color: #a020f0;">let</span> ((tops (tops-callgraph callgraph))
        (pass-info-allocations (make-pass-info-allocations))
        (pass-info-deallocations (make-pass-info-deallocations)))
    (<span style="color: #a020f0;">loop</span> for top in tops do
         (analyze-calls-func top pass-info-allocations nil)
         (analyze-calls-func top pass-info-deallocations nil))

    (<span style="color: #a020f0;">loop</span> for f in (funcs-ordered callgraph) do
         (generate-allocations-func f pass-info-allocations)
         (generate-allocations-func f pass-info-deallocations))))
</pre>
</div>


<p>
Because the passes are symmetric, we use a <code>pass-info</code> struct that contains the
data and functions to direct the computation towards allocation or deallocation.
</p>
</div>


<ul class="org-ul">
<li><a id="org641c07f"></a>Pass information<br />
<div class="outline-text-6" id="text-org641c07f">
<p>
The pass information struct contains several functions and a mapping from
function to allocations that can move to the calling function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defstruct</span> <span style="color: #228b22;">pass-info</span>
  allocations
  available-allocation-variables
  create-allocation
  insert-before-ast
  to-caller-allocations-map)
</pre>
</div>

<p>
For inserting the allocations we create the struct as follows:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-pass-info-allocations</span> ()
  (make-pass-info
   <span style="color: #483d8b;">:allocations</span> #'allocations
   <span style="color: #483d8b;">:available-allocation-variables</span> #'available-allocation-variables
   <span style="color: #483d8b;">:create-allocation</span> #'create-allocation
   <span style="color: #483d8b;">:insert-before-ast</span> #'insert-before-ast
   <span style="color: #483d8b;">:to-caller-allocations-map</span> (make-hash-table)))
</pre>
</div>

<p>
For inserting deallocations, we create the struct as follows:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-pass-info-deallocations</span> ()
  (make-pass-info
   <span style="color: #483d8b;">:allocations</span> #'deallocations
   <span style="color: #483d8b;">:available-allocation-variables</span> #'anticipated-deallocation-variables
   <span style="color: #483d8b;">:create-allocation</span> #'create-deallocation
   <span style="color: #483d8b;">:insert-before-ast</span> #'insert-after-ast
   <span style="color: #483d8b;">:to-caller-allocations-map</span> (make-hash-table)))
</pre>
</div>
</div>
</li>

<li><a id="org80abd64"></a>Analyzing calls<br />
<div class="outline-text-6" id="text-org80abd64">
<p>
The first phase of the analysis aims to record which allocations should be
performed by the calling function.  We recursively analyze this using the top
of the callgraph.  As soon as we encounter a call statement, we recurse into
that function.  To ensure we only analyze each function once, we keep track of
functions already analyzed.  The allocations that can move to the caller is
defined to be the set of available-allocation-variables minus the set of
allocations.  This means that if there is a call that does not have
allocations, but they are available, then the allocations have already happened
and the allocations should always move to the caller.
</p>

<p>
The function also initializes the <code>to-caller-allocations-map</code> when necessary.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">analyze-calls-func</span> (func pass-info funcs-done)
  (<span style="color: #a020f0;">unless</span> (member func funcs-done)
    (<span style="color: #a020f0;">with-slots</span> (available-allocation-variables to-caller-allocations-map
                                                allocations)
        pass-info
      (<span style="color: #a020f0;">let*</span> ((cfgraph (cfgraph func))
             (to-caller (dataflow-difference
                         (funcall available-allocation-variables cfgraph)
                         (funcall allocations cfgraph)))
             (bbs (mapcar #'element (vertexes cfgraph))))
        (create-dataflow-set-func func pass-info)
        (push func funcs-done)
        (<span style="color: #a020f0;">loop</span> for bb in bbs when (call-to-non-builtin bb)
           do (add-to-caller-allocations
               bb (gethash bb to-caller) pass-info)
             (analyze-calls-func
              (func (call (stat bb))) pass-info funcs-done))))))
</pre>
</div>

<p>
The following function adds the allocations that should go to the caller to the
<code>pass-info</code> datastructure.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">add-to-caller-allocations</span> (bb available-dataflow-variables pass-info)
  (<span style="color: #a020f0;">with-slots</span> (to-caller-allocations-map) pass-info
    (<span style="color: #a020f0;">let*</span> ((call (call (stat bb)))
           (func (func call))
           (call-variables
            (get-call-variables (elements available-dataflow-variables)
                                call))
           (to-caller-allocations (dataflow-variables-calling-func-&gt;called-func
                                   call-variables call)))
      (create-dataflow-set-func func pass-info)
      (add-all-to-set to-caller-allocations
                      (gethash func to-caller-allocations-map)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-call-variables</span> (dataflow-variables call)
  (<span style="color: #a020f0;">let*</span> ((decls (mapcar #'get-decl-param (params call))))
    (filter #'(<span style="color: #a020f0;">lambda</span> (dfv) (member (decl dfv) decls)) dataflow-variables)))
</pre>
</div>

<p>
The following function creates an empty dataflow set for a function when
necessary.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-dataflow-set-func</span> (func pass-info)
  (<span style="color: #a020f0;">with-slots</span> (to-caller-allocations-map) pass-info
    (<span style="color: #a020f0;">unless</span> (gethash func to-caller-allocations-map)
      (setf (gethash func to-caller-allocations-map)
            (make-dataflow-set)))))
</pre>
</div>
</div>
</li>


<li><a id="orgb3658b6"></a>Generating the allocations<br />
<div class="outline-text-6" id="text-orgb3658b6">
<p>
The function below inserts allocations for each basic block unless the
allocations are known to be handled by the calling function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-allocations-func</span> (func pass-info)
  (<span style="color: #a020f0;">with-slots</span> (called-by) func
    (<span style="color: #a020f0;">unless</span> (and called-by
                 (<span style="color: #a020f0;">loop</span> for c in called-by always (call-expr-p c)))
      (<span style="color: #a020f0;">with-slots</span> (allocations to-caller-allocations-map) pass-info
        (<span style="color: #a020f0;">let*</span> ((cfgraph (cfgraph func))
               (allocations-map (funcall allocations cfgraph))
               (to-caller (gethash func to-caller-allocations-map)))
          (<span style="color: #a020f0;">loop</span> for bb being the hash-keys in allocations-map
             using (hash-value allocation-set)
             do (insert-allocations-bb
                 bb (set-difference allocation-set to-caller) pass-info)))))))
</pre>
</div>

<p>
The following function insert allocations based on whether it is a call to
another function.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-allocations-bb</span> (bb allocations-set pass-info)
  (<span style="color: #a020f0;">with-slots</span> (insert-before-ast create-allocation) pass-info
    (<span style="color: #a020f0;">if</span> (call-to-non-builtin bb)
        (insert-allocations-call bb allocations-set pass-info)
        (insert-allocations-bb-regular bb allocations-set pass-info))))
</pre>
</div>

<p>
If the basic block is a call to a non-builtin function, we retrieve the
allocations that should be done by the caller (transforming the declarations
from the called function to the caller) and intersect that with the allocations
that should happen at this basic block.  This ensures that we generate the
allocations that should be moved to the caller and that we do not generate
these allocations in places where it is not necessary.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-allocations-call</span> (bb allocations-set pass-info)
  (<span style="color: #a020f0;">with-slots</span> (to-caller-allocations-map) pass-info
    (<span style="color: #a020f0;">let*</span> ((call (call (stat bb)))
           (to-caller (make-dataflow-set
                       (dataflow-variables-called-func-&gt;calling-func
                        (elements
                         (gethash (func call) to-caller-allocations-map))
                        call))))
      (insert-allocations-bb-regular
       bb (intersection allocations-set to-caller) pass-info))))
</pre>
</div>

<p>
The following function just inserts the allocations in <code>allocations-set</code> at
basic block <code>bb</code> using the functions that are stored in <code>pass-info</code>. 
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">insert-allocations-bb-regular</span> (bb allocations-set pass-info)
  (<span style="color: #a020f0;">with-slots</span> (insert-before-ast create-allocation) pass-info
    (<span style="color: #a020f0;">loop</span> for allocation in (elements allocations-set)
           do (funcall insert-before-ast
                       (stat bb)
                       (funcall create-allocation (decl allocation))))))
</pre>
</div>


<p>
The following functions create the actual allocations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-allocation</span> (decl)
  (create-allocation-with-name <span style="color: #8b2252;">"mcl_builtin_allocate_on_device"</span> decl))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-deallocation</span> (decl)
  (create-allocation-with-name <span style="color: #8b2252;">"mcl_builtin_deallocate_on_device"</span> decl))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-allocation-with-name</span> (name-function decl)
  (make-call-stat
   (make-call
    (make-id name-function)
    (list 
     (make-var-expr (make-normal-var
                     (make-basic-var (make-id (name (get-id decl))) nil)))))))
</pre>
</div>
</div>
</li>

<li><a id="org0a287e9"></a>The dataflow solutions<br />
<div class="outline-text-6" id="text-org0a287e9">
<p>
Essentially, there is only one dataflow analysis necessary.  The first function
<code>allocations</code> makes use of <code>available-allocation-variables</code> discussed below.
The analysis <code>allocation</code> indicates per basic block which allocations should be
performed (without taking into account whether the allocations can be moved to
the caller).  The allocations are defined to be the difference between the OUT
and IN set of available-allocation-variables.  This means that if an allocation
is not available before a basic block but it is available after the basic
block, then an allocation should happen:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">allocations</span> (cfgraph)
  (<span style="color: #a020f0;">multiple-value-bind</span> (out in) (available-allocation-variables cfgraph)
    (dataflow-difference out in)))
</pre>
</div>

<p>
The <code>available-allocation-variables</code> is simply a forward dataflow where
allocations that are generated at certain basic blocks are simply propogated
through the graph (they don't get killed).
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">available-allocation-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-allocation-variables cfgraph))
        (kill (empty-dataflow-map cfgraph)))
    (must-forward cfgraph gen kill)))
</pre>
</div>

<p>
Generating allocation variables looks for basic blocks that are calls with name
"mcl<sub>builtin</sub><sub>transfer</sub><sub>to</sub><sub>device</sub>":
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-allocation-variables</span> (cfgraph)
  (gen-de/allocation-variables cfgraph <span style="color: #8b2252;">"mcl_builtin_transfer_to_device"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-de/allocation-variables</span> (cfgraph name-builtin-func)
  (<span style="color: #a020f0;">let</span> ((bbs (mapcar #'element (vertexes cfgraph)))
        (map (make-hash-table)))
    (<span style="color: #a020f0;">dolist</span> (bb bbs)
      (<span style="color: #a020f0;">let</span> ((set (make-dataflow-set)))
        (get-allocation-vars-from-bb bb set name-builtin-func)
        (setf (gethash bb map) set)))
    map))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-allocation-vars-from-bb</span> (bb set name-builtin-func)
  (<span style="color: #a020f0;">when</span> (and (typep bb 'bb-stat)
             (typep (stat bb) 'call-stat))
    (get-allocation-vars-from-call (call (stat bb)) set name-builtin-func)))
</pre>
</div>

<p>
When the call is the call we are looking for, we create the allocation
variable, if the call is another builtin function, we leave it allone,
otherwise we gather the allocation variables that are generated within the
called function, translate the declarations to declarations of the caller and
add them to the allocations of the basic block:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-allocation-vars-from-call</span> (call set name-builtin-func)
  (<span style="color: #a020f0;">with-slots</span> (id params func) call
    (<span style="color: #a020f0;">cond</span> ((string= (name id) name-builtin-func)
           (add-to-set (make-allocation-variable
                        (get-decl-param (first params))) <span style="color: #ff0000; font-weight: bold;">set))</span>
          ((builtin-func-p call))
          (t
           (get-allocation-vars-from-called-func call set name-builtin-func)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-allocation-vars-from-called-func</span> (call set name-builtin-func)
  (<span style="color: #a020f0;">with-slots</span> (func) call
    (<span style="color: #a020f0;">let</span> ((allocation-vars-called-func
           (elements
            (universal-set
             (gen-de/allocation-variables
              (cfgraph func) name-builtin-func)))))
      (add-all-to-set
       (dataflow-variables-called-func-&gt;calling-func
        (filter #'(<span style="color: #a020f0;">lambda</span> (allocation-var)
                    (decl-called-func-in-calling-func-p (decl allocation-var)
                                                        call))
                allocation-vars-called-func)
        call)
       set))))
</pre>
</div>

<p>
The following code makes allocation variables:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">allocation-variable</span> (dataflow-variable) ())

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-allocation-variable</span> (decl)
  (make-instance 'allocation-variable <span style="color: #483d8b;">:decl</span> decl))
</pre>
</div>



<p>
The following functions are similar but then for deallocations:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">deallocations</span> (cfgraph)
  (<span style="color: #a020f0;">multiple-value-bind</span> (in out) (anticipated-deallocation-variables cfgraph)
    (dataflow-difference in out)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">anticipated-deallocation-variables</span> (cfgraph)
  (<span style="color: #a020f0;">let</span> ((gen (gen-deallocation-variables cfgraph))
        (kill (empty-dataflow-map cfgraph)))
    (must-backward cfgraph gen kill)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-deallocation-variables</span> (cfgraph)
  (gen-de/allocation-variables cfgraph <span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span>))
</pre>
</div>
</div>
</li>

<li><a id="org590214c"></a>Helper functions<br />
<div class="outline-text-6" id="text-org590214c">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">call-to-non-builtin</span> (bb)
  (and (typep bb 'bb-stat)
       (<span style="color: #a020f0;">let</span> ((stat (stat bb)))
         (and (typep stat 'call-stat)
              (not (builtin-func-p (call stat)))))))
</pre>
</div>
</div>
</li>
</ul>
</div>



<div id="outline-container-org27233a7" class="outline-5">
<h5 id="org27233a7"><span class="section-number-5">7.10.2.3</span> Testing generating allocations</h5>
<div class="outline-text-5" id="text-7-10-2-3">
</div>
<ul class="org-ul">
<li><a id="org51c4eae"></a>The package<br />
<div class="outline-text-6" id="text-org51c4eae">
<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-generate-allocations</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:test-mcl</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span> <span style="color: #483d8b;">:generate-allocations</span>
        <span style="color: #483d8b;">:parse-mcpl</span> <span style="color: #483d8b;">:set-parents</span> <span style="color: #483d8b;">:resolve-calls</span> <span style="color: #483d8b;">:set-callgraph</span> <span style="color: #483d8b;">:resolve-vars</span>
        <span style="color: #483d8b;">:set-cfgraphs</span> <span style="color: #483d8b;">:set-vars-written</span>)
  (<span style="color: #483d8b;">:shadowing-import-from</span> <span style="color: #483d8b;">:fiveam</span> <span style="color: #483d8b;">:skip</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:test-generate-allocations</span>))
</pre>
</div>
</div>
</li>

<li><a id="org976aff3"></a>The tests<br />
<div class="outline-text-6" id="text-org976aff3">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite generate-allocations <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite generate-allocations)

(test generate-allocations
  (is (allocations-ok (gen-allocations
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_allocate_on_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_deallocate_on_device(output);</span>
<span style="color: #8b2252;">}"</span>))
  (is (allocations-ok (gen-allocations
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_allocate_on_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_deallocate_on_device(output);</span>
<span style="color: #8b2252;">}"</span>))
  (is (allocations-ok (gen-allocations
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_allocate_on_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_deallocate_on_device(output);</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (allocations-ok (gen-allocations
                   <span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_allocate_on_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_deallocate_on_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)
  (is (allocations-ok (gen-allocations
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     f(n, output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     f(n, output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   if (0 == 0) {</span>
<span style="color: #8b2252;">     mcl_builtin_allocate_on_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">     f(n, output);</span>
<span style="color: #8b2252;">     mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">     mcl_builtin_deallocate_on_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;">   else {</span>
<span style="color: #8b2252;">     mcl_builtin_allocate_on_device(output);</span>
<span style="color: #8b2252;">     f(n, output);</span>
<span style="color: #8b2252;">     mcl_builtin_deallocate_on_device(output);</span>
<span style="color: #8b2252;">   }</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>))
  (is (allocations-ok (gen-allocations
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;"> }</span>

<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)
<span style="color: #8b2252;">"perfect void f(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_to_device(output);</span>
<span style="color: #8b2252;">   mcl_builtin_transfer_from_device(output);</span>
<span style="color: #8b2252;">}</span>
<span style="color: #8b2252;"> perfect void g(const int n, float[n] output) {</span>
<span style="color: #8b2252;">   mcl_builtin_allocate_on_device(output);</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;">   f(n, output);</span>
<span style="color: #8b2252;">   mcl_builtin_deallocate_on_device(output);</span>
<span style="color: #8b2252;"> }</span>
<span style="color: #8b2252;">"</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">allocations-ok</span> (ast-with-generated-allocations string-wanted)
  (ast= ast-with-generated-allocations (string-&gt;ast string-wanted)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen-allocations</span> (input-string)
  (<span style="color: #a020f0;">let*</span> ((module (string-&gt;ast input-string))
         (exports (make-hash-table <span style="color: #483d8b;">:test</span> 'equal)))
    (set-parents module)
    (resolve-calls module exports)
    (<span style="color: #a020f0;">let</span> ((callgraph (set-callgraph (funcs (code module)))))
      (resolve-vars module exports)
      (set-cfgraphs module nil t)
      (set-vars-written callgraph)
      (generate-allocations callgraph)
      module)))

(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*module-template*</span>
<span style="color: #8b2252;">"package a;</span>
<span style="color: #8b2252;"> module a;</span>
<span style="color: #8b2252;"> import perfect;</span>

<span style="color: #8b2252;"> ~a</span>
<span style="color: #8b2252;">"</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">string-&gt;ast</span> (input-string)
  (parse-mcpl (format nil *module-template* input-string)))

</pre>
</div>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org373222e" class="outline-4">
<h4 id="org373222e"><span class="section-number-4">7.10.3</span> Remove unnecessary transfers</h4>
<div class="outline-text-4" id="text-7-10-3">
</div>
<div id="outline-container-orga671dfc" class="outline-5">
<h5 id="orga671dfc"><span class="section-number-5">7.10.3.1</span> The package</h5>
<div class="outline-text-5" id="text-7-10-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:remove-unnecessary-transfers</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:ast</span> <span style="color: #483d8b;">:ast-mcpl</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:remove-unnecessary-transfers</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d1548a" class="outline-5">
<h5 id="org6d1548a"><span class="section-number-5">7.10.3.2</span> The functionality</h5>
<div class="outline-text-5" id="text-7-10-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">remove-unnecessary-transfers</span> (module)
  (visit module #'remove-transfers-fw #'remove-transfers-bw))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">remove-transfers-fw</span> (ast))
(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">remove-transfers-bw</span> (ast))

(defvisitor remove-transfers-fw ast (ast string symbol list number)
  t)
(defvisitor remove-transfers-bw ast (ast string symbol list number)
  nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">remove-transfers-fw</span> ((call-stat call-stat))
  (<span style="color: #a020f0;">let</span> ((call (call call-stat)))
    (<span style="color: #a020f0;">when</span> (and (builtin-func-p call)
               (string= (name (id call))
                        <span style="color: #8b2252;">"mcl_builtin_transfer_from_device"</span>)
               (not (written (get-decl-param (first (params call))))))
      (remove-from-ast call-stat)))
  t)
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org4a9c255" class="outline-2">
<h2 id="org4a9c255"><span class="section-number-2">8</span> Commandline</h2>
<div class="outline-text-2" id="text-8">
<p>
This section describes the commandline interface to <code>mcl</code>.  
</p>
</div>

<div id="outline-container-orge520d48" class="outline-3">
<h3 id="orge520d48"><span class="section-number-3">8.1</span> The package</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:mcl-commandline</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:clon</span> <span style="color: #483d8b;">:clon-completion</span> <span style="color: #483d8b;">:mcl</span> <span style="color: #483d8b;">:errors</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:cl-fad</span> <span style="color: #483d8b;">:list-directory</span> <span style="color: #483d8b;">:pathname-as-directory</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:alexandria</span> <span style="color: #483d8b;">:read-file-into-string</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:main</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org75707a9" class="outline-3">
<h3 id="org75707a9"><span class="section-number-3">8.2</span> Defining the commandline arguments</h3>
<div class="outline-text-3" id="text-8-2">
</div>

<div id="outline-container-org4f23bc7" class="outline-4">
<h4 id="org4f23bc7"><span class="section-number-4">8.2.1</span> Defining the commands and flags</h4>
<div class="outline-text-4" id="text-8-2-1">
<div class="org-src-container">
<pre class="src src-lisp">(defcommand <span style="color: #8b2252;">"list-targets"</span>
    (clon:defsynopsis (<span style="color: #483d8b;">:make-default</span> nil)
      (text <span style="color: #483d8b;">:contents</span> <span style="color: #8b2252;">"List the compilation targets."</span>)
      (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>
            <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print this help and exit."</span>)))

(defcommand <span style="color: #8b2252;">"list-hwd"</span>
    (clon:defsynopsis (<span style="color: #483d8b;">:make-default</span> nil)
      (text <span style="color: #483d8b;">:contents</span> <span style="color: #8b2252;">"List the available hardware descriptions."</span>)
      (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>
            <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print this help and exit."</span>)))

(defcommand <span style="color: #8b2252;">"gen-cpp"</span>
  (clon:defsynopsis (<span style="color: #483d8b;">:make-default</span> nil <span style="color: #483d8b;">:postfix</span> <span style="color: #8b2252;">"FILE"</span>) 
      (text <span style="color: #483d8b;">:contents</span> <span style="color: #8b2252;">"Generate C++ code."</span>)
      (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span> <span style="color: #483d8b;">:long-name</span> <span style="color: #8b2252;">"help"</span>
            <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print this help and exit."</span>)

      (stropt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"t"</span> <span style="color: #483d8b;">:long-name</span> <span style="color: #8b2252;">"target"</span>
                      <span style="color: #483d8b;">:argument-name</span> <span style="color: #8b2252;">"TARGET"</span> 
                      <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Create C++ code for target TARGET."</span>)
      (stropt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"o"</span>
              <span style="color: #483d8b;">:argument-name</span> <span style="color: #8b2252;">"OUTPUT-DIR"</span> <span style="color: #483d8b;">:env-var</span> <span style="color: #8b2252;">"MCL_OUTPUT_DIR"</span>
              <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"The directory where the files be created."</span>)
      (strlist <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"e"</span> <span style="color: #483d8b;">:long-name</span> <span style="color: #8b2252;">"entry-funcs"</span>
                      <span style="color: #483d8b;">:argument-name</span> <span style="color: #8b2252;">"ENTRY-FUNCS"</span>
                      <span style="color: #483d8b;">:description</span>
                      <span style="color: #8b2252;">"Create C++ code with entry functions ENTRY-FUNCS."</span>)))

(defcommand <span style="color: #8b2252;">"gen-cashmere"</span>
    (clon:defsynopsis (<span style="color: #483d8b;">:make-default</span> nil <span style="color: #483d8b;">:postfix</span> <span style="color: #8b2252;">"MCL-FILE..."</span>) 
        (text <span style="color: #483d8b;">:contents</span> <span style="color: #8b2252;">"Generate Cashmere code."</span>)
      (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>
            <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print this help and exit."</span>)
      (strlist <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"t"</span>
               <span style="color: #483d8b;">:argument-name</span> <span style="color: #8b2252;">"TARGETS"</span> <span style="color: #483d8b;">:argument-type</span> <span style="color: #483d8b;">:required</span>
               <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Create Cashmere code for targets TARGETS."</span>)
      (stropt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"o"</span>
              <span style="color: #483d8b;">:argument-name</span> <span style="color: #8b2252;">"OUTPUT-DIR"</span> <span style="color: #483d8b;">:env-var</span> <span style="color: #8b2252;">"MCL_OUTPUT_DIR"</span>
              <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"The directory where the files be created."</span>)))

(defcommand <span style="color: #8b2252;">"translate"</span>
    (clon:defsynopsis (<span style="color: #483d8b;">:make-default</span> nil <span style="color: #483d8b;">:postfix</span> <span style="color: #8b2252;">"MCL-FILE"</span>)
      (text <span style="color: #483d8b;">:contents</span> <span style="color: #8b2252;">"Translate to a lower-level hardware description."</span>)
      (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>
            <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print this help and exit"</span>)
      (stropt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"hwd"</span>
               <span style="color: #483d8b;">:argument-name</span> <span style="color: #8b2252;">"HARDWARE-DESCRIPTION"</span> <span style="color: #483d8b;">:argument-type</span> <span style="color: #483d8b;">:required</span>
               <span style="color: #483d8b;">:description</span> (format nil <span style="color: #8b2252;">"~a~a"</span> <span style="color: #8b2252;">"Translate to hardware "</span>
                                    <span style="color: #8b2252;">"description HARDWARE-DESCRIPTION"</span>))))

(defcommand <span style="color: #8b2252;">"print-ast-json"</span>
    (clon:defsynopsis (<span style="color: #483d8b;">:make-default</span> nil <span style="color: #483d8b;">:postfix</span> <span style="color: #8b2252;">"MCL-FILE"</span>)
      (text <span style="color: #483d8b;">:contents</span> <span style="color: #8b2252;">"Print the AST in JSON format."</span>)
      (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>
            <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print this help and exit"</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orge4af03e" class="outline-4">
<h4 id="orge4af03e"><span class="section-number-4">8.2.2</span> Defining the main synopsis</h4>
<div class="outline-text-4" id="text-8-2-2">
<div class="org-src-container">
<pre class="src src-lisp">(def-main-synopsis
  (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>
        <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print this help and exit."</span>)
  (lispobj <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"l"</span> <span style="color: #483d8b;">:argument-name</span> <span style="color: #8b2252;">"LOG-LEVEL"</span>
           <span style="color: #483d8b;">:argument-type</span> <span style="color: #483d8b;">:required</span> <span style="color: #483d8b;">:typespec</span> 'integer
           <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Set the log-level to LOG-LEVEL"</span> <span style="color: #483d8b;">:default-value</span> 0)
  (flag <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"v"</span> <span style="color: #483d8b;">:long-name</span> <span style="color: #8b2252;">"version"</span>
        <span style="color: #483d8b;">:description</span> <span style="color: #8b2252;">"Print the version number."</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf568ea1" class="outline-4">
<h4 id="orgf568ea1"><span class="section-number-4">8.2.3</span> Defining the completions</h4>
<div class="outline-text-4" id="text-8-2-3">
<div class="org-src-container">
<pre class="src src-lisp">(def-main-completions
  (<span style="color: #8b2252;">"-l"</span> <span style="color: #8b2252;">"0 1 2 3"</span>))

(def-command-completions <span style="color: #8b2252;">"translate"</span>
  (<span style="color: #8b2252;">"-hwd"</span> <span style="color: #8b2252;">"$(mcl list-hwd)"</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org555c043" class="outline-4">
<h4 id="org555c043"><span class="section-number-4">8.2.4</span> Defining the functions for the commands</h4>
<div class="outline-text-4" id="text-8-2-4">
<p>
The command <code>list-targets</code> shows a list of targets separated by a space.  The
targets are extracted from the <code>codegen</code> directory.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-command-func <span style="color: #8b2252;">"list-targets"</span>
  (<span style="color: #a020f0;">cond</span> ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>)
         (clon:help))
        (t
         (format t <span style="color: #8b2252;">"~{~a~^ ~}~%"</span> (get-targets)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-targets</span> ()
  (get-filenames-directory <span style="color: #8b2252;">"input/codegen/"</span>))
</pre>
</div>

<p>
The command <code>list-hwd</code> shows a list of hardware-descriptions.  The
hardware-descriptions are extracted from the <code>hdl</code> directory.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-command-func <span style="color: #8b2252;">"list-hwd"</span>
  (<span style="color: #a020f0;">cond</span> ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>)
         (clon:help))
        (t
         (format t <span style="color: #8b2252;">"~{~a~^ ~}~%"</span> (get-hardware-descriptions)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-hardware-descriptions</span> ()
  (get-filenames-directory <span style="color: #8b2252;">"input/hdl/"</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(def-command-func <span style="color: #8b2252;">"gen-cpp"</span> 
  (<span style="color: #a020f0;">cond</span> ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>)
         (clon:help))
        (t
         (<span style="color: #a020f0;">let</span> ((target (clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"t"</span>))
               (entry-funcs (clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"e"</span>))
               (output-dir (clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"o"</span>))
               (file (clon:remainder)))
           (<span style="color: #a020f0;">unless</span> target
             (exit-with <span style="color: #8b2252;">"Need to specify a target."</span>))
           (<span style="color: #a020f0;">unless</span> entry-funcs
             (exit-with <span style="color: #8b2252;">"Need to specify one or more entry functions."</span>))
           (<span style="color: #a020f0;">unless</span> (and file (eql (length file) 1))
             (exit-with <span style="color: #8b2252;">"Need to specify an MCL file"</span>))
           (<span style="color: #a020f0;">let</span> ((file (first file)))
             (generate-code file target entry-funcs output-dir))))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(def-command-func <span style="color: #8b2252;">"gen-cashmere"</span>
  (<span style="color: #a020f0;">cond</span> ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>)
         (clon:help))
        (t
         (<span style="color: #a020f0;">let</span> ((targets (clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"t"</span>))
               (output-dir (clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"o"</span>))
               (input-files (clon:remainder)))
           (<span style="color: #a020f0;">unless</span> targets
             (exit-with <span style="color: #8b2252;">"Need to specify one or more target."</span>))
           (<span style="color: #a020f0;">unless</span> input-files
             (exit-with <span style="color: #8b2252;">"Need to specify one or more files."</span>))
           (<span style="color: #a020f0;">unless</span> output-dir
             (exit-with <span style="color: #8b2252;">"Need to specify an output directory."</span>))
           (generate-cashmere-code input-files targets output-dir)))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(def-command-func <span style="color: #8b2252;">"translate"</span>
  (<span style="color: #a020f0;">cond</span> ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>)
         (clon:help))
        (t
         (<span style="color: #a020f0;">let</span> ((hwd (clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"hwd"</span>))
               (input-file (clon:remainder)))
           (<span style="color: #a020f0;">unless</span> hwd
             (exit-with <span style="color: #8b2252;">"Need to specify a hardware description."</span>))
           (<span style="color: #a020f0;">if</span> (= (length input-file) 1)
               (format t <span style="color: #8b2252;">"~a~%"</span> (translate (first input-file) hwd))
               (exit-with <span style="color: #8b2252;">"Need to specify an MCL file."</span>))))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(def-command-func <span style="color: #8b2252;">"print-ast-json"</span>
  (<span style="color: #a020f0;">cond</span> ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>)
         (clon:help))
        (t
         (<span style="color: #a020f0;">let</span> ((input-file (clon:remainder)))
           (<span style="color: #a020f0;">if</span> (= (length input-file) 1)
               (format t <span style="color: #8b2252;">"~a~%"</span> (print-ast-json (first input-file)))
               (exit-with <span style="color: #8b2252;">"Need to specify an MCL file."</span>))))))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">main</span> ()
  <span style="color: #8b2252;">"Entry point for the standalone application."</span>
  (clon:make-context)
  (<span style="color: #a020f0;">handler-case</span>
      (<span style="color: #a020f0;">progn</span> 
        (logging:initialize-logging)
        (logging:set-level (clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"l"</span>))
        (<span style="color: #a020f0;">cond</span> ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"h"</span>)
               (clon:help))
              ((clon:getopt <span style="color: #483d8b;">:short-name</span> <span style="color: #8b2252;">"v"</span>)
               (print-version))
              (t
               (<span style="color: #a020f0;">unless</span> (clon:remainder)
                 (exit-with <span style="color: #8b2252;">"Missing command."</span>))
               (dispatch)))
        (clon:exit))
    (mcl-error (e) (report-mcl-error e))))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">report-mcl-error</span> (<span style="color: #ff0000; font-weight: bold;">error</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">report-mcl-error</span> ((e mcl-error))
  (<span style="color: #a020f0;">with-slots</span> (loc text) e
    (<span style="color: #a020f0;">if</span> loc (print-mcl-error-with-loc loc text)
        (format t <span style="color: #8b2252;">"~a~%"</span> text))
    (clon:exit 1)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-mcl-error-with-loc</span> (loc text)
  (<span style="color: #a020f0;">destructuring-bind</span> ((start-position . end-position) filename) loc
    (<span style="color: #a020f0;">if</span> filename
        (print-mcl-error-with-file start-position end-position filename text)
        (format t <span style="color: #8b2252;">"between positions ~a and ~a~%"</span> start-position end-position))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">safe-index</span> (index string)
  (min (max index 0) (length string)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-newline</span> (string end)
  (<span style="color: #a020f0;">let*</span> ((end (safe-index end string))
         (position (position #\Newline string <span style="color: #483d8b;">:start</span> 0 <span style="color: #483d8b;">:end</span> end <span style="color: #483d8b;">:from-end</span> t)))
    (<span style="color: #a020f0;">if</span> position (1+ position) 0)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-mcl-error-with-file</span> (start-position end-position filename message)
  (<span style="color: #a020f0;">let*</span> ((file-as-string (read-file-into-string filename))
         (line-nr (1+ (count #\Newline file-as-string <span style="color: #483d8b;">:end</span> start-position)))
         (column-nr (- start-position (find-newline file-as-string start-position)))
         (width-arrows (max 1 (- end-position start-position))))
    (format *error-output* <span style="color: #8b2252;">"~a:~a:~a: error: ~a~%"</span> filename line-nr column-nr message)
    (<span style="color: #a020f0;">when</span> (= (count #\newline message) 0)
      (print-line-and-arrows line-nr column-nr width-arrows file-as-string))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-line-and-arrows</span> (line-nr column-nr width-arrows file-as-string)
  (<span style="color: #a020f0;">let*</span> ((lines (split-sequence:split-sequence #\newline file-as-string))
         (line (nth (1- line-nr) lines))
         (nr-tabs (count #\tab line <span style="color: #483d8b;">:end</span> column-nr)))
    (format *error-output* <span style="color: #8b2252;">"~a~%"</span> line)
    (format *error-output* <span style="color: #8b2252;">"~vt~v,,,'^a~%"</span> (+ column-nr (* (1- 8) nr-tabs)) width-arrows <span style="color: #8b2252;">""</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org38871c5" class="outline-4">
<h4 id="org38871c5"><span class="section-number-4">8.2.5</span> Utility functions</h4>
<div class="outline-text-4" id="text-8-2-5">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-filenames-directory</span> (directory)
  (mapcar #'pathname-name
          (list-directory
           (merge-pathnames
            directory
            (pathname-as-directory (sb-posix:getenv <span style="color: #8b2252;">"MCL_ROOT_DIR"</span>))))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org454f804" class="outline-2">
<h2 id="org454f804"><span class="section-number-2">9</span> The main module</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orgda50797" class="outline-3">
<h3 id="orgda50797"><span class="section-number-3">9.1</span> The MCL package</h3>
<div class="outline-text-3" id="text-9-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:mcl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:pass-library</span> <span style="color: #483d8b;">:passes</span>)
  (<span style="color: #483d8b;">:import-from</span> <span style="color: #483d8b;">:utility-directory</span> <span style="color: #483d8b;">:def-standard-class</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:semantic-analysis</span> <span style="color: #483d8b;">:sa</span>
           <span style="color: #483d8b;">:print-pretty</span> <span style="color: #483d8b;">:pp</span>
           <span style="color: #483d8b;">:generate-code</span> <span style="color: #483d8b;">:gen</span>
           <span style="color: #483d8b;">:generate-cashmere-code</span>
           <span style="color: #483d8b;">:print-version</span>
           <span style="color: #483d8b;">:*version*</span>
           <span style="color: #483d8b;">:translate</span>
           <span style="color: #483d8b;">:print-ast-json</span>
           <span style="color: #483d8b;">:print</span>))
</pre>
</div>
</div>
</div>


<div id="outline-container-org31ed7ac" class="outline-3">
<h3 id="org31ed7ac"><span class="section-number-3">9.2</span> The main file</h3>
<div class="outline-text-3" id="text-9-2">
<p>
The version:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*version*</span> <span style="color: #8b2252;">"0.1.3"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">semantic-analysis</span> (mcl-file-name)
  (run-pass 'semantic-analysis (list (cons 'semantic-analysis mcl-file-name))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">sa</span> ()
  (semantic-analysis <span style="color: #8b2252;">"input/mcpl/prnu_extract/prnu_extract.mcl"</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-pretty</span> (mcl-file-name)
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(enable-pass 'print-pretty 'remove-hardware-vars)</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(enable-pass 'print-pretty 'translate)</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(enable-pass 'print-pretty 'move-dimension-constants-out-foreach)</span>
  (enable-pass 'print-pretty 'flatten-types)
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(enable-pass 'print-pretty 'move-foreach-to-func)</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">(enable-pass 'print-pretty 'optimize-transfers)</span>
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">(enable-pass 'print-pretty 'generate-transfers)</span>
  (run-pass 'print-pretty (list (cons 'print-pretty mcl-file-name)
                                (cons 'translate <span style="color: #8b2252;">"gpu"</span>)
                                (cons 'semantic-analysis mcl-file-name))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">pp</span> ()
  (print-pretty <span style="color: #8b2252;">"input/mcpl/lib/fft/fft.mcl"</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-ast-json</span> (mcl-file-name <span style="color: #228b22;">&amp;optional</span> hwd)
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">(enable-pass 'print-ast-json 'translate)</span>
  (run-pass 'print-ast-json
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">(if hwd)</span>
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">(list (cons 'print-ast-json mcl-file-name)</span>
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">   (cons 'translate hwd)</span>
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">   (cons 'semantic-analysis mcl-file-name))</span>
            (list (cons 'print-ast-json mcl-file-name)
                  (cons 'semantic-analysis mcl-file-name))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print</span> ()
  (print-ast-json <span style="color: #8b2252;">"input/mcpl/matrixmultiplication/matrixmultiplication.mcl"</span>))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">translate</span> (mcl-file-name target)
  (enable-pass 'print-pretty 'translate)
  (run-pass 'print-pretty (list (cons 'semantic-analysis mcl-file-name)
                                (cons 'translate target)
                                (cons 'print-pretty mcl-file-name))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">flatten</span> (mcl-file-name target)
  (enable-pass 'print-pretty 'translate)
  (enable-pass 'print-pretty 'flatten-types)
  (run-pass 'print-pretty (list (cons 'semantic-analysis mcl-file-name)
                                (cons 'translate target)
                                (cons 'print-pretty mcl-file-name))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">generate-code</span> (mcl-file-name target entry-funcs output-dir)
  (run-pass 'generate-code (list (cons 'semantic-analysis mcl-file-name)
                                 (cons 'translate target)
                                 (cons 'generate-code
                                       (list <span style="color: #8b2252;">"cpp"</span> target entry-funcs
                                             output-dir)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">gen</span> ()
  (generate-code <span style="color: #8b2252;">"input/mcpl/matrixmultiplication/matrixmultiplication.mcl"</span> <span style="color: #8b2252;">"fermi"</span> (list <span style="color: #8b2252;">"matmul"</span>)
                 (mcl-util:getenv <span style="color: #8b2252;">"MCL_OUTPUT_DIR"</span>)))


(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-version</span> ()
  (format t <span style="color: #8b2252;">"Many-Core Levels (MCL) ~a~%"</span> *version*))
</pre>
</div>
</div>

<div id="outline-container-org16001ee" class="outline-4">
<h4 id="org16001ee"><span class="section-number-4">9.2.1</span> Generating Cashmere code</h4>
<div class="outline-text-4" id="text-9-2-1">
<p>
We store all the information about Cashmere code in the following
data-structure:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(def-standard-class cashmere-info ()
  (target call-code from-target java-code module))
</pre>
</div>

<p>
We define here what hardware we target:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">create-cashmere-info</span> (target messages module)
  (<span style="color: #a020f0;">destructuring-bind</span> (from-target parameters java-code) messages
    (make-instance 'cashmere-info
                   <span style="color: #483d8b;">:target</span> target
                   <span style="color: #483d8b;">:call-code</span> (format nil <span style="color: #8b2252;">"kl.launch(~a)"</span> parameters)
                   <span style="color: #483d8b;">:from-target</span> from-target
                   <span style="color: #483d8b;">:java-code</span> java-code
                   <span style="color: #483d8b;">:module</span> module)))
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">cashmere</span> ()
  (generate-cashmere-code
   (list
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">grayscale</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/grayscale/grayscale.mcl"</span> 
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">fastnoise</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/fastnoise/fastnoise1.mcl"</span> 
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/fastnoise/fastnoise2.mcl"</span> 
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">zeromean</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/zeromean/zeromean.mcl"</span> 
    <span style="color: #8b2252;">"input/mcpl/lib/util/transpose.mcl"</span> 
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">wiener</span>
    <span style="color: #8b2252;">"input/mcpl/lib/math/toComplex.mcl"</span> 
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/wiener/computeSquaredMagnitudes.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/wiener/computeVarianceEstimates.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/wiener/varianceZeroMean.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/wiener/scaleWithVariances.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/lib/math/toReal.mcl"</span> 
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">peak to correlation energy</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/peak_to_correlation_energy/toComplexAndFlip.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/peak_to_correlation_energy/crossCorrelate.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/peak_to_correlation_energy/findPeak.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/peak_to_correlation_energy/maxLocFloats.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/peak_to_correlation_energy/computeEnergy.mcl"</span>
    <span style="color: #8b2252;">"input/mcpl/prnu_extract/peak_to_correlation_energy/sumDoubles.mcl"</span>
    )
   (list <span style="color: #8b2252;">"fermi"</span>)
   (mcl-util:getenv <span style="color: #8b2252;">"MCL_OUTPUT_DIR"</span>)))

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org199a0fe" class="outline-3">
<h3 id="org199a0fe"><span class="section-number-3">9.3</span> Testing MCL</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-org492f9d1" class="outline-4">
<h4 id="org492f9d1"><span class="section-number-4">9.3.1</span> The package for testing</h4>
<div class="outline-text-4" id="text-9-3-1">
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:test-mcl</span>
  (<span style="color: #483d8b;">:use</span> <span style="color: #483d8b;">:cl</span> <span style="color: #483d8b;">:cl-log</span> <span style="color: #483d8b;">:mcl</span> <span style="color: #483d8b;">:fiveam</span>)
  (<span style="color: #483d8b;">:export</span> <span style="color: #483d8b;">:mcl-test-suite</span> <span style="color: #483d8b;">:test-mcl</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org2edd6a5" class="outline-4">
<h4 id="org2edd6a5"><span class="section-number-4">9.3.2</span> The main test file</h4>
<div class="outline-text-4" id="text-9-3-2">
<div class="org-src-container">
<pre class="src src-lisp">(def-suite mcl-test-suite)



(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">test-mcl</span> ()
  (with-logging-disabled
    (run! 'mcl-test-suite)))

(def-suite version <span style="color: #483d8b;">:in</span> mcl-test-suite)
(in-suite version)

(test version-ok
  (<span style="color: #a020f0;">let</span> ((filename-version (format nil <span style="color: #8b2252;">"~a/VERSION"</span> (mcl-util:getenv <span style="color: #8b2252;">"MCL_ROOT_DIR"</span>))))
    (is 
     (string= mcl:*version*
              (format nil (<span style="color: #a020f0;">with-open-file</span> (s filename-version)
                            (read-line s)))))))
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf37fe43" class="outline-2">
<h2 id="orgf37fe43"><span class="section-number-2">10</span> Copying <a id="orgb0d3680"></a></h2>
<div class="outline-text-2" id="text-10">
<p>
A system for programming many-cores on multiple levels of abstraction.
Copyright (C) 2018 Pieter Hijma
</p>

<p>
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
</p>

<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
</p>

<p>
You should have received a copy of the GNU General Public License
along with this program.  If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-06-17 Mon 11:54</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
